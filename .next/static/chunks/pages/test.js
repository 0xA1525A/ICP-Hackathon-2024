/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/test"],{

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/actor.js":
/*!***********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/actor.js ***!
  \***********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACTOR_METHOD_WITH_CERTIFICATE: () => (/* binding */ ACTOR_METHOD_WITH_CERTIFICATE),\n/* harmony export */   ACTOR_METHOD_WITH_HTTP_DETAILS: () => (/* binding */ ACTOR_METHOD_WITH_HTTP_DETAILS),\n/* harmony export */   Actor: () => (/* binding */ Actor),\n/* harmony export */   ActorCallError: () => (/* binding */ ActorCallError),\n/* harmony export */   AdvancedActor: () => (/* binding */ AdvancedActor),\n/* harmony export */   QueryCallRejectedError: () => (/* binding */ QueryCallRejectedError),\n/* harmony export */   UpdateCallRejectedError: () => (/* binding */ UpdateCallRejectedError),\n/* harmony export */   getManagementCanister: () => (/* binding */ getManagementCanister)\n/* harmony export */ });\n/* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer/ */ \"./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dfinity/candid */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/index.js\");\n/* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polling */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/index.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dfinity/principal */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./certificate */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _canisters_management_idl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./canisters/management_idl */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js\");\n\n\n\n\n\n\n\n\n\nclass ActorCallError extends _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError {\n    constructor(canisterId, methodName, type, props) {\n        super([\n            `Call failed:`,\n            `  Canister: ${canisterId.toText()}`,\n            `  Method: ${methodName} (${type})`,\n            ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n        ].join('\\n'));\n        this.canisterId = canisterId;\n        this.methodName = methodName;\n        this.type = type;\n        this.props = props;\n    }\n}\nclass QueryCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, result) {\n        var _a;\n        super(canisterId, methodName, 'query', {\n            Status: result.status,\n            Code: (_a = _agent__WEBPACK_IMPORTED_MODULE_1__.ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code \"${result.reject_code}\"`,\n            Message: result.reject_message,\n        });\n        this.result = result;\n    }\n}\nclass UpdateCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, requestId, response, reject_code, reject_message, error_code) {\n        super(canisterId, methodName, 'update', Object.assign({ 'Request ID': (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_6__.toHex)(requestId) }, (response.body\n            ? Object.assign(Object.assign({}, (error_code\n                ? {\n                    'Error code': error_code,\n                }\n                : {})), { 'Reject code': String(reject_code), 'Reject message': reject_message }) : {\n            'HTTP status code': response.status.toString(),\n            'HTTP status text': response.statusText,\n        })));\n        this.requestId = requestId;\n        this.response = response;\n        this.reject_code = reject_code;\n        this.reject_message = reject_message;\n        this.error_code = error_code;\n    }\n}\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nclass Actor {\n    constructor(metadata) {\n        this[metadataSymbol] = Object.freeze(metadata);\n    }\n    /**\n     * Get the Agent class this Actor would call, or undefined if the Actor would use\n     * the default agent (global.ic.agent).\n     * @param actor The actor to get the agent of.\n     */\n    static agentOf(actor) {\n        return actor[metadataSymbol].config.agent;\n    }\n    /**\n     * Get the interface of an actor, in the form of an instance of a Service.\n     * @param actor The actor to get the interface of.\n     */\n    static interfaceOf(actor) {\n        return actor[metadataSymbol].service;\n    }\n    static canisterIdOf(actor) {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(actor[metadataSymbol].config.canisterId);\n    }\n    static async install(fields, config) {\n        const mode = fields.mode === undefined ? { install: null } : fields.mode;\n        // Need to transform the arg into a number array.\n        const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n        // Same for module.\n        const wasmModule = [...new Uint8Array(fields.module)];\n        const canisterId = typeof config.canisterId === 'string'\n            ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromText(config.canisterId)\n            : config.canisterId;\n        await getManagementCanister(config).install_code({\n            mode,\n            arg,\n            wasm_module: wasmModule,\n            canister_id: canisterId,\n            sender_canister_version: [],\n        });\n    }\n    static async createCanister(config, settings) {\n        function settingsToCanisterSettings(settings) {\n            return [\n                {\n                    controllers: settings.controllers ? [settings.controllers] : [],\n                    compute_allocation: settings.compute_allocation ? [settings.compute_allocation] : [],\n                    freezing_threshold: settings.freezing_threshold ? [settings.freezing_threshold] : [],\n                    memory_allocation: settings.memory_allocation ? [settings.memory_allocation] : [],\n                    reserved_cycles_limit: [],\n                    log_visibility: [],\n                    wasm_memory_limit: [],\n                },\n            ];\n        }\n        const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({\n            amount: [],\n            settings: settingsToCanisterSettings(settings || {}),\n            specified_id: [],\n            sender_canister_version: [],\n        });\n        return canisterId;\n    }\n    static async createAndInstallCanister(interfaceFactory, fields, config) {\n        const canisterId = await this.createCanister(config);\n        await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));\n        return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));\n    }\n    static createActorClass(interfaceFactory, options) {\n        const service = interfaceFactory({ IDL: _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL });\n        class CanisterActor extends Actor {\n            constructor(config) {\n                if (!config.canisterId)\n                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError(`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n                const canisterId = typeof config.canisterId === 'string'\n                    ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromText(config.canisterId)\n                    : config.canisterId;\n                super({\n                    config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),\n                    service,\n                });\n                for (const [methodName, func] of service._fields) {\n                    if (options === null || options === void 0 ? void 0 : options.httpDetails) {\n                        func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n                    }\n                    if (options === null || options === void 0 ? void 0 : options.certificate) {\n                        func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n                    }\n                    this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n                }\n            }\n        }\n        return CanisterActor;\n    }\n    static createActor(interfaceFactory, configuration) {\n        if (!configuration.canisterId) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError(`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n        }\n        return new (this.createActorClass(interfaceFactory))(configuration);\n    }\n    /**\n     * Returns an actor with methods that return the http response details along with the result\n     * @param interfaceFactory - the interface factory for the actor\n     * @param configuration - the configuration for the actor\n     * @deprecated - use createActor with actorClassOptions instead\n     */\n    static createActorWithHttpDetails(interfaceFactory, configuration) {\n        return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(configuration);\n    }\n    /**\n     * Returns an actor with methods that return the http response details along with the result\n     * @param interfaceFactory - the interface factory for the actor\n     * @param configuration - the configuration for the actor\n     * @param actorClassOptions - options for the actor class extended details to return with the result\n     */\n    static createActorWithExtendedDetails(interfaceFactory, configuration, actorClassOptions = {\n        httpDetails: true,\n        certificate: true,\n    }) {\n        return new (this.createActorClass(interfaceFactory, actorClassOptions))(configuration);\n    }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n    const returnValues = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.decode(types, buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(msg));\n    switch (returnValues.length) {\n        case 0:\n            return undefined;\n        case 1:\n            return returnValues[0];\n        default:\n            return returnValues;\n    }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n    pollingStrategyFactory: _polling__WEBPACK_IMPORTED_MODULE_4__.strategy.defaultStrategy,\n};\nconst ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nconst ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\nfunction _createActorMethod(actor, methodName, func, blsVerify) {\n    let caller;\n    if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n        caller = async (options, ...args) => {\n            var _a, _b;\n            // First, if there's a config transformation, call it.\n            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n            const agent = options.agent || actor[metadataSymbol].config.agent || (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)();\n            const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n            const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.encode(func.argTypes, args);\n            const result = await agent.query(cid, {\n                methodName,\n                arg,\n                effectiveCanisterId: options.effectiveCanisterId,\n            });\n            const httpDetails = Object.assign(Object.assign({}, result.httpDetails), { requestDetails: result.requestDetails });\n            switch (result.status) {\n                case \"rejected\" /* QueryResponseStatus.Rejected */:\n                    throw new QueryCallRejectedError(cid, methodName, result);\n                case \"replied\" /* QueryResponseStatus.Replied */:\n                    return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n                        ? {\n                            httpDetails,\n                            result: decodeReturnValue(func.retTypes, result.reply.arg),\n                        }\n                        : decodeReturnValue(func.retTypes, result.reply.arg);\n            }\n        };\n    }\n    else {\n        caller = async (options, ...args) => {\n            var _a, _b;\n            // First, if there's a config transformation, call it.\n            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n            const agent = options.agent || actor[metadataSymbol].config.agent || (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)();\n            const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);\n            const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId);\n            const ecid = effectiveCanisterId !== undefined ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(effectiveCanisterId) : cid;\n            const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.encode(func.argTypes, args);\n            if (agent.rootKey == null)\n                throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError('Agent root key not initialized before making call');\n            const { requestId, response, requestDetails } = await agent.call(cid, {\n                methodName,\n                arg,\n                effectiveCanisterId: ecid,\n            });\n            let reply;\n            let certificate;\n            if (response.body && response.body.certificate) {\n                const cert = response.body.certificate;\n                certificate = await _certificate__WEBPACK_IMPORTED_MODULE_7__.Certificate.create({\n                    certificate: (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.bufFromBufLike)(cert),\n                    rootKey: agent.rootKey,\n                    canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId),\n                    blsVerify,\n                });\n                const path = [new TextEncoder().encode('request_status'), requestId];\n                const status = new TextDecoder().decode((0,_certificate__WEBPACK_IMPORTED_MODULE_7__.lookupResultToBuffer)(certificate.lookup([...path, 'status'])));\n                switch (status) {\n                    case 'replied':\n                        reply = (0,_certificate__WEBPACK_IMPORTED_MODULE_7__.lookupResultToBuffer)(certificate.lookup([...path, 'reply']));\n                        break;\n                    case 'rejected': {\n                        // Find rejection details in the certificate\n                        const rejectCode = new Uint8Array((0,_certificate__WEBPACK_IMPORTED_MODULE_7__.lookupResultToBuffer)(certificate.lookup([...path, 'reject_code'])))[0];\n                        const rejectMessage = new TextDecoder().decode((0,_certificate__WEBPACK_IMPORTED_MODULE_7__.lookupResultToBuffer)(certificate.lookup([...path, 'reject_message'])));\n                        const error_code_buf = (0,_certificate__WEBPACK_IMPORTED_MODULE_7__.lookupResultToBuffer)(certificate.lookup([...path, 'error_code']));\n                        const error_code = error_code_buf\n                            ? new TextDecoder().decode(error_code_buf)\n                            : undefined;\n                        throw new UpdateCallRejectedError(cid, methodName, requestId, response, rejectCode, rejectMessage, error_code);\n                    }\n                }\n            }\n            else if (response.body && 'reject_message' in response.body) {\n                // handle v2 response errors by throwing an UpdateCallRejectedError object\n                const { reject_code, reject_message, error_code } = response.body;\n                throw new UpdateCallRejectedError(cid, methodName, requestId, response, reject_code, reject_message, error_code);\n            }\n            // Fall back to polling if we receive an Accepted response code\n            if (response.status === 202) {\n                const pollStrategy = pollingStrategyFactory();\n                // Contains the certificate and the reply from the boundary node\n                const response = await (0,_polling__WEBPACK_IMPORTED_MODULE_4__.pollForResponse)(agent, ecid, requestId, pollStrategy, blsVerify);\n                certificate = response.certificate;\n                reply = response.reply;\n            }\n            const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n            const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n            const httpDetails = Object.assign(Object.assign({}, response), { requestDetails });\n            if (reply !== undefined) {\n                if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n                    return {\n                        httpDetails,\n                        certificate,\n                        result: decodeReturnValue(func.retTypes, reply),\n                    };\n                }\n                else if (shouldIncludeCertificate) {\n                    return {\n                        certificate,\n                        result: decodeReturnValue(func.retTypes, reply),\n                    };\n                }\n                else if (shouldIncludeHttpDetails) {\n                    return {\n                        httpDetails,\n                        result: decodeReturnValue(func.retTypes, reply),\n                    };\n                }\n                return decodeReturnValue(func.retTypes, reply);\n            }\n            else if (func.retTypes.length === 0) {\n                return shouldIncludeHttpDetails\n                    ? {\n                        httpDetails: response,\n                        result: undefined,\n                    }\n                    : undefined;\n            }\n            else {\n                throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n            }\n        };\n    }\n    const handler = (...args) => caller({}, ...args);\n    handler.withOptions =\n        (options) => (...args) => caller(options, ...args);\n    return handler;\n}\n/**\n * Create a management canister actor\n * @param config - a CallConfig\n */\nfunction getManagementCanister(config) {\n    function transform(_methodName, args) {\n        if (config.effectiveCanisterId) {\n            return { effectiveCanisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(config.effectiveCanisterId) };\n        }\n        const first = args[0];\n        let effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromHex('');\n        if (first && typeof first === 'object' && first.canister_id) {\n            effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(first.canister_id);\n        }\n        return { effectiveCanisterId };\n    }\n    return Actor.createActor(_canisters_management_idl__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign(Object.assign(Object.assign({}, config), { canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromHex('') }), {\n        callTransform: transform,\n        queryTransform: transform,\n    }));\n}\nclass AdvancedActor extends Actor {\n    constructor(metadata) {\n        super(metadata);\n    }\n}\n//# sourceMappingURL=actor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FjdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDO0FBQzZCO0FBQ3hCO0FBQ2dCO0FBQ0E7QUFDUDtBQUNSO0FBQzJCO0FBQ0g7QUFDeEQsNkJBQTZCLCtDQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0MseUJBQXlCLFlBQVksR0FBRyxLQUFLO0FBQzdDLGdFQUFnRSxFQUFFLEtBQUsseUJBQXlCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBaUIsd0VBQXdFLG1CQUFtQjtBQUNwSTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0VBQWdFLGNBQWMsb0RBQUssYUFBYTtBQUNoRyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU0sc0VBQXNFO0FBQ2hHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVM7QUFDeEI7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseURBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCLDBDQUEwQztBQUNwRjtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlDQUF5QyxhQUFhLFlBQVk7QUFDN0csZ0ZBQWdGLGFBQWEsWUFBWTtBQUN6RztBQUNBO0FBQ0EsMkNBQTJDLEdBQUcsb0RBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFVLDBDQUEwQywwQkFBMEI7QUFDNUc7QUFDQSxzQkFBc0IseURBQVM7QUFDL0I7QUFDQTtBQUNBLHdFQUF3RSxvQ0FBb0MsWUFBWTtBQUN4SDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQVUsMENBQTBDLGlDQUFpQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxtQkFBbUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQUcsZUFBZSwyQ0FBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4Q0FBUTtBQUNwQztBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUtBQXVLO0FBQzNOLGlGQUFpRix1REFBZTtBQUNoRyx3QkFBd0IseURBQVM7QUFDakMsd0JBQXdCLGdEQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhEQUE4RCx5QkFBeUIsdUNBQXVDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsc0tBQXNLO0FBQzFOLGlGQUFpRix1REFBZTtBQUNoRyxvQkFBb0IsMERBQTBELDhDQUE4QztBQUM1SCx3QkFBd0IseURBQVM7QUFDakMsNkRBQTZELHlEQUFTO0FBQ3RFLHdCQUF3QixnREFBRztBQUMzQjtBQUNBLDBCQUEwQiwrQ0FBVTtBQUNwQyxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxREFBVztBQUMvQyxpQ0FBaUMsK0RBQWM7QUFDL0M7QUFDQSxnQ0FBZ0MseURBQVM7QUFDekM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx3REFBd0Qsa0VBQW9CO0FBQzVFO0FBQ0E7QUFDQSxnQ0FBZ0Msa0VBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrRUFBb0I7QUFDOUUsdUVBQXVFLGtFQUFvQjtBQUMzRiwrQ0FBK0Msa0VBQW9CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQ0FBMEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHlEQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZUFBZSxnQkFBZ0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsd0JBQXdCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQix5REFBUztBQUNuRDtBQUNBO0FBQ0Esa0NBQWtDLHlEQUFTO0FBQzNDO0FBQ0Esa0NBQWtDLHlEQUFTO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNkJBQTZCLGlFQUFxQiw4Q0FBOEMsYUFBYSxZQUFZLHlEQUFTLGNBQWM7QUFDaEo7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyLyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0QWdlbnQsIFJlcGxpY2FSZWplY3RDb2RlLCB9IGZyb20gJy4vYWdlbnQnO1xuaW1wb3J0IHsgQWdlbnRFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGJ1ZkZyb21CdWZMaWtlLCBJREwgfSBmcm9tICdAZGZpbml0eS9jYW5kaWQnO1xuaW1wb3J0IHsgcG9sbEZvclJlc3BvbnNlLCBzdHJhdGVneSB9IGZyb20gJy4vcG9sbGluZyc7XG5pbXBvcnQgeyBQcmluY2lwYWwgfSBmcm9tICdAZGZpbml0eS9wcmluY2lwYWwnO1xuaW1wb3J0IHsgdG9IZXggfSBmcm9tICcuL3V0aWxzL2J1ZmZlcic7XG5pbXBvcnQgeyBDZXJ0aWZpY2F0ZSwgbG9va3VwUmVzdWx0VG9CdWZmZXIgfSBmcm9tICcuL2NlcnRpZmljYXRlJztcbmltcG9ydCBtYW5hZ2VtZW50Q2FuaXN0ZXJJZGwgZnJvbSAnLi9jYW5pc3RlcnMvbWFuYWdlbWVudF9pZGwnO1xuZXhwb3J0IGNsYXNzIEFjdG9yQ2FsbEVycm9yIGV4dGVuZHMgQWdlbnRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgICAgc3VwZXIoW1xuICAgICAgICAgICAgYENhbGwgZmFpbGVkOmAsXG4gICAgICAgICAgICBgICBDYW5pc3RlcjogJHtjYW5pc3RlcklkLnRvVGV4dCgpfWAsXG4gICAgICAgICAgICBgICBNZXRob2Q6ICR7bWV0aG9kTmFtZX0gKCR7dHlwZX0pYCxcbiAgICAgICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BzKS5tYXAobiA9PiBgICBcIiR7bn1cIjogJHtKU09OLnN0cmluZ2lmeShwcm9wc1tuXSl9YCksXG4gICAgICAgIF0uam9pbignXFxuJykpO1xuICAgICAgICB0aGlzLmNhbmlzdGVySWQgPSBjYW5pc3RlcklkO1xuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFF1ZXJ5Q2FsbFJlamVjdGVkRXJyb3IgZXh0ZW5kcyBBY3RvckNhbGxFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgJ3F1ZXJ5Jywge1xuICAgICAgICAgICAgU3RhdHVzOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICAgICAgQ29kZTogKF9hID0gUmVwbGljYVJlamVjdENvZGVbcmVzdWx0LnJlamVjdF9jb2RlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYFVua25vd24gQ29kZSBcIiR7cmVzdWx0LnJlamVjdF9jb2RlfVwiYCxcbiAgICAgICAgICAgIE1lc3NhZ2U6IHJlc3VsdC5yZWplY3RfbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVcGRhdGVDYWxsUmVqZWN0ZWRFcnJvciBleHRlbmRzIEFjdG9yQ2FsbEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYW5pc3RlcklkLCBtZXRob2ROYW1lLCByZXF1ZXN0SWQsIHJlc3BvbnNlLCByZWplY3RfY29kZSwgcmVqZWN0X21lc3NhZ2UsIGVycm9yX2NvZGUpIHtcbiAgICAgICAgc3VwZXIoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgJ3VwZGF0ZScsIE9iamVjdC5hc3NpZ24oeyAnUmVxdWVzdCBJRCc6IHRvSGV4KHJlcXVlc3RJZCkgfSwgKHJlc3BvbnNlLmJvZHlcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoZXJyb3JfY29kZVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAnRXJyb3IgY29kZSc6IGVycm9yX2NvZGUsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pKSwgeyAnUmVqZWN0IGNvZGUnOiBTdHJpbmcocmVqZWN0X2NvZGUpLCAnUmVqZWN0IG1lc3NhZ2UnOiByZWplY3RfbWVzc2FnZSB9KSA6IHtcbiAgICAgICAgICAgICdIVFRQIHN0YXR1cyBjb2RlJzogcmVzcG9uc2Uuc3RhdHVzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAnSFRUUCBzdGF0dXMgdGV4dCc6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHRoaXMucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMucmVqZWN0X2NvZGUgPSByZWplY3RfY29kZTtcbiAgICAgICAgdGhpcy5yZWplY3RfbWVzc2FnZSA9IHJlamVjdF9tZXNzYWdlO1xuICAgICAgICB0aGlzLmVycm9yX2NvZGUgPSBlcnJvcl9jb2RlO1xuICAgIH1cbn1cbmNvbnN0IG1ldGFkYXRhU3ltYm9sID0gU3ltYm9sLmZvcignaWMtYWdlbnQtbWV0YWRhdGEnKTtcbi8qKlxuICogQW4gYWN0b3IgYmFzZSBjbGFzcy4gQW4gYWN0b3IgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSBmdW5jdGlvbnMgdGhhdCB3aWxsXG4gKiByZXR1cm4gYSBwcm9taXNlLiBUaGVzZSBmdW5jdGlvbnMgYXJlIGRlcml2ZWQgZnJvbSB0aGUgSURMIGRlZmluaXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3RvciB7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpc1ttZXRhZGF0YVN5bWJvbF0gPSBPYmplY3QuZnJlZXplKG1ldGFkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBBZ2VudCBjbGFzcyB0aGlzIEFjdG9yIHdvdWxkIGNhbGwsIG9yIHVuZGVmaW5lZCBpZiB0aGUgQWN0b3Igd291bGQgdXNlXG4gICAgICogdGhlIGRlZmF1bHQgYWdlbnQgKGdsb2JhbC5pYy5hZ2VudCkuXG4gICAgICogQHBhcmFtIGFjdG9yIFRoZSBhY3RvciB0byBnZXQgdGhlIGFnZW50IG9mLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZ2VudE9mKGFjdG9yKSB7XG4gICAgICAgIHJldHVybiBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLmFnZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGludGVyZmFjZSBvZiBhbiBhY3RvciwgaW4gdGhlIGZvcm0gb2YgYW4gaW5zdGFuY2Ugb2YgYSBTZXJ2aWNlLlxuICAgICAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gZ2V0IHRoZSBpbnRlcmZhY2Ugb2YuXG4gICAgICovXG4gICAgc3RhdGljIGludGVyZmFjZU9mKGFjdG9yKSB7XG4gICAgICAgIHJldHVybiBhY3RvclttZXRhZGF0YVN5bWJvbF0uc2VydmljZTtcbiAgICB9XG4gICAgc3RhdGljIGNhbmlzdGVySWRPZihhY3Rvcikge1xuICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb20oYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZy5jYW5pc3RlcklkKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGluc3RhbGwoZmllbGRzLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgbW9kZSA9IGZpZWxkcy5tb2RlID09PSB1bmRlZmluZWQgPyB7IGluc3RhbGw6IG51bGwgfSA6IGZpZWxkcy5tb2RlO1xuICAgICAgICAvLyBOZWVkIHRvIHRyYW5zZm9ybSB0aGUgYXJnIGludG8gYSBudW1iZXIgYXJyYXkuXG4gICAgICAgIGNvbnN0IGFyZyA9IGZpZWxkcy5hcmcgPyBbLi4ubmV3IFVpbnQ4QXJyYXkoZmllbGRzLmFyZyldIDogW107XG4gICAgICAgIC8vIFNhbWUgZm9yIG1vZHVsZS5cbiAgICAgICAgY29uc3Qgd2FzbU1vZHVsZSA9IFsuLi5uZXcgVWludDhBcnJheShmaWVsZHMubW9kdWxlKV07XG4gICAgICAgIGNvbnN0IGNhbmlzdGVySWQgPSB0eXBlb2YgY29uZmlnLmNhbmlzdGVySWQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IFByaW5jaXBhbC5mcm9tVGV4dChjb25maWcuY2FuaXN0ZXJJZClcbiAgICAgICAgICAgIDogY29uZmlnLmNhbmlzdGVySWQ7XG4gICAgICAgIGF3YWl0IGdldE1hbmFnZW1lbnRDYW5pc3Rlcihjb25maWcpLmluc3RhbGxfY29kZSh7XG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgd2FzbV9tb2R1bGU6IHdhc21Nb2R1bGUsXG4gICAgICAgICAgICBjYW5pc3Rlcl9pZDogY2FuaXN0ZXJJZCxcbiAgICAgICAgICAgIHNlbmRlcl9jYW5pc3Rlcl92ZXJzaW9uOiBbXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGVDYW5pc3Rlcihjb25maWcsIHNldHRpbmdzKSB7XG4gICAgICAgIGZ1bmN0aW9uIHNldHRpbmdzVG9DYW5pc3RlclNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcnM6IHNldHRpbmdzLmNvbnRyb2xsZXJzID8gW3NldHRpbmdzLmNvbnRyb2xsZXJzXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlX2FsbG9jYXRpb246IHNldHRpbmdzLmNvbXB1dGVfYWxsb2NhdGlvbiA/IFtzZXR0aW5ncy5jb21wdXRlX2FsbG9jYXRpb25dIDogW10sXG4gICAgICAgICAgICAgICAgICAgIGZyZWV6aW5nX3RocmVzaG9sZDogc2V0dGluZ3MuZnJlZXppbmdfdGhyZXNob2xkID8gW3NldHRpbmdzLmZyZWV6aW5nX3RocmVzaG9sZF0gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbWVtb3J5X2FsbG9jYXRpb246IHNldHRpbmdzLm1lbW9yeV9hbGxvY2F0aW9uID8gW3NldHRpbmdzLm1lbW9yeV9hbGxvY2F0aW9uXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICByZXNlcnZlZF9jeWNsZXNfbGltaXQ6IFtdLFxuICAgICAgICAgICAgICAgICAgICBsb2dfdmlzaWJpbGl0eTogW10sXG4gICAgICAgICAgICAgICAgICAgIHdhc21fbWVtb3J5X2xpbWl0OiBbXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhbmlzdGVyX2lkOiBjYW5pc3RlcklkIH0gPSBhd2FpdCBnZXRNYW5hZ2VtZW50Q2FuaXN0ZXIoY29uZmlnIHx8IHt9KS5wcm92aXNpb25hbF9jcmVhdGVfY2FuaXN0ZXJfd2l0aF9jeWNsZXMoe1xuICAgICAgICAgICAgYW1vdW50OiBbXSxcbiAgICAgICAgICAgIHNldHRpbmdzOiBzZXR0aW5nc1RvQ2FuaXN0ZXJTZXR0aW5ncyhzZXR0aW5ncyB8fCB7fSksXG4gICAgICAgICAgICBzcGVjaWZpZWRfaWQ6IFtdLFxuICAgICAgICAgICAgc2VuZGVyX2NhbmlzdGVyX3ZlcnNpb246IFtdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbmlzdGVySWQ7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGVBbmRJbnN0YWxsQ2FuaXN0ZXIoaW50ZXJmYWNlRmFjdG9yeSwgZmllbGRzLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgY2FuaXN0ZXJJZCA9IGF3YWl0IHRoaXMuY3JlYXRlQ2FuaXN0ZXIoY29uZmlnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnN0YWxsKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkcyksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgeyBjYW5pc3RlcklkIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQWN0b3IoaW50ZXJmYWNlRmFjdG9yeSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpLCB7IGNhbmlzdGVySWQgfSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlQWN0b3JDbGFzcyhpbnRlcmZhY2VGYWN0b3J5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSBpbnRlcmZhY2VGYWN0b3J5KHsgSURMIH0pO1xuICAgICAgICBjbGFzcyBDYW5pc3RlckFjdG9yIGV4dGVuZHMgQWN0b3Ige1xuICAgICAgICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcuY2FuaXN0ZXJJZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFnZW50RXJyb3IoYENhbmlzdGVyIElEIGlzIHJlcXVpcmVkLCBidXQgcmVjZWl2ZWQgJHt0eXBlb2YgY29uZmlnLmNhbmlzdGVySWR9IGluc3RlYWQuIElmIHlvdSBhcmUgdXNpbmcgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZGVjbGFyYXRpb25zLCB0aGlzIG1heSBiZSBiZWNhdXNlIHlvdXIgYXBwbGljYXRpb24gaXMgbm90IHNldHRpbmcgdGhlIGNhbmlzdGVyIElEIGluIHByb2Nlc3MuZW52IGNvcnJlY3RseS5gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5pc3RlcklkID0gdHlwZW9mIGNvbmZpZy5jYW5pc3RlcklkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IFByaW5jaXBhbC5mcm9tVGV4dChjb25maWcuY2FuaXN0ZXJJZClcbiAgICAgICAgICAgICAgICAgICAgOiBjb25maWcuY2FuaXN0ZXJJZDtcbiAgICAgICAgICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQUNUT1JfQ09ORklHKSwgY29uZmlnKSwgeyBjYW5pc3RlcklkIH0pLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW21ldGhvZE5hbWUsIGZ1bmNdIG9mIHNlcnZpY2UuX2ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmh0dHBEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jLmFubm90YXRpb25zLnB1c2goQUNUT1JfTUVUSE9EX1dJVEhfSFRUUF9ERVRBSUxTKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNlcnRpZmljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jLmFubm90YXRpb25zLnB1c2goQUNUT1JfTUVUSE9EX1dJVEhfQ0VSVElGSUNBVEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSBfY3JlYXRlQWN0b3JNZXRob2QodGhpcywgbWV0aG9kTmFtZSwgZnVuYywgY29uZmlnLmJsc1ZlcmlmeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDYW5pc3RlckFjdG9yO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlQWN0b3IoaW50ZXJmYWNlRmFjdG9yeSwgY29uZmlndXJhdGlvbikge1xuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24uY2FuaXN0ZXJJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFnZW50RXJyb3IoYENhbmlzdGVyIElEIGlzIHJlcXVpcmVkLCBidXQgcmVjZWl2ZWQgJHt0eXBlb2YgY29uZmlndXJhdGlvbi5jYW5pc3RlcklkfSBpbnN0ZWFkLiBJZiB5b3UgYXJlIHVzaW5nIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGRlY2xhcmF0aW9ucywgdGhpcyBtYXkgYmUgYmVjYXVzZSB5b3VyIGFwcGxpY2F0aW9uIGlzIG5vdCBzZXR0aW5nIHRoZSBjYW5pc3RlciBJRCBpbiBwcm9jZXNzLmVudiBjb3JyZWN0bHkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jcmVhdGVBY3RvckNsYXNzKGludGVyZmFjZUZhY3RvcnkpKShjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhY3RvciB3aXRoIG1ldGhvZHMgdGhhdCByZXR1cm4gdGhlIGh0dHAgcmVzcG9uc2UgZGV0YWlscyBhbG9uZyB3aXRoIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gaW50ZXJmYWNlRmFjdG9yeSAtIHRoZSBpbnRlcmZhY2UgZmFjdG9yeSBmb3IgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIGNvbmZpZ3VyYXRpb24gLSB0aGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGFjdG9yXG4gICAgICogQGRlcHJlY2F0ZWQgLSB1c2UgY3JlYXRlQWN0b3Igd2l0aCBhY3RvckNsYXNzT3B0aW9ucyBpbnN0ZWFkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUFjdG9yV2l0aEh0dHBEZXRhaWxzKGludGVyZmFjZUZhY3RvcnksIGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jcmVhdGVBY3RvckNsYXNzKGludGVyZmFjZUZhY3RvcnksIHsgaHR0cERldGFpbHM6IHRydWUgfSkpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFjdG9yIHdpdGggbWV0aG9kcyB0aGF0IHJldHVybiB0aGUgaHR0cCByZXNwb25zZSBkZXRhaWxzIGFsb25nIHdpdGggdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSBpbnRlcmZhY2VGYWN0b3J5IC0gdGhlIGludGVyZmFjZSBmYWN0b3J5IGZvciB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gY29uZmlndXJhdGlvbiAtIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gYWN0b3JDbGFzc09wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgYWN0b3IgY2xhc3MgZXh0ZW5kZWQgZGV0YWlscyB0byByZXR1cm4gd2l0aCB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUFjdG9yV2l0aEV4dGVuZGVkRGV0YWlscyhpbnRlcmZhY2VGYWN0b3J5LCBjb25maWd1cmF0aW9uLCBhY3RvckNsYXNzT3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cERldGFpbHM6IHRydWUsXG4gICAgICAgIGNlcnRpZmljYXRlOiB0cnVlLFxuICAgIH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jcmVhdGVBY3RvckNsYXNzKGludGVyZmFjZUZhY3RvcnksIGFjdG9yQ2xhc3NPcHRpb25zKSkoY29uZmlndXJhdGlvbik7XG4gICAgfVxufVxuLy8gSURMIGZ1bmN0aW9ucyBjYW4gaGF2ZSBtdWx0aXBsZSByZXR1cm4gdmFsdWVzLCBzbyBkZWNvZGluZyBhbHdheXNcbi8vIHByb2R1Y2VzIGFuIGFycmF5LiBFbnN1cmUgdGhhdCBmdW5jdGlvbnMgd2l0aCBzaW5nbGUgb3IgemVybyByZXR1cm5cbi8vIHZhbHVlcyBiZWhhdmUgYXMgZXhwZWN0ZWQuXG5mdW5jdGlvbiBkZWNvZGVSZXR1cm5WYWx1ZSh0eXBlcywgbXNnKSB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWVzID0gSURMLmRlY29kZSh0eXBlcywgQnVmZmVyLmZyb20obXNnKSk7XG4gICAgc3dpdGNoIChyZXR1cm5WYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZXNbMF07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICAgIH1cbn1cbmNvbnN0IERFRkFVTFRfQUNUT1JfQ09ORklHID0ge1xuICAgIHBvbGxpbmdTdHJhdGVneUZhY3Rvcnk6IHN0cmF0ZWd5LmRlZmF1bHRTdHJhdGVneSxcbn07XG5leHBvcnQgY29uc3QgQUNUT1JfTUVUSE9EX1dJVEhfSFRUUF9ERVRBSUxTID0gJ2h0dHAtZGV0YWlscyc7XG5leHBvcnQgY29uc3QgQUNUT1JfTUVUSE9EX1dJVEhfQ0VSVElGSUNBVEUgPSAnY2VydGlmaWNhdGUnO1xuZnVuY3Rpb24gX2NyZWF0ZUFjdG9yTWV0aG9kKGFjdG9yLCBtZXRob2ROYW1lLCBmdW5jLCBibHNWZXJpZnkpIHtcbiAgICBsZXQgY2FsbGVyO1xuICAgIGlmIChmdW5jLmFubm90YXRpb25zLmluY2x1ZGVzKCdxdWVyeScpIHx8IGZ1bmMuYW5ub3RhdGlvbnMuaW5jbHVkZXMoJ2NvbXBvc2l0ZV9xdWVyeScpKSB7XG4gICAgICAgIGNhbGxlciA9IGFzeW5jIChvcHRpb25zLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgLy8gRmlyc3QsIGlmIHRoZXJlJ3MgYSBjb25maWcgdHJhbnNmb3JtYXRpb24sIGNhbGwgaXQuXG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgKF9iID0gKF9hID0gYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZykucXVlcnlUcmFuc2Zvcm0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBtZXRob2ROYW1lLCBhcmdzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjdG9yW21ldGFkYXRhU3ltYm9sXS5jb25maWcpLCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgY29uc3QgYWdlbnQgPSBvcHRpb25zLmFnZW50IHx8IGFjdG9yW21ldGFkYXRhU3ltYm9sXS5jb25maWcuYWdlbnQgfHwgZ2V0RGVmYXVsdEFnZW50KCk7XG4gICAgICAgICAgICBjb25zdCBjaWQgPSBQcmluY2lwYWwuZnJvbShvcHRpb25zLmNhbmlzdGVySWQgfHwgYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZy5jYW5pc3RlcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IElETC5lbmNvZGUoZnVuYy5hcmdUeXBlcywgYXJncyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZ2VudC5xdWVyeShjaWQsIHtcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICBlZmZlY3RpdmVDYW5pc3RlcklkOiBvcHRpb25zLmVmZmVjdGl2ZUNhbmlzdGVySWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGh0dHBEZXRhaWxzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN1bHQuaHR0cERldGFpbHMpLCB7IHJlcXVlc3REZXRhaWxzOiByZXN1bHQucmVxdWVzdERldGFpbHMgfSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIiAvKiBRdWVyeVJlc3BvbnNlU3RhdHVzLlJlamVjdGVkICovOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUXVlcnlDYWxsUmVqZWN0ZWRFcnJvcihjaWQsIG1ldGhvZE5hbWUsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcGxpZWRcIiAvKiBRdWVyeVJlc3BvbnNlU3RhdHVzLlJlcGxpZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLmFubm90YXRpb25zLmluY2x1ZGVzKEFDVE9SX01FVEhPRF9XSVRIX0hUVFBfREVUQUlMUylcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBEZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZGVjb2RlUmV0dXJuVmFsdWUoZnVuYy5yZXRUeXBlcywgcmVzdWx0LnJlcGx5LmFyZyksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRlY29kZVJldHVyblZhbHVlKGZ1bmMucmV0VHlwZXMsIHJlc3VsdC5yZXBseS5hcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FsbGVyID0gYXN5bmMgKG9wdGlvbnMsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAvLyBGaXJzdCwgaWYgdGhlcmUncyBhIGNvbmZpZyB0cmFuc2Zvcm1hdGlvbiwgY2FsbCBpdC5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCAoX2IgPSAoX2EgPSBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnKS5jYWxsVHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbWV0aG9kTmFtZSwgYXJncywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnKSwgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50ID0gb3B0aW9ucy5hZ2VudCB8fCBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLmFnZW50IHx8IGdldERlZmF1bHRBZ2VudCgpO1xuICAgICAgICAgICAgY29uc3QgeyBjYW5pc3RlcklkLCBlZmZlY3RpdmVDYW5pc3RlcklkLCBwb2xsaW5nU3RyYXRlZ3lGYWN0b3J5IH0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9BQ1RPUl9DT05GSUcpLCBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBjaWQgPSBQcmluY2lwYWwuZnJvbShjYW5pc3RlcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGVjaWQgPSBlZmZlY3RpdmVDYW5pc3RlcklkICE9PSB1bmRlZmluZWQgPyBQcmluY2lwYWwuZnJvbShlZmZlY3RpdmVDYW5pc3RlcklkKSA6IGNpZDtcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IElETC5lbmNvZGUoZnVuYy5hcmdUeXBlcywgYXJncyk7XG4gICAgICAgICAgICBpZiAoYWdlbnQucm9vdEtleSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEVycm9yKCdBZ2VudCByb290IGtleSBub3QgaW5pdGlhbGl6ZWQgYmVmb3JlIG1ha2luZyBjYWxsJyk7XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVlc3RJZCwgcmVzcG9uc2UsIHJlcXVlc3REZXRhaWxzIH0gPSBhd2FpdCBhZ2VudC5jYWxsKGNpZCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgIGVmZmVjdGl2ZUNhbmlzdGVySWQ6IGVjaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCByZXBseTtcbiAgICAgICAgICAgIGxldCBjZXJ0aWZpY2F0ZTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5ib2R5ICYmIHJlc3BvbnNlLmJvZHkuY2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZXJ0ID0gcmVzcG9uc2UuYm9keS5jZXJ0aWZpY2F0ZTtcbiAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZSA9IGF3YWl0IENlcnRpZmljYXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBidWZGcm9tQnVmTGlrZShjZXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdEtleTogYWdlbnQucm9vdEtleSxcbiAgICAgICAgICAgICAgICAgICAgY2FuaXN0ZXJJZDogUHJpbmNpcGFsLmZyb20oY2FuaXN0ZXJJZCksXG4gICAgICAgICAgICAgICAgICAgIGJsc1ZlcmlmeSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gW25ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgncmVxdWVzdF9zdGF0dXMnKSwgcmVxdWVzdElkXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydGlmaWNhdGUubG9va3VwKFsuLi5wYXRoLCAnc3RhdHVzJ10pKSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVwbGllZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseSA9IGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnRpZmljYXRlLmxvb2t1cChbLi4ucGF0aCwgJ3JlcGx5J10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgcmVqZWN0aW9uIGRldGFpbHMgaW4gdGhlIGNlcnRpZmljYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWplY3RDb2RlID0gbmV3IFVpbnQ4QXJyYXkobG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydGlmaWNhdGUubG9va3VwKFsuLi5wYXRoLCAncmVqZWN0X2NvZGUnXSkpKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlamVjdE1lc3NhZ2UgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydGlmaWNhdGUubG9va3VwKFsuLi5wYXRoLCAncmVqZWN0X21lc3NhZ2UnXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yX2NvZGVfYnVmID0gbG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydGlmaWNhdGUubG9va3VwKFsuLi5wYXRoLCAnZXJyb3JfY29kZSddKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvcl9jb2RlID0gZXJyb3JfY29kZV9idWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShlcnJvcl9jb2RlX2J1ZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGRhdGVDYWxsUmVqZWN0ZWRFcnJvcihjaWQsIG1ldGhvZE5hbWUsIHJlcXVlc3RJZCwgcmVzcG9uc2UsIHJlamVjdENvZGUsIHJlamVjdE1lc3NhZ2UsIGVycm9yX2NvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2UuYm9keSAmJiAncmVqZWN0X21lc3NhZ2UnIGluIHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdjIgcmVzcG9uc2UgZXJyb3JzIGJ5IHRocm93aW5nIGFuIFVwZGF0ZUNhbGxSZWplY3RlZEVycm9yIG9iamVjdFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVqZWN0X2NvZGUsIHJlamVjdF9tZXNzYWdlLCBlcnJvcl9jb2RlIH0gPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGRhdGVDYWxsUmVqZWN0ZWRFcnJvcihjaWQsIG1ldGhvZE5hbWUsIHJlcXVlc3RJZCwgcmVzcG9uc2UsIHJlamVjdF9jb2RlLCByZWplY3RfbWVzc2FnZSwgZXJyb3JfY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gcG9sbGluZyBpZiB3ZSByZWNlaXZlIGFuIEFjY2VwdGVkIHJlc3BvbnNlIGNvZGVcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbGxTdHJhdGVneSA9IHBvbGxpbmdTdHJhdGVneUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAvLyBDb250YWlucyB0aGUgY2VydGlmaWNhdGUgYW5kIHRoZSByZXBseSBmcm9tIHRoZSBib3VuZGFyeSBub2RlXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb2xsRm9yUmVzcG9uc2UoYWdlbnQsIGVjaWQsIHJlcXVlc3RJZCwgcG9sbFN0cmF0ZWd5LCBibHNWZXJpZnkpO1xuICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlID0gcmVzcG9uc2UuY2VydGlmaWNhdGU7XG4gICAgICAgICAgICAgICAgcmVwbHkgPSByZXNwb25zZS5yZXBseTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEluY2x1ZGVIdHRwRGV0YWlscyA9IGZ1bmMuYW5ub3RhdGlvbnMuaW5jbHVkZXMoQUNUT1JfTUVUSE9EX1dJVEhfSFRUUF9ERVRBSUxTKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEluY2x1ZGVDZXJ0aWZpY2F0ZSA9IGZ1bmMuYW5ub3RhdGlvbnMuaW5jbHVkZXMoQUNUT1JfTUVUSE9EX1dJVEhfQ0VSVElGSUNBVEUpO1xuICAgICAgICAgICAgY29uc3QgaHR0cERldGFpbHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlKSwgeyByZXF1ZXN0RGV0YWlscyB9KTtcbiAgICAgICAgICAgIGlmIChyZXBseSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEluY2x1ZGVIdHRwRGV0YWlscyAmJiBzaG91bGRJbmNsdWRlQ2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBEZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGRlY29kZVJldHVyblZhbHVlKGZ1bmMucmV0VHlwZXMsIHJlcGx5KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hvdWxkSW5jbHVkZUNlcnRpZmljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZGVjb2RlUmV0dXJuVmFsdWUoZnVuYy5yZXRUeXBlcywgcmVwbHkpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaG91bGRJbmNsdWRlSHR0cERldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBEZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBkZWNvZGVSZXR1cm5WYWx1ZShmdW5jLnJldFR5cGVzLCByZXBseSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVSZXR1cm5WYWx1ZShmdW5jLnJldFR5cGVzLCByZXBseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmdW5jLnJldFR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRJbmNsdWRlSHR0cERldGFpbHNcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwRGV0YWlsczogcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbCB3YXMgcmV0dXJuZWQgdW5kZWZpbmVkLCBidXQgdHlwZSBbJHtmdW5jLnJldFR5cGVzLmpvaW4oJywnKX1dLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVyID0gKC4uLmFyZ3MpID0+IGNhbGxlcih7fSwgLi4uYXJncyk7XG4gICAgaGFuZGxlci53aXRoT3B0aW9ucyA9XG4gICAgICAgIChvcHRpb25zKSA9PiAoLi4uYXJncykgPT4gY2FsbGVyKG9wdGlvbnMsIC4uLmFyZ3MpO1xuICAgIHJldHVybiBoYW5kbGVyO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBtYW5hZ2VtZW50IGNhbmlzdGVyIGFjdG9yXG4gKiBAcGFyYW0gY29uZmlnIC0gYSBDYWxsQ29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYW5hZ2VtZW50Q2FuaXN0ZXIoY29uZmlnKSB7XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKF9tZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgICAgIGlmIChjb25maWcuZWZmZWN0aXZlQ2FuaXN0ZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZWZmZWN0aXZlQ2FuaXN0ZXJJZDogUHJpbmNpcGFsLmZyb20oY29uZmlnLmVmZmVjdGl2ZUNhbmlzdGVySWQpIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICAgICAgICBsZXQgZWZmZWN0aXZlQ2FuaXN0ZXJJZCA9IFByaW5jaXBhbC5mcm9tSGV4KCcnKTtcbiAgICAgICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdCA9PT0gJ29iamVjdCcgJiYgZmlyc3QuY2FuaXN0ZXJfaWQpIHtcbiAgICAgICAgICAgIGVmZmVjdGl2ZUNhbmlzdGVySWQgPSBQcmluY2lwYWwuZnJvbShmaXJzdC5jYW5pc3Rlcl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZWZmZWN0aXZlQ2FuaXN0ZXJJZCB9O1xuICAgIH1cbiAgICByZXR1cm4gQWN0b3IuY3JlYXRlQWN0b3IobWFuYWdlbWVudENhbmlzdGVySWRsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgeyBjYW5pc3RlcklkOiBQcmluY2lwYWwuZnJvbUhleCgnJykgfSksIHtcbiAgICAgICAgY2FsbFRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICBxdWVyeVRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIH0pKTtcbn1cbmV4cG9ydCBjbGFzcyBBZHZhbmNlZEFjdG9yIGV4dGVuZHMgQWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG1ldGFkYXRhKSB7XG4gICAgICAgIHN1cGVyKG1ldGFkYXRhKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/actor.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/api.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/api.js ***!
  \***************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReplicaRejectCode: () => (/* binding */ ReplicaRejectCode)\n/* harmony export */ });\n/**\n * Codes used by the replica for rejecting a message.\n * See {@link https://sdk.dfinity.org/docs/interface-spec/#reject-codes | the interface spec}.\n */\nvar ReplicaRejectCode;\n(function (ReplicaRejectCode) {\n    ReplicaRejectCode[ReplicaRejectCode[\"SysFatal\"] = 1] = \"SysFatal\";\n    ReplicaRejectCode[ReplicaRejectCode[\"SysTransient\"] = 2] = \"SysTransient\";\n    ReplicaRejectCode[ReplicaRejectCode[\"DestinationInvalid\"] = 3] = \"DestinationInvalid\";\n    ReplicaRejectCode[ReplicaRejectCode[\"CanisterReject\"] = 4] = \"CanisterReject\";\n    ReplicaRejectCode[ReplicaRejectCode[\"CanisterError\"] = 5] = \"CanisterError\";\n})(ReplicaRejectCode || (ReplicaRejectCode = {}));\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2FwaS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLFFBQVEscUZBQXFGO0FBQzdGO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQyIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29kZXMgdXNlZCBieSB0aGUgcmVwbGljYSBmb3IgcmVqZWN0aW5nIGEgbWVzc2FnZS5cbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9zZGsuZGZpbml0eS5vcmcvZG9jcy9pbnRlcmZhY2Utc3BlYy8jcmVqZWN0LWNvZGVzIHwgdGhlIGludGVyZmFjZSBzcGVjfS5cbiAqL1xuZXhwb3J0IHZhciBSZXBsaWNhUmVqZWN0Q29kZTtcbihmdW5jdGlvbiAoUmVwbGljYVJlamVjdENvZGUpIHtcbiAgICBSZXBsaWNhUmVqZWN0Q29kZVtSZXBsaWNhUmVqZWN0Q29kZVtcIlN5c0ZhdGFsXCJdID0gMV0gPSBcIlN5c0ZhdGFsXCI7XG4gICAgUmVwbGljYVJlamVjdENvZGVbUmVwbGljYVJlamVjdENvZGVbXCJTeXNUcmFuc2llbnRcIl0gPSAyXSA9IFwiU3lzVHJhbnNpZW50XCI7XG4gICAgUmVwbGljYVJlamVjdENvZGVbUmVwbGljYVJlamVjdENvZGVbXCJEZXN0aW5hdGlvbkludmFsaWRcIl0gPSAzXSA9IFwiRGVzdGluYXRpb25JbnZhbGlkXCI7XG4gICAgUmVwbGljYVJlamVjdENvZGVbUmVwbGljYVJlamVjdENvZGVbXCJDYW5pc3RlclJlamVjdFwiXSA9IDRdID0gXCJDYW5pc3RlclJlamVjdFwiO1xuICAgIFJlcGxpY2FSZWplY3RDb2RlW1JlcGxpY2FSZWplY3RDb2RlW1wiQ2FuaXN0ZXJFcnJvclwiXSA9IDVdID0gXCJDYW5pc3RlckVycm9yXCI7XG59KShSZXBsaWNhUmVqZWN0Q29kZSB8fCAoUmVwbGljYVJlamVjdENvZGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/api.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/errors.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/errors.js ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentHTTPResponseError: () => (/* binding */ AgentHTTPResponseError)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/errors.js\");\n\nclass AgentHTTPResponseError extends _errors__WEBPACK_IMPORTED_MODULE_0__.AgentError {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDO0FBQ25DLHFDQUFxQywrQ0FBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2FnZW50QDIuMS4zX0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjNfX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hZ2VudC9odHRwL2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZ2VudEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmV4cG9ydCBjbGFzcyBBZ2VudEhUVFBSZXNwb25zZUVycm9yIGV4dGVuZHMgQWdlbnRFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/errors.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/index.js":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/index.js ***!
  \**********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpAgent: () => (/* binding */ HttpAgent),\n/* harmony export */   IC_ROOT_KEY: () => (/* binding */ IC_ROOT_KEY),\n/* harmony export */   IdentityInvalidError: () => (/* binding */ IdentityInvalidError),\n/* harmony export */   MANAGEMENT_CANISTER_ID: () => (/* binding */ MANAGEMENT_CANISTER_ID),\n/* harmony export */   RequestStatusResponseStatus: () => (/* binding */ RequestStatusResponseStatus),\n/* harmony export */   makeNonce: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_7__.makeNonce)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../auth */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/auth.js\");\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../cbor */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../request_id */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _transforms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transforms */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./errors */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/errors.js\");\n/* harmony import */ var _canisterStatus__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../canisterStatus */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../certificate */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var _utils_expirableMap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utils/expirableMap */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js\");\n/* harmony import */ var _public_key__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../public_key */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/public_key.js\");\n/* harmony import */ var _utils_leb__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utils/leb */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n/* harmony import */ var _observable__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../observable */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/observable.js\");\n/* harmony import */ var _polling_backoff__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../polling/backoff */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/backoff.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../constants */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/constants.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _transforms__WEBPACK_IMPORTED_MODULE_6__) if([\"default\",\"makeNonce\",\"RequestStatusResponseStatus\",\"IC_ROOT_KEY\",\"MANAGEMENT_CANISTER_ID\",\"IdentityInvalidError\",\"HttpAgent\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _transforms__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HttpAgent_instances, _HttpAgent_identity, _HttpAgent_fetch, _HttpAgent_fetchOptions, _HttpAgent_callOptions, _HttpAgent_timeDiffMsecs, _HttpAgent_credentials, _HttpAgent_rootKeyFetched, _HttpAgent_retryTimes, _HttpAgent_backoffStrategy, _HttpAgent_maxIngressExpiryInMinutes, _HttpAgent_waterMark, _HttpAgent_queryPipeline, _HttpAgent_updatePipeline, _HttpAgent_subnetKeys, _HttpAgent_verifyQuerySignatures, _HttpAgent_requestAndRetryQuery, _HttpAgent_requestAndRetry, _HttpAgent_verifyQueryResponse;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar RequestStatusResponseStatus;\n(function (RequestStatusResponseStatus) {\n    RequestStatusResponseStatus[\"Received\"] = \"received\";\n    RequestStatusResponseStatus[\"Processing\"] = \"processing\";\n    RequestStatusResponseStatus[\"Replied\"] = \"replied\";\n    RequestStatusResponseStatus[\"Rejected\"] = \"rejected\";\n    RequestStatusResponseStatus[\"Unknown\"] = \"unknown\";\n    RequestStatusResponseStatus[\"Done\"] = \"done\";\n})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));\nconst MINUTE_TO_MSECS = 60 * 1000;\n// Root public key for the IC, encoded as hex\nconst IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n    'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n    '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n    'b01291091c5f87b98883463f98091a0baaae';\nconst MANAGEMENT_CANISTER_ID = 'aaaaa-aa';\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\nclass HttpDefaultFetchError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {\n    constructor(message) {\n        super(message);\n        this.message = message;\n    }\n}\nclass IdentityInvalidError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {\n    constructor(message) {\n        super(message);\n        this.message = message;\n    }\n}\nfunction getDefaultFetch() {\n    let defaultFetch;\n    if (typeof window !== 'undefined') {\n        // Browser context\n        if (window.fetch) {\n            defaultFetch = window.fetch.bind(window);\n        }\n        else {\n            throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.');\n        }\n    }\n    else if (typeof __webpack_require__.g !== 'undefined') {\n        // Node context\n        if (__webpack_require__.g.fetch) {\n            defaultFetch = __webpack_require__.g.fetch.bind(__webpack_require__.g);\n        }\n        else {\n            throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.');\n        }\n    }\n    else if (typeof self !== 'undefined') {\n        if (self.fetch) {\n            defaultFetch = self.fetch.bind(self);\n        }\n    }\n    if (defaultFetch) {\n        return defaultFetch;\n    }\n    throw new HttpDefaultFetchError('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.');\n}\nfunction determineHost(configuredHost) {\n    let host;\n    if (configuredHost !== undefined) {\n        if (!configuredHost.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n            host = new URL(window.location.protocol + '//' + configuredHost);\n        }\n        else {\n            host = new URL(configuredHost);\n        }\n    }\n    else {\n        // Mainnet, local, and remote environments will have the api route available\n        const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n        const remoteHosts = ['.github.dev', '.gitpod.io'];\n        const location = typeof window !== 'undefined' ? window.location : undefined;\n        const hostname = location === null || location === void 0 ? void 0 : location.hostname;\n        let knownHost;\n        if (hostname && typeof hostname === 'string') {\n            if (remoteHosts.some(host => hostname.endsWith(host))) {\n                knownHost = hostname;\n            }\n            else {\n                knownHost = knownHosts.find(host => hostname.endsWith(host));\n            }\n        }\n        if (location && knownHost) {\n            // If the user is on a boundary-node provided host, we can use the same host for the agent\n            host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);\n        }\n        else {\n            host = new URL('https://icp-api.io');\n        }\n    }\n    return host.toString();\n}\n/**\n * A HTTP agent allows users to interact with a client of the internet computer\nusing the available methods. It exposes an API that closely follows the\npublic view of the internet computer, and is not intended to be exposed\ndirectly to the majority of users due to its low-level interface.\n * There is a pipeline to apply transformations to the request before sending\nit to the client. This is to decouple signature, nonce generation and\nother computations so that this class can stay as simple as possible while\nallowing extensions.\n */\nclass HttpAgent {\n    /**\n     * @param options - Options for the HttpAgent\n     * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead\n     */\n    constructor(options = {}) {\n        var _a;\n        _HttpAgent_instances.add(this);\n        _HttpAgent_identity.set(this, void 0);\n        _HttpAgent_fetch.set(this, void 0);\n        _HttpAgent_fetchOptions.set(this, void 0);\n        _HttpAgent_callOptions.set(this, void 0);\n        _HttpAgent_timeDiffMsecs.set(this, 0);\n        _HttpAgent_credentials.set(this, void 0);\n        _HttpAgent_rootKeyFetched.set(this, false);\n        _HttpAgent_retryTimes.set(this, void 0); // Retry requests N times before erroring by default\n        _HttpAgent_backoffStrategy.set(this, void 0);\n        _HttpAgent_maxIngressExpiryInMinutes.set(this, void 0);\n        // Public signature to help with type checking.\n        this._isAgent = true;\n        this.config = {};\n        // The UTC time in milliseconds when the latest request was made\n        _HttpAgent_waterMark.set(this, 0);\n        this.log = new _observable__WEBPACK_IMPORTED_MODULE_14__.ObservableLog();\n        _HttpAgent_queryPipeline.set(this, []);\n        _HttpAgent_updatePipeline.set(this, []);\n        _HttpAgent_subnetKeys.set(this, new _utils_expirableMap__WEBPACK_IMPORTED_MODULE_11__.ExpirableMap({\n            expirationTime: 5 * 60 * 1000, // 5 minutes\n        }));\n        _HttpAgent_verifyQuerySignatures.set(this, true);\n        /**\n         * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n         * @param queryResponse - The response from the query\n         * @param subnetStatus - The subnet status, including all node keys\n         * @returns ApiQueryResponse\n         */\n        _HttpAgent_verifyQueryResponse.set(this, (queryResponse, subnetStatus) => {\n            if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\") === false) {\n                // This should not be called if the user has disabled verification\n                return queryResponse;\n            }\n            if (!subnetStatus) {\n                throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n            }\n            const { status, signatures = [], requestId } = queryResponse;\n            const domainSeparator = new TextEncoder().encode('\\x0Bic-response');\n            for (const sig of signatures) {\n                const { timestamp, identity } = sig;\n                const nodeId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(identity).toText();\n                let hash;\n                // Hash is constructed differently depending on the status\n                if (status === 'replied') {\n                    const { reply } = queryResponse;\n                    hash = (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hashOfMap)({\n                        status: status,\n                        reply: reply,\n                        timestamp: BigInt(timestamp),\n                        request_id: requestId,\n                    });\n                }\n                else if (status === 'rejected') {\n                    const { reject_code, reject_message, error_code } = queryResponse;\n                    hash = (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hashOfMap)({\n                        status: status,\n                        reject_code: reject_code,\n                        reject_message: reject_message,\n                        error_code: error_code,\n                        timestamp: BigInt(timestamp),\n                        request_id: requestId,\n                    });\n                }\n                else {\n                    throw new Error(`Unknown status: ${status}`);\n                }\n                const separatorWithHash = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_5__.concat)(domainSeparator, new Uint8Array(hash));\n                // FIX: check for match without verifying N times\n                const pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);\n                if (!pubKey) {\n                    throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n                }\n                const rawKey = _public_key__WEBPACK_IMPORTED_MODULE_12__.Ed25519PublicKey.fromDer(pubKey).rawKey;\n                const valid = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_17__.ed25519.verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));\n                if (valid)\n                    return queryResponse;\n                throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError(`Invalid signature from replica ${nodeId} signed query.`);\n            }\n            return queryResponse;\n        });\n        this.config = options;\n        __classPrivateFieldSet(this, _HttpAgent_fetch, options.fetch || getDefaultFetch() || fetch.bind(__webpack_require__.g), \"f\");\n        __classPrivateFieldSet(this, _HttpAgent_fetchOptions, options.fetchOptions, \"f\");\n        __classPrivateFieldSet(this, _HttpAgent_callOptions, options.callOptions, \"f\");\n        this.rootKey = options.rootKey ? options.rootKey : (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_5__.fromHex)(IC_ROOT_KEY);\n        const host = determineHost(options.host);\n        this.host = new URL(host);\n        if (options.verifyQuerySignatures !== undefined) {\n            __classPrivateFieldSet(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, \"f\");\n        }\n        // Default is 3\n        __classPrivateFieldSet(this, _HttpAgent_retryTimes, (_a = options.retryTimes) !== null && _a !== void 0 ? _a : 3, \"f\");\n        // Delay strategy for retries. Default is exponential backoff\n        const defaultBackoffFactory = () => new _polling_backoff__WEBPACK_IMPORTED_MODULE_15__.ExponentialBackoff({\n            maxIterations: __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\"),\n        });\n        __classPrivateFieldSet(this, _HttpAgent_backoffStrategy, options.backoffStrategy || defaultBackoffFactory, \"f\");\n        // Rewrite to avoid redirects\n        if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n            this.host.hostname = IC0_DOMAIN;\n        }\n        else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n            this.host.hostname = ICP0_DOMAIN;\n        }\n        else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n            this.host.hostname = ICP_API_DOMAIN;\n        }\n        if (options.credentials) {\n            const { name, password } = options.credentials;\n            __classPrivateFieldSet(this, _HttpAgent_credentials, `${name}${password ? ':' + password : ''}`, \"f\");\n        }\n        __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(options.identity || new _auth__WEBPACK_IMPORTED_MODULE_2__.AnonymousIdentity()), \"f\");\n        if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes > 5) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(`The maximum ingress expiry time is 5 minutes. Provided ingress expiry time is ${options.ingressExpiryInMinutes} minutes.`);\n        }\n        if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes <= 0) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(`Ingress expiry time must be greater than 0. Provided ingress expiry time is ${options.ingressExpiryInMinutes} minutes.`);\n        }\n        __classPrivateFieldSet(this, _HttpAgent_maxIngressExpiryInMinutes, options.ingressExpiryInMinutes || 5, \"f\");\n        // Add a nonce transform to ensure calls are unique\n        this.addTransform('update', (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform)(_types__WEBPACK_IMPORTED_MODULE_7__.makeNonce));\n        if (options.useQueryNonces) {\n            this.addTransform('query', (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform)(_types__WEBPACK_IMPORTED_MODULE_7__.makeNonce));\n        }\n        if (options.logToConsole) {\n            this.log.subscribe(log => {\n                if (log.level === 'error') {\n                    console.error(log.message);\n                }\n                else if (log.level === 'warn') {\n                    console.warn(log.message);\n                }\n                else {\n                    console.log(log.message);\n                }\n            });\n        }\n    }\n    get waterMark() {\n        return __classPrivateFieldGet(this, _HttpAgent_waterMark, \"f\");\n    }\n    static createSync(options = {}) {\n        return new this(Object.assign({}, options));\n    }\n    static async create(options = {\n        shouldFetchRootKey: false,\n    }) {\n        const agent = HttpAgent.createSync(options);\n        const initPromises = [agent.syncTime()];\n        if (agent.host.toString() !== 'https://icp-api.io' && options.shouldFetchRootKey) {\n            initPromises.push(agent.fetchRootKey());\n        }\n        await Promise.all(initPromises);\n        return agent;\n    }\n    static async from(agent) {\n        var _a;\n        try {\n            if ('config' in agent) {\n                return await HttpAgent.create(agent.config);\n            }\n            return await HttpAgent.create({\n                fetch: agent._fetch,\n                fetchOptions: agent._fetchOptions,\n                callOptions: agent._callOptions,\n                host: agent._host.toString(),\n                identity: (_a = agent._identity) !== null && _a !== void 0 ? _a : undefined,\n            });\n        }\n        catch (_b) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError('Failed to create agent from provided agent');\n        }\n    }\n    isLocal() {\n        const hostname = this.host.hostname;\n        return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n    }\n    addTransform(type, fn, priority = fn.priority || 0) {\n        if (type === 'update') {\n            // Keep the pipeline sorted at all time, by priority.\n            const i = __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n            __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").length, 0, Object.assign(fn, { priority }));\n        }\n        else if (type === 'query') {\n            // Keep the pipeline sorted at all time, by priority.\n            const i = __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n            __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").length, 0, Object.assign(fn, { priority }));\n        }\n    }\n    async getPrincipal() {\n        if (!__classPrivateFieldGet(this, _HttpAgent_identity, \"f\")) {\n            throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n        }\n        return (await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\")).getPrincipal();\n    }\n    async call(canisterId, options, identity) {\n        var _a;\n        // TODO - restore this value\n        const callSync = (_a = options.callSync) !== null && _a !== void 0 ? _a : true;\n        const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n        if (!id) {\n            throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n        }\n        const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        const ecid = options.effectiveCanisterId\n            ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(options.effectiveCanisterId)\n            : canister;\n        const sender = id.getPrincipal() || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n        let ingress_expiry = new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, \"f\") * MINUTE_TO_MSECS);\n        // If the value is off by more than 30 seconds, reconcile system time with the network\n        if (Math.abs(__classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, \"f\")) > 1000 * 30) {\n            ingress_expiry = new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, \"f\") * MINUTE_TO_MSECS + __classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, \"f\"));\n        }\n        const submit = {\n            request_type: _types__WEBPACK_IMPORTED_MODULE_7__.SubmitRequestType.Call,\n            canister_id: canister,\n            method_name: options.methodName,\n            arg: options.arg,\n            sender,\n            ingress_expiry,\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let transformedRequest = (await this._transform({\n            request: {\n                body: null,\n                method: 'POST',\n                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? { Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\")) } : {})),\n            },\n            endpoint: \"call\" /* Endpoint.Call */,\n            body: submit,\n        }));\n        const nonce = transformedRequest.body.nonce\n            ? toNonce(transformedRequest.body.nonce)\n            : undefined;\n        submit.nonce = nonce;\n        function toNonce(buf) {\n            return new Uint8Array(buf);\n        }\n        // Apply transform for identity.\n        transformedRequest = await id.transformRequest(transformedRequest);\n        const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);\n        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n        try {\n            // Attempt v3 sync call\n            const requestSync = () => {\n                this.log.print(`fetching \"/api/v3/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n                return __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v3/canister/${ecid.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_callOptions, \"f\")), transformedRequest.request), { body }));\n            };\n            const requestAsync = () => {\n                this.log.print(`fetching \"/api/v2/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n                return __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_callOptions, \"f\")), transformedRequest.request), { body }));\n            };\n            const request = __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n                request: callSync ? requestSync : requestAsync,\n                backoff,\n                tries: 0,\n            });\n            const [response, requestId] = await Promise.all([request, (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.requestIdOf)(submit)]);\n            const responseBuffer = await response.arrayBuffer();\n            const responseBody = (response.status === 200 && responseBuffer.byteLength > 0\n                ? _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(responseBuffer)\n                : null);\n            // Update the watermark with the latest time from consensus\n            if (responseBody && 'certificate' in responseBody) {\n                const time = await this.parseTimeFromResponse({\n                    certificate: responseBody.certificate,\n                });\n                __classPrivateFieldSet(this, _HttpAgent_waterMark, time, \"f\");\n            }\n            return {\n                requestId,\n                response: {\n                    ok: response.ok,\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: responseBody,\n                    headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),\n                },\n                requestDetails: submit,\n            };\n        }\n        catch (error) {\n            // If the error is due to the v3 api not being supported, fall back to v2\n            if (error.message.includes('v3 api not supported.')) {\n                this.log.warn('v3 api not supported. Fall back to v2');\n                return this.call(canisterId, Object.assign(Object.assign({}, options), { \n                    // disable v3 api\n                    callSync: false }), identity);\n            }\n            this.log.error('Error while making call:', error);\n            throw error;\n        }\n    }\n    async query(canisterId, fields, identity) {\n        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n        const ecid = fields.effectiveCanisterId\n            ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(fields.effectiveCanisterId)\n            : _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        this.log.print(`ecid ${ecid.toString()}`);\n        this.log.print(`canisterId ${canisterId.toString()}`);\n        const makeQuery = async () => {\n            const id = await (identity !== undefined ? identity : __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n            if (!id) {\n                throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n            }\n            const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n            const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n            const request = {\n                request_type: \"query\" /* ReadRequestType.Query */,\n                canister_id: canister,\n                method_name: fields.methodName,\n                arg: fields.arg,\n                sender,\n                ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, \"f\") * MINUTE_TO_MSECS),\n            };\n            const requestId = await (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.requestIdOf)(request);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let transformedRequest = await this._transform({\n                request: {\n                    method: 'POST',\n                    headers: Object.assign({ 'Content-Type': 'application/cbor' }, (__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? { Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\")) } : {})),\n                },\n                endpoint: \"read\" /* Endpoint.Query */,\n                body: request,\n            });\n            // Apply transform for identity.\n            transformedRequest = (await (id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest)));\n            const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);\n            const args = {\n                canister: canister.toText(),\n                ecid,\n                transformedRequest,\n                body,\n                requestId,\n                backoff,\n                tries: 0,\n            };\n            return {\n                requestDetails: request,\n                query: await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, args),\n            };\n        };\n        const getSubnetStatus = async () => {\n            if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n                return undefined;\n            }\n            const subnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(ecid.toString());\n            if (subnetStatus) {\n                return subnetStatus;\n            }\n            await this.fetchSubnetKeys(ecid.toString());\n            return __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(ecid.toString());\n        };\n        // Attempt to make the query i=retryTimes times\n        // Make query and fetch subnet keys in parallel\n        const [queryResult, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n        const { requestDetails, query } = queryResult;\n        const queryWithDetails = Object.assign(Object.assign({}, query), { requestDetails });\n        this.log.print('Query response:', queryWithDetails);\n        // Skip verification if the user has disabled it\n        if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n            return queryWithDetails;\n        }\n        try {\n            return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, queryWithDetails, subnetStatus);\n        }\n        catch (_a) {\n            // In case the node signatures have changed, refresh the subnet keys and try again\n            this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');\n            __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").delete(canisterId.toString());\n            await this.fetchSubnetKeys(ecid.toString());\n            const updatedSubnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(canisterId.toString());\n            if (!updatedSubnetStatus) {\n                throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n            }\n            return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, queryWithDetails, updatedSubnetStatus);\n        }\n    }\n    async createReadStateRequest(fields, identity) {\n        const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n        if (!id) {\n            throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n        }\n        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const transformedRequest = await this._transform({\n            request: {\n                method: 'POST',\n                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? { Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\")) } : {})),\n            },\n            endpoint: \"read_state\" /* Endpoint.ReadState */,\n            body: {\n                request_type: \"read_state\" /* ReadRequestType.ReadState */,\n                paths: fields.paths,\n                sender,\n                ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, \"f\") * MINUTE_TO_MSECS),\n            },\n        });\n        // Apply transform for identity.\n        return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);\n    }\n    async readState(canisterId, fields, identity, \n    // eslint-disable-next-line\n    request) {\n        const canister = typeof canisterId === 'string' ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(canisterId) : canisterId;\n        const transformedRequest = request !== null && request !== void 0 ? request : (await this.createReadStateRequest(fields, identity));\n        // With read_state, we should always use a fresh expiry, even beyond the point where the initial request would have expired\n        const bodyWithAdjustedExpiry = Object.assign(Object.assign({}, transformedRequest.body), { ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(_constants__WEBPACK_IMPORTED_MODULE_16__.DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS) });\n        const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(bodyWithAdjustedExpiry);\n        this.log.print(`fetching \"/api/v2/canister/${canister}/read_state\" with request:`, transformedRequest);\n        // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n        try {\n            const response = await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n                request: () => __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\")), transformedRequest.request), { body })),\n                backoff,\n                tries: 0,\n            });\n            if (!response.ok) {\n                throw new Error(`Server returned an error:\\n` +\n                    `  Code: ${response.status} (${response.statusText})\\n` +\n                    `  Body: ${await response.text()}\\n`);\n            }\n            const decodedResponse = _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await response.arrayBuffer());\n            this.log.print('Read state response:', decodedResponse);\n            const parsedTime = await this.parseTimeFromResponse(decodedResponse);\n            if (parsedTime > 0) {\n                this.log.print('Read state response time:', parsedTime);\n                __classPrivateFieldSet(this, _HttpAgent_waterMark, parsedTime, \"f\");\n            }\n            return decodedResponse;\n        }\n        catch (error) {\n            this.log.error('Caught exception while attempting to read state', error);\n            throw error;\n        }\n    }\n    async parseTimeFromResponse(response) {\n        let tree;\n        if (response.certificate) {\n            const decoded = _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(response.certificate);\n            if (decoded && 'tree' in decoded) {\n                tree = decoded.tree;\n            }\n            else {\n                throw new Error('Could not decode time from response');\n            }\n            const timeLookup = (0,_certificate__WEBPACK_IMPORTED_MODULE_10__.lookup_path)(['time'], tree);\n            if (timeLookup.status !== _certificate__WEBPACK_IMPORTED_MODULE_10__.LookupStatus.Found) {\n                throw new Error('Time was not found in the response or was not in its expected format.');\n            }\n            if (!(timeLookup.value instanceof ArrayBuffer) && !ArrayBuffer.isView(timeLookup)) {\n                throw new Error('Time was not found in the response or was not in its expected format.');\n            }\n            const date = (0,_utils_leb__WEBPACK_IMPORTED_MODULE_13__.decodeTime)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_5__.bufFromBufLike)(timeLookup.value));\n            this.log.print('Time from response:', date);\n            this.log.print('Time from response in milliseconds:', Number(date));\n            return Number(date);\n        }\n        else {\n            this.log.warn('No certificate found in response');\n        }\n        return 0;\n    }\n    /**\n     * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n     * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n     */\n    async syncTime(canisterId) {\n        const CanisterStatus = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../canisterStatus */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\"));\n        const callTime = Date.now();\n        try {\n            if (!canisterId) {\n                this.log.print('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');\n            }\n            const status = await CanisterStatus.request({\n                // Fall back with canisterId of the ICP Ledger\n                canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n                agent: this,\n                paths: ['time'],\n            });\n            const replicaTime = status.get('time');\n            if (replicaTime) {\n                __classPrivateFieldSet(this, _HttpAgent_timeDiffMsecs, Number(replicaTime) - Number(callTime), \"f\");\n            }\n        }\n        catch (error) {\n            this.log.error('Caught exception while attempting to sync time', error);\n        }\n    }\n    async status() {\n        const headers = __classPrivateFieldGet(this, _HttpAgent_credentials, \"f\")\n            ? {\n                Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\")),\n            }\n            : {};\n        this.log.print(`fetching \"/api/v2/status\"`);\n        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n        const response = await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n            backoff,\n            request: () => __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/status`, this.host), Object.assign({ headers }, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\"))),\n            tries: 0,\n        });\n        return _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await response.arrayBuffer());\n    }\n    async fetchRootKey() {\n        if (!__classPrivateFieldGet(this, _HttpAgent_rootKeyFetched, \"f\")) {\n            const status = await this.status();\n            // Hex-encoded version of the replica root key\n            this.rootKey = status.root_key;\n            __classPrivateFieldSet(this, _HttpAgent_rootKeyFetched, true, \"f\");\n        }\n        return this.rootKey;\n    }\n    invalidateIdentity() {\n        __classPrivateFieldSet(this, _HttpAgent_identity, null, \"f\");\n    }\n    replaceIdentity(identity) {\n        __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(identity), \"f\");\n    }\n    async fetchSubnetKeys(canisterId) {\n        const effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        const response = await (0,_canisterStatus__WEBPACK_IMPORTED_MODULE_9__.request)({\n            canisterId: effectiveCanisterId,\n            paths: ['subnet'],\n            agent: this,\n        });\n        const subnetResponse = response.get('subnet');\n        if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n            __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").set(effectiveCanisterId.toText(), subnetResponse);\n            return subnetResponse;\n        }\n        // If the subnet status is not returned, return undefined\n        return undefined;\n    }\n    _transform(request) {\n        let p = Promise.resolve(request);\n        if (request.endpoint === \"call\" /* Endpoint.Call */) {\n            for (const fn of __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\")) {\n                p = p.then(r => fn(r).then(r2 => r2 || r));\n            }\n        }\n        else {\n            for (const fn of __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\")) {\n                p = p.then(r => fn(r).then(r2 => r2 || r));\n            }\n        }\n        return p;\n    }\n}\n_HttpAgent_identity = new WeakMap(), _HttpAgent_fetch = new WeakMap(), _HttpAgent_fetchOptions = new WeakMap(), _HttpAgent_callOptions = new WeakMap(), _HttpAgent_timeDiffMsecs = new WeakMap(), _HttpAgent_credentials = new WeakMap(), _HttpAgent_rootKeyFetched = new WeakMap(), _HttpAgent_retryTimes = new WeakMap(), _HttpAgent_backoffStrategy = new WeakMap(), _HttpAgent_maxIngressExpiryInMinutes = new WeakMap(), _HttpAgent_waterMark = new WeakMap(), _HttpAgent_queryPipeline = new WeakMap(), _HttpAgent_updatePipeline = new WeakMap(), _HttpAgent_subnetKeys = new WeakMap(), _HttpAgent_verifyQuerySignatures = new WeakMap(), _HttpAgent_verifyQueryResponse = new WeakMap(), _HttpAgent_instances = new WeakSet(), _HttpAgent_requestAndRetryQuery = async function _HttpAgent_requestAndRetryQuery(args) {\n    var _a, _b;\n    const { ecid, transformedRequest, body, requestId, backoff, tries } = args;\n    const delay = tries === 0 ? 0 : backoff.next();\n    this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with tries:`, {\n        tries,\n        backoff,\n        delay,\n    });\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n    }\n    if (delay > 0) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    let response;\n    // Make the request and retry if it throws an error\n    try {\n        this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with request:`, transformedRequest);\n        const fetchResponse = await __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\")), transformedRequest.request), { body }));\n        if (fetchResponse.status === 200) {\n            const queryResponse = _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await fetchResponse.arrayBuffer());\n            response = Object.assign(Object.assign({}, queryResponse), { httpDetails: {\n                    ok: fetchResponse.ok,\n                    status: fetchResponse.status,\n                    statusText: fetchResponse.statusText,\n                    headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(fetchResponse.headers),\n                }, requestId });\n        }\n        else {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_8__.AgentHTTPResponseError(`Gateway returned an error:\\n` +\n                `  Code: ${fetchResponse.status} (${fetchResponse.statusText})\\n` +\n                `  Body: ${await fetchResponse.text()}\\n`, {\n                ok: fetchResponse.ok,\n                status: fetchResponse.status,\n                statusText: fetchResponse.statusText,\n                headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(fetchResponse.headers),\n            });\n        }\n    }\n    catch (error) {\n        if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n            this.log.warn(`Caught exception while attempting to make query:\\n` +\n                `  ${error}\\n` +\n                `  Retrying query.`);\n            return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, Object.assign(Object.assign({}, args), { tries: tries + 1 }));\n        }\n        throw error;\n    }\n    const timestamp = (_b = (_a = response.signatures) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.timestamp;\n    // Skip watermark verification if the user has set verifyQuerySignatures to false\n    if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n        return response;\n    }\n    if (!timestamp) {\n        throw new Error('Timestamp not found in query response. This suggests a malformed or malicious response.');\n    }\n    // Convert the timestamp to milliseconds\n    const timeStampInMs = Number(BigInt(timestamp) / BigInt(1000000));\n    this.log.print('watermark and timestamp', {\n        waterMark: this.waterMark,\n        timestamp: timeStampInMs,\n    });\n    // If the timestamp is less than the watermark, retry the request up to the retry limit\n    if (Number(this.waterMark) > timeStampInMs) {\n        const error = new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError('Timestamp is below the watermark. Retrying query.');\n        this.log.error('Timestamp is below', error, {\n            timestamp,\n            waterMark: this.waterMark,\n        });\n        if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n            return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, Object.assign(Object.assign({}, args), { tries: tries + 1 }));\n        }\n        {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n        }\n    }\n    return response;\n}, _HttpAgent_requestAndRetry = async function _HttpAgent_requestAndRetry(args) {\n    const { request, backoff, tries } = args;\n    const delay = tries === 0 ? 0 : backoff.next();\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n    }\n    if (delay > 0) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    let response;\n    try {\n        response = await request();\n    }\n    catch (error) {\n        if (__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\") > tries) {\n            this.log.warn(`Caught exception while attempting to make request:\\n` +\n                `  ${error}\\n` +\n                `  Retrying request.`);\n            // Delay the request by the configured backoff strategy\n            return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, { request, backoff, tries: tries + 1 });\n        }\n        throw error;\n    }\n    if (response.ok) {\n        return response;\n    }\n    const responseText = await response.clone().text();\n    const errorMessage = `Server returned an error:\\n` +\n        `  Code: ${response.status} (${response.statusText})\\n` +\n        `  Body: ${responseText}\\n`;\n    if (response.status === 404 && response.url.includes('api/v3')) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_8__.AgentHTTPResponseError('v3 api not supported. Fall back to v2', {\n            ok: response.ok,\n            status: response.status,\n            statusText: response.statusText,\n            headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),\n        });\n    }\n    if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n        return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, { request, backoff, tries: tries + 1 });\n    }\n    throw new _errors__WEBPACK_IMPORTED_MODULE_8__.AgentHTTPResponseError(errorMessage, {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n        headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),\n    });\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQztBQUNMO0FBQ0s7QUFDWjtBQUN1QjtBQUNXO0FBQ1c7QUFDeEI7QUFDTjtBQUNIO0FBQzhDO0FBQzdDO0FBQ1E7QUFDSjtBQUNQO0FBQ0k7QUFDVTtBQUNhO0FBQzNDO0FBQ087QUFDN0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0VBQWtFO0FBQ25FO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0NBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQywrQ0FBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBTTtBQUMxQjtBQUNBLFlBQVkscUJBQU07QUFDbEIsMkJBQTJCLHFCQUFNLFlBQVkscUJBQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQixJQUFJLFVBQVUsRUFBRSx5Q0FBeUM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFhO0FBQ3BDO0FBQ0E7QUFDQSw0Q0FBNEMsOERBQVk7QUFDeEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUVBQTRCO0FBQ3REO0FBQ0Esb0JBQW9CLHFDQUFxQztBQUN6RDtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QywrQkFBK0IseURBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEMsMkJBQTJCLHNEQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEIsMENBQTBDO0FBQ3RFLDJCQUEyQixzREFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0EsMENBQTBDLHFEQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1RUFBNEI7QUFDMUQ7QUFDQSwrQkFBK0IsMERBQWdCO0FBQy9DLDhCQUE4QiwyREFBTztBQUNyQztBQUNBO0FBQ0EsMEJBQTBCLHVFQUE0QixtQ0FBbUMsUUFBUTtBQUNqRztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0dBQXdHLHFCQUFNO0FBQzlHO0FBQ0E7QUFDQSwyREFBMkQsc0RBQU87QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpRUFBa0I7QUFDbEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxvRUFBb0UsS0FBSyxFQUFFLCtCQUErQjtBQUMxRztBQUNBLGtHQUFrRyxvREFBaUI7QUFDbkg7QUFDQSxzQkFBc0IsK0NBQVUsa0ZBQWtGLGdDQUFnQztBQUNsSjtBQUNBO0FBQ0Esc0JBQXNCLCtDQUFVLGdGQUFnRixnQ0FBZ0M7QUFDaEo7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtEQUFrQixDQUFDLDZDQUFTO0FBQ2hFO0FBQ0EsdUNBQXVDLCtEQUFrQixDQUFDLDZDQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0JBQXNCLCtDQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUxBQXlMLFVBQVU7QUFDbk07QUFDQTtBQUNBO0FBQ0E7QUFDQSx1TEFBdUwsVUFBVTtBQUNqTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBUztBQUNsQztBQUNBLGNBQWMseURBQVM7QUFDdkI7QUFDQSw0Q0FBNEMseURBQVM7QUFDckQsaUNBQWlDLCtDQUFNO0FBQ3ZDO0FBQ0E7QUFDQSxpQ0FBaUMsK0NBQU07QUFDdkM7QUFDQTtBQUNBLDBCQUEwQixxREFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQ0FBb0MsaUVBQWlFLDRGQUE0RixJQUFJO0FBQzlPLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFLHVIQUF1SCxjQUFjLGdFQUFnRSw2RkFBNkYsTUFBTTtBQUN4UztBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0UsdUhBQXVILGNBQWMsZ0VBQWdFLDZGQUE2RixNQUFNO0FBQ3hTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0VBQXNFLHdEQUFXO0FBQ2pGO0FBQ0E7QUFDQSxrQkFBa0IseUNBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQW9CO0FBQ2pELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBUztBQUN2QixjQUFjLHlEQUFTO0FBQ3ZCLCtCQUErQixnQkFBZ0I7QUFDL0MscUNBQXFDLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlEQUFTO0FBQ3RDLDBGQUEwRix5REFBUztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0NBQU07QUFDMUM7QUFDQSxvQ0FBb0Msd0RBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0NBQW9DLGlFQUFpRSw0RkFBNEYsSUFBSTtBQUNsUCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EseUJBQXlCLHlDQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QywrREFBK0QsWUFBWSxnQkFBZ0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVFQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YseURBQVM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0NBQW9DLGlFQUFpRSw0RkFBNEYsSUFBSTtBQUM5TyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQ0FBTTtBQUMxQyxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5REFBUztBQUNuRTtBQUNBO0FBQ0EscUVBQXFFLDhCQUE4QixvQkFBb0IsK0NBQU0sQ0FBQyw4RUFBcUMsR0FBRztBQUN0SyxxQkFBcUIseUNBQVc7QUFDaEMscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0gsb0JBQW9CLHNFQUFzRSw4RkFBOEYsTUFBTTtBQUM3VDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCLEdBQUcsb0JBQW9CO0FBQ3ZFLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQSxvQ0FBb0MseUNBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUNBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBEQUFXO0FBQzFDLHNDQUFzQyx1REFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFVLENBQUMsNkRBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EscUNBQXFDLGtTQUE4QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Rix5REFBUztBQUNqRztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUpBQXFKLFNBQVM7QUFDOUo7QUFDQSxTQUFTO0FBQ1QsZUFBZSx5Q0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlEQUFTO0FBQzdDLCtCQUErQix3REFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUE0RDtBQUN4RTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0IsK0NBQVUseUVBQXlFLDBEQUEwRDtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckUsb0lBQW9JLGdCQUFnQixpRUFBaUUsOEZBQThGLE1BQU07QUFDelQ7QUFDQSxrQ0FBa0MseUNBQVc7QUFDN0MscURBQXFELG9CQUFvQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQW9CO0FBQ2pELGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQXNCO0FBQzVDLDJCQUEyQixzQkFBc0IsR0FBRyx5QkFBeUI7QUFDN0UsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUVBQW9CO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQSwySkFBMkosV0FBVyxrQkFBa0I7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwySkFBMkosV0FBVyxrQkFBa0I7QUFDeEw7QUFDQTtBQUNBLHNCQUFzQiwrQ0FBVSx5RUFBeUUsMERBQTBEO0FBQ25LO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0NBQVUseUVBQXlFLDBEQUEwRDtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBLDBIQUEwSCxvQ0FBb0M7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUIsR0FBRyxvQkFBb0I7QUFDM0QsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQSxrQkFBa0IsMkRBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpRUFBb0I7QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQSxzSEFBc0gsb0NBQW9DO0FBQzFKO0FBQ0EsY0FBYywyREFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlFQUFvQjtBQUNyQyxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0h0dHBBZ2VudF9pbnN0YW5jZXMsIF9IdHRwQWdlbnRfaWRlbnRpdHksIF9IdHRwQWdlbnRfZmV0Y2gsIF9IdHRwQWdlbnRfZmV0Y2hPcHRpb25zLCBfSHR0cEFnZW50X2NhbGxPcHRpb25zLCBfSHR0cEFnZW50X3RpbWVEaWZmTXNlY3MsIF9IdHRwQWdlbnRfY3JlZGVudGlhbHMsIF9IdHRwQWdlbnRfcm9vdEtleUZldGNoZWQsIF9IdHRwQWdlbnRfcmV0cnlUaW1lcywgX0h0dHBBZ2VudF9iYWNrb2ZmU3RyYXRlZ3ksIF9IdHRwQWdlbnRfbWF4SW5ncmVzc0V4cGlyeUluTWludXRlcywgX0h0dHBBZ2VudF93YXRlck1hcmssIF9IdHRwQWdlbnRfcXVlcnlQaXBlbGluZSwgX0h0dHBBZ2VudF91cGRhdGVQaXBlbGluZSwgX0h0dHBBZ2VudF9zdWJuZXRLZXlzLCBfSHR0cEFnZW50X3ZlcmlmeVF1ZXJ5U2lnbmF0dXJlcywgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnlRdWVyeSwgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnksIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlSZXNwb25zZTtcbmltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgeyBBZ2VudEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IEFub255bW91c0lkZW50aXR5IH0gZnJvbSAnLi4vLi4vYXV0aCc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJy4uLy4uL2Nib3InO1xuaW1wb3J0IHsgaGFzaE9mTWFwLCByZXF1ZXN0SWRPZiB9IGZyb20gJy4uLy4uL3JlcXVlc3RfaWQnO1xuaW1wb3J0IHsgYnVmRnJvbUJ1Zkxpa2UsIGNvbmNhdCwgZnJvbUhleCB9IGZyb20gJy4uLy4uL3V0aWxzL2J1ZmZlcic7XG5pbXBvcnQgeyBFeHBpcnksIGh0dHBIZWFkZXJzVHJhbnNmb3JtLCBtYWtlTm9uY2VUcmFuc2Zvcm0gfSBmcm9tICcuL3RyYW5zZm9ybXMnO1xuaW1wb3J0IHsgbWFrZU5vbmNlLCBTdWJtaXRSZXF1ZXN0VHlwZSwgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEFnZW50SFRUUFJlc3BvbnNlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnLi4vLi4vY2FuaXN0ZXJTdGF0dXMnO1xuaW1wb3J0IHsgQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvciwgTG9va3VwU3RhdHVzLCBsb29rdXBfcGF0aCwgfSBmcm9tICcuLi8uLi9jZXJ0aWZpY2F0ZSc7XG5pbXBvcnQgeyBlZDI1NTE5IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5JztcbmltcG9ydCB7IEV4cGlyYWJsZU1hcCB9IGZyb20gJy4uLy4uL3V0aWxzL2V4cGlyYWJsZU1hcCc7XG5pbXBvcnQgeyBFZDI1NTE5UHVibGljS2V5IH0gZnJvbSAnLi4vLi4vcHVibGljX2tleSc7XG5pbXBvcnQgeyBkZWNvZGVUaW1lIH0gZnJvbSAnLi4vLi4vdXRpbHMvbGViJztcbmltcG9ydCB7IE9ic2VydmFibGVMb2cgfSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlJztcbmltcG9ydCB7IEV4cG9uZW50aWFsQmFja29mZiB9IGZyb20gJy4uLy4uL3BvbGxpbmcvYmFja29mZic7XG5pbXBvcnQgeyBERUZBVUxUX0lOR1JFU1NfRVhQSVJZX0RFTFRBX0lOX01TRUNTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmV4cG9ydCAqIGZyb20gJy4vdHJhbnNmb3Jtcyc7XG5leHBvcnQgeyBtYWtlTm9uY2UgfSBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCB2YXIgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzO1xuKGZ1bmN0aW9uIChSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMpIHtcbiAgICBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXNbXCJSZWNlaXZlZFwiXSA9IFwicmVjZWl2ZWRcIjtcbiAgICBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXNbXCJQcm9jZXNzaW5nXCJdID0gXCJwcm9jZXNzaW5nXCI7XG4gICAgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzW1wiUmVwbGllZFwiXSA9IFwicmVwbGllZFwiO1xuICAgIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1c1tcIlJlamVjdGVkXCJdID0gXCJyZWplY3RlZFwiO1xuICAgIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1c1tcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbiAgICBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXNbXCJEb25lXCJdID0gXCJkb25lXCI7XG59KShSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMgfHwgKFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cyA9IHt9KSk7XG5jb25zdCBNSU5VVEVfVE9fTVNFQ1MgPSA2MCAqIDEwMDA7XG4vLyBSb290IHB1YmxpYyBrZXkgZm9yIHRoZSBJQywgZW5jb2RlZCBhcyBoZXhcbmV4cG9ydCBjb25zdCBJQ19ST09UX0tFWSA9ICczMDgxODIzMDFkMDYwZDJiMDYwMTA0MDE4MmRjN2MwNTAzMDEwMjAxMDYwYzJiMDYwMTA0MDE4MmRjN2MwNTAzMDIwMTAzNjEwMDgxNCcgK1xuICAgICdjMGU2ZWM3MWZhYjU4M2IwOGJkODEzNzNjMjU1YzNjMzcxYjJlODQ4NjNjOThhNGYxZTA4Yjc0MjM1ZDE0ZmI1ZDljMGNkNTQ2ZDk2OCcgK1xuICAgICc1ZjkxM2EwYzBiMmNjNTM0MTU4M2JmNGI0MzkyZTQ2N2RiOTZkNjViOWJiNGNiNzE3MTEyZjg0NzJlMGQ1YTRkMTQ1MDVmZmQ3NDg0JyArXG4gICAgJ2IwMTI5MTA5MWM1Zjg3Yjk4ODgzNDYzZjk4MDkxYTBiYWFhZSc7XG5leHBvcnQgY29uc3QgTUFOQUdFTUVOVF9DQU5JU1RFUl9JRCA9ICdhYWFhYS1hYSc7XG4vLyBJQzAgZG9tYWluIGluZm9cbmNvbnN0IElDMF9ET01BSU4gPSAnaWMwLmFwcCc7XG5jb25zdCBJQzBfU1VCX0RPTUFJTiA9ICcuaWMwLmFwcCc7XG5jb25zdCBJQ1AwX0RPTUFJTiA9ICdpY3AwLmlvJztcbmNvbnN0IElDUDBfU1VCX0RPTUFJTiA9ICcuaWNwMC5pbyc7XG5jb25zdCBJQ1BfQVBJX0RPTUFJTiA9ICdpY3AtYXBpLmlvJztcbmNvbnN0IElDUF9BUElfU1VCX0RPTUFJTiA9ICcuaWNwLWFwaS5pbyc7XG5jbGFzcyBIdHRwRGVmYXVsdEZldGNoRXJyb3IgZXh0ZW5kcyBBZ2VudEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJZGVudGl0eUludmFsaWRFcnJvciBleHRlbmRzIEFnZW50RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEZldGNoKCkge1xuICAgIGxldCBkZWZhdWx0RmV0Y2g7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEJyb3dzZXIgY29udGV4dFxuICAgICAgICBpZiAod2luZG93LmZldGNoKSB7XG4gICAgICAgICAgICBkZWZhdWx0RmV0Y2ggPSB3aW5kb3cuZmV0Y2guYmluZCh3aW5kb3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEh0dHBEZWZhdWx0RmV0Y2hFcnJvcignRmV0Y2ggaW1wbGVtZW50YXRpb24gd2FzIG5vdCBhdmFpbGFibGUuIFlvdSBhcHBlYXIgdG8gYmUgaW4gYSBicm93c2VyIGNvbnRleHQsIGJ1dCB3aW5kb3cuZmV0Y2ggd2FzIG5vdCBwcmVzZW50LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE5vZGUgY29udGV4dFxuICAgICAgICBpZiAoZ2xvYmFsLmZldGNoKSB7XG4gICAgICAgICAgICBkZWZhdWx0RmV0Y2ggPSBnbG9iYWwuZmV0Y2guYmluZChnbG9iYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEh0dHBEZWZhdWx0RmV0Y2hFcnJvcignRmV0Y2ggaW1wbGVtZW50YXRpb24gd2FzIG5vdCBhdmFpbGFibGUuIFlvdSBhcHBlYXIgdG8gYmUgaW4gYSBOb2RlLmpzIGNvbnRleHQsIGJ1dCBnbG9iYWwuZmV0Y2ggd2FzIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChzZWxmLmZldGNoKSB7XG4gICAgICAgICAgICBkZWZhdWx0RmV0Y2ggPSBzZWxmLmZldGNoLmJpbmQoc2VsZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRGZXRjaCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEZldGNoO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSHR0cERlZmF1bHRGZXRjaEVycm9yKCdGZXRjaCBpbXBsZW1lbnRhdGlvbiB3YXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIHByb3ZpZGUgZmV0Y2ggdG8gdGhlIEh0dHBBZ2VudCBjb25zdHJ1Y3Rvciwgb3IgZW5zdXJlIGl0IGlzIGF2YWlsYWJsZSBpbiB0aGUgd2luZG93IG9yIGdsb2JhbCBjb250ZXh0LicpO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lSG9zdChjb25maWd1cmVkSG9zdCkge1xuICAgIGxldCBob3N0O1xuICAgIGlmIChjb25maWd1cmVkSG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghY29uZmlndXJlZEhvc3QubWF0Y2goL15bYS16XSs6LykgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGhvc3QgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBjb25maWd1cmVkSG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBob3N0ID0gbmV3IFVSTChjb25maWd1cmVkSG9zdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE1haW5uZXQsIGxvY2FsLCBhbmQgcmVtb3RlIGVudmlyb25tZW50cyB3aWxsIGhhdmUgdGhlIGFwaSByb3V0ZSBhdmFpbGFibGVcbiAgICAgICAgY29uc3Qga25vd25Ib3N0cyA9IFsnaWMwLmFwcCcsICdpY3AwLmlvJywgJzEyNy4wLjAuMScsICdsb2NhbGhvc3QnXTtcbiAgICAgICAgY29uc3QgcmVtb3RlSG9zdHMgPSBbJy5naXRodWIuZGV2JywgJy5naXRwb2QuaW8nXTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBsb2NhdGlvbiA9PT0gbnVsbCB8fCBsb2NhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIGxldCBrbm93bkhvc3Q7XG4gICAgICAgIGlmIChob3N0bmFtZSAmJiB0eXBlb2YgaG9zdG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAocmVtb3RlSG9zdHMuc29tZShob3N0ID0+IGhvc3RuYW1lLmVuZHNXaXRoKGhvc3QpKSkge1xuICAgICAgICAgICAgICAgIGtub3duSG9zdCA9IGhvc3RuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga25vd25Ib3N0ID0ga25vd25Ib3N0cy5maW5kKGhvc3QgPT4gaG9zdG5hbWUuZW5kc1dpdGgoaG9zdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhdGlvbiAmJiBrbm93bkhvc3QpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIG9uIGEgYm91bmRhcnktbm9kZSBwcm92aWRlZCBob3N0LCB3ZSBjYW4gdXNlIHRoZSBzYW1lIGhvc3QgZm9yIHRoZSBhZ2VudFxuICAgICAgICAgICAgaG9zdCA9IG5ldyBVUkwoYCR7bG9jYXRpb24ucHJvdG9jb2x9Ly8ke2tub3duSG9zdH0ke2xvY2F0aW9uLnBvcnQgPyAnOicgKyBsb2NhdGlvbi5wb3J0IDogJyd9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBob3N0ID0gbmV3IFVSTCgnaHR0cHM6Ly9pY3AtYXBpLmlvJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhvc3QudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogQSBIVFRQIGFnZW50IGFsbG93cyB1c2VycyB0byBpbnRlcmFjdCB3aXRoIGEgY2xpZW50IG9mIHRoZSBpbnRlcm5ldCBjb21wdXRlclxudXNpbmcgdGhlIGF2YWlsYWJsZSBtZXRob2RzLiBJdCBleHBvc2VzIGFuIEFQSSB0aGF0IGNsb3NlbHkgZm9sbG93cyB0aGVcbnB1YmxpYyB2aWV3IG9mIHRoZSBpbnRlcm5ldCBjb21wdXRlciwgYW5kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSBleHBvc2VkXG5kaXJlY3RseSB0byB0aGUgbWFqb3JpdHkgb2YgdXNlcnMgZHVlIHRvIGl0cyBsb3ctbGV2ZWwgaW50ZXJmYWNlLlxuICogVGhlcmUgaXMgYSBwaXBlbGluZSB0byBhcHBseSB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIHJlcXVlc3QgYmVmb3JlIHNlbmRpbmdcbml0IHRvIHRoZSBjbGllbnQuIFRoaXMgaXMgdG8gZGVjb3VwbGUgc2lnbmF0dXJlLCBub25jZSBnZW5lcmF0aW9uIGFuZFxub3RoZXIgY29tcHV0YXRpb25zIHNvIHRoYXQgdGhpcyBjbGFzcyBjYW4gc3RheSBhcyBzaW1wbGUgYXMgcG9zc2libGUgd2hpbGVcbmFsbG93aW5nIGV4dGVuc2lvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBIdHRwQWdlbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIEh0dHBBZ2VudFxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgSHR0cEFnZW50LmNyZWF0ZWAgb3IgYEh0dHBBZ2VudC5jcmVhdGVTeW5jYCBpbnN0ZWFkXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgX0h0dHBBZ2VudF9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICBfSHR0cEFnZW50X2lkZW50aXR5LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfSHR0cEFnZW50X2ZldGNoLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfSHR0cEFnZW50X2ZldGNoT3B0aW9ucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0h0dHBBZ2VudF9jYWxsT3B0aW9ucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0h0dHBBZ2VudF90aW1lRGlmZk1zZWNzLnNldCh0aGlzLCAwKTtcbiAgICAgICAgX0h0dHBBZ2VudF9jcmVkZW50aWFscy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0h0dHBBZ2VudF9yb290S2V5RmV0Y2hlZC5zZXQodGhpcywgZmFsc2UpO1xuICAgICAgICBfSHR0cEFnZW50X3JldHJ5VGltZXMuc2V0KHRoaXMsIHZvaWQgMCk7IC8vIFJldHJ5IHJlcXVlc3RzIE4gdGltZXMgYmVmb3JlIGVycm9yaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgX0h0dHBBZ2VudF9iYWNrb2ZmU3RyYXRlZ3kuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9IdHRwQWdlbnRfbWF4SW5ncmVzc0V4cGlyeUluTWludXRlcy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgLy8gUHVibGljIHNpZ25hdHVyZSB0byBoZWxwIHdpdGggdHlwZSBjaGVja2luZy5cbiAgICAgICAgdGhpcy5faXNBZ2VudCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge307XG4gICAgICAgIC8vIFRoZSBVVEMgdGltZSBpbiBtaWxsaXNlY29uZHMgd2hlbiB0aGUgbGF0ZXN0IHJlcXVlc3Qgd2FzIG1hZGVcbiAgICAgICAgX0h0dHBBZ2VudF93YXRlck1hcmsuc2V0KHRoaXMsIDApO1xuICAgICAgICB0aGlzLmxvZyA9IG5ldyBPYnNlcnZhYmxlTG9nKCk7XG4gICAgICAgIF9IdHRwQWdlbnRfcXVlcnlQaXBlbGluZS5zZXQodGhpcywgW10pO1xuICAgICAgICBfSHR0cEFnZW50X3VwZGF0ZVBpcGVsaW5lLnNldCh0aGlzLCBbXSk7XG4gICAgICAgIF9IdHRwQWdlbnRfc3VibmV0S2V5cy5zZXQodGhpcywgbmV3IEV4cGlyYWJsZU1hcCh7XG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZTogNSAqIDYwICogMTAwMCwgLy8gNSBtaW51dGVzXG4gICAgICAgIH0pKTtcbiAgICAgICAgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMuc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIGh0dHBzOi8vaW50ZXJuZXRjb21wdXRlci5vcmcvZG9jcy9jdXJyZW50L3JlZmVyZW5jZXMvaWMtaW50ZXJmYWNlLXNwZWMvI2h0dHAtcXVlcnkgZm9yIGRldGFpbHMgb24gdmFsaWRhdGlvblxuICAgICAgICAgKiBAcGFyYW0gcXVlcnlSZXNwb25zZSAtIFRoZSByZXNwb25zZSBmcm9tIHRoZSBxdWVyeVxuICAgICAgICAgKiBAcGFyYW0gc3VibmV0U3RhdHVzIC0gVGhlIHN1Ym5ldCBzdGF0dXMsIGluY2x1ZGluZyBhbGwgbm9kZSBrZXlzXG4gICAgICAgICAqIEByZXR1cm5zIEFwaVF1ZXJ5UmVzcG9uc2VcbiAgICAgICAgICovXG4gICAgICAgIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlSZXNwb25zZS5zZXQodGhpcywgKHF1ZXJ5UmVzcG9uc2UsIHN1Ym5ldFN0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMsIFwiZlwiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGlmIHRoZSB1c2VyIGhhcyBkaXNhYmxlZCB2ZXJpZmljYXRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlSZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3VibmV0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGZyb20gcmVwbGljYSBzaWduZWQgcXVlcnk6IG5vIG1hdGNoaW5nIG5vZGUga2V5IGZvdW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBzdGF0dXMsIHNpZ25hdHVyZXMgPSBbXSwgcmVxdWVzdElkIH0gPSBxdWVyeVJlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgZG9tYWluU2VwYXJhdG9yID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdcXHgwQmljLXJlc3BvbnNlJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNpZyBvZiBzaWduYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0aW1lc3RhbXAsIGlkZW50aXR5IH0gPSBzaWc7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gUHJpbmNpcGFsLmZyb21VaW50OEFycmF5KGlkZW50aXR5KS50b1RleHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzaDtcbiAgICAgICAgICAgICAgICAvLyBIYXNoIGlzIGNvbnN0cnVjdGVkIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB0aGUgc3RhdHVzXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3JlcGxpZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVwbHkgfSA9IHF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBoYXNoT2ZNYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseTogcmVwbHksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IEJpZ0ludCh0aW1lc3RhbXApLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdF9pZDogcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVqZWN0X2NvZGUsIHJlamVjdF9tZXNzYWdlLCBlcnJvcl9jb2RlIH0gPSBxdWVyeVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNoID0gaGFzaE9mTWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0X2NvZGU6IHJlamVjdF9jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0X21lc3NhZ2U6IHJlamVjdF9tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfY29kZTogZXJyb3JfY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogQmlnSW50KHRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0X2lkOiByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0YXR1czogJHtzdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvcldpdGhIYXNoID0gY29uY2F0KGRvbWFpblNlcGFyYXRvciwgbmV3IFVpbnQ4QXJyYXkoaGFzaCkpO1xuICAgICAgICAgICAgICAgIC8vIEZJWDogY2hlY2sgZm9yIG1hdGNoIHdpdGhvdXQgdmVyaWZ5aW5nIE4gdGltZXNcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJLZXkgPSBzdWJuZXRTdGF0dXMgPT09IG51bGwgfHwgc3VibmV0U3RhdHVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWJuZXRTdGF0dXMubm9kZUtleXMuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwdWJLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGZyb20gcmVwbGljYSBzaWduZWQgcXVlcnk6IG5vIG1hdGNoaW5nIG5vZGUga2V5IGZvdW5kLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByYXdLZXkgPSBFZDI1NTE5UHVibGljS2V5LmZyb21EZXIocHViS2V5KS5yYXdLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBlZDI1NTE5LnZlcmlmeShzaWcuc2lnbmF0dXJlLCBuZXcgVWludDhBcnJheShzZXBhcmF0b3JXaXRoSGFzaCksIG5ldyBVaW50OEFycmF5KHJhd0tleSkpO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIGZyb20gcmVwbGljYSAke25vZGVJZH0gc2lnbmVkIHF1ZXJ5LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IG9wdGlvbnM7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF9mZXRjaCwgb3B0aW9ucy5mZXRjaCB8fCBnZXREZWZhdWx0RmV0Y2goKSB8fCBmZXRjaC5iaW5kKGdsb2JhbCksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSHR0cEFnZW50X2ZldGNoT3B0aW9ucywgb3B0aW9ucy5mZXRjaE9wdGlvbnMsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSHR0cEFnZW50X2NhbGxPcHRpb25zLCBvcHRpb25zLmNhbGxPcHRpb25zLCBcImZcIik7XG4gICAgICAgIHRoaXMucm9vdEtleSA9IG9wdGlvbnMucm9vdEtleSA/IG9wdGlvbnMucm9vdEtleSA6IGZyb21IZXgoSUNfUk9PVF9LRVkpO1xuICAgICAgICBjb25zdCBob3N0ID0gZGV0ZXJtaW5lSG9zdChvcHRpb25zLmhvc3QpO1xuICAgICAgICB0aGlzLmhvc3QgPSBuZXcgVVJMKGhvc3QpO1xuICAgICAgICBpZiAob3B0aW9ucy52ZXJpZnlRdWVyeVNpZ25hdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSHR0cEFnZW50X3ZlcmlmeVF1ZXJ5U2lnbmF0dXJlcywgb3B0aW9ucy52ZXJpZnlRdWVyeVNpZ25hdHVyZXMsIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IGlzIDNcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSHR0cEFnZW50X3JldHJ5VGltZXMsIChfYSA9IG9wdGlvbnMucmV0cnlUaW1lcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMywgXCJmXCIpO1xuICAgICAgICAvLyBEZWxheSBzdHJhdGVneSBmb3IgcmV0cmllcy4gRGVmYXVsdCBpcyBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgIGNvbnN0IGRlZmF1bHRCYWNrb2ZmRmFjdG9yeSA9ICgpID0+IG5ldyBFeHBvbmVudGlhbEJhY2tvZmYoe1xuICAgICAgICAgICAgbWF4SXRlcmF0aW9uczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3JldHJ5VGltZXMsIFwiZlwiKSxcbiAgICAgICAgfSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF9iYWNrb2ZmU3RyYXRlZ3ksIG9wdGlvbnMuYmFja29mZlN0cmF0ZWd5IHx8IGRlZmF1bHRCYWNrb2ZmRmFjdG9yeSwgXCJmXCIpO1xuICAgICAgICAvLyBSZXdyaXRlIHRvIGF2b2lkIHJlZGlyZWN0c1xuICAgICAgICBpZiAodGhpcy5ob3N0Lmhvc3RuYW1lLmVuZHNXaXRoKElDMF9TVUJfRE9NQUlOKSkge1xuICAgICAgICAgICAgdGhpcy5ob3N0Lmhvc3RuYW1lID0gSUMwX0RPTUFJTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhvc3QuaG9zdG5hbWUuZW5kc1dpdGgoSUNQMF9TVUJfRE9NQUlOKSkge1xuICAgICAgICAgICAgdGhpcy5ob3N0Lmhvc3RuYW1lID0gSUNQMF9ET01BSU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ob3N0Lmhvc3RuYW1lLmVuZHNXaXRoKElDUF9BUElfU1VCX0RPTUFJTikpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdC5ob3N0bmFtZSA9IElDUF9BUElfRE9NQUlOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIHBhc3N3b3JkIH0gPSBvcHRpb25zLmNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSHR0cEFnZW50X2NyZWRlbnRpYWxzLCBgJHtuYW1lfSR7cGFzc3dvcmQgPyAnOicgKyBwYXNzd29yZCA6ICcnfWAsIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9IdHRwQWdlbnRfaWRlbnRpdHksIFByb21pc2UucmVzb2x2ZShvcHRpb25zLmlkZW50aXR5IHx8IG5ldyBBbm9ueW1vdXNJZGVudGl0eSgpKSwgXCJmXCIpO1xuICAgICAgICBpZiAob3B0aW9ucy5pbmdyZXNzRXhwaXJ5SW5NaW51dGVzICYmIG9wdGlvbnMuaW5ncmVzc0V4cGlyeUluTWludXRlcyA+IDUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEVycm9yKGBUaGUgbWF4aW11bSBpbmdyZXNzIGV4cGlyeSB0aW1lIGlzIDUgbWludXRlcy4gUHJvdmlkZWQgaW5ncmVzcyBleHBpcnkgdGltZSBpcyAke29wdGlvbnMuaW5ncmVzc0V4cGlyeUluTWludXRlc30gbWludXRlcy5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbmdyZXNzRXhwaXJ5SW5NaW51dGVzICYmIG9wdGlvbnMuaW5ncmVzc0V4cGlyeUluTWludXRlcyA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRFcnJvcihgSW5ncmVzcyBleHBpcnkgdGltZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLiBQcm92aWRlZCBpbmdyZXNzIGV4cGlyeSB0aW1lIGlzICR7b3B0aW9ucy5pbmdyZXNzRXhwaXJ5SW5NaW51dGVzfSBtaW51dGVzLmApO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF9tYXhJbmdyZXNzRXhwaXJ5SW5NaW51dGVzLCBvcHRpb25zLmluZ3Jlc3NFeHBpcnlJbk1pbnV0ZXMgfHwgNSwgXCJmXCIpO1xuICAgICAgICAvLyBBZGQgYSBub25jZSB0cmFuc2Zvcm0gdG8gZW5zdXJlIGNhbGxzIGFyZSB1bmlxdWVcbiAgICAgICAgdGhpcy5hZGRUcmFuc2Zvcm0oJ3VwZGF0ZScsIG1ha2VOb25jZVRyYW5zZm9ybShtYWtlTm9uY2UpKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudXNlUXVlcnlOb25jZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVHJhbnNmb3JtKCdxdWVyeScsIG1ha2VOb25jZVRyYW5zZm9ybShtYWtlTm9uY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5sb2dUb0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLnN1YnNjcmliZShsb2cgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2cubGV2ZWwgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihsb2cubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvZy5sZXZlbCA9PT0gJ3dhcm4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihsb2cubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhsb2cubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHdhdGVyTWFyaygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF93YXRlck1hcmssIFwiZlwiKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVN5bmMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUob3B0aW9ucyA9IHtcbiAgICAgICAgc2hvdWxkRmV0Y2hSb290S2V5OiBmYWxzZSxcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGFnZW50ID0gSHR0cEFnZW50LmNyZWF0ZVN5bmMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGluaXRQcm9taXNlcyA9IFthZ2VudC5zeW5jVGltZSgpXTtcbiAgICAgICAgaWYgKGFnZW50Lmhvc3QudG9TdHJpbmcoKSAhPT0gJ2h0dHBzOi8vaWNwLWFwaS5pbycgJiYgb3B0aW9ucy5zaG91bGRGZXRjaFJvb3RLZXkpIHtcbiAgICAgICAgICAgIGluaXRQcm9taXNlcy5wdXNoKGFnZW50LmZldGNoUm9vdEtleSgpKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChpbml0UHJvbWlzZXMpO1xuICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBmcm9tKGFnZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgnY29uZmlnJyBpbiBhZ2VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBIdHRwQWdlbnQuY3JlYXRlKGFnZW50LmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgSHR0cEFnZW50LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgZmV0Y2g6IGFnZW50Ll9mZXRjaCxcbiAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnM6IGFnZW50Ll9mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGFnZW50Ll9jYWxsT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBob3N0OiBhZ2VudC5faG9zdC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGlkZW50aXR5OiAoX2EgPSBhZ2VudC5faWRlbnRpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFnZW50RXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYWdlbnQgZnJvbSBwcm92aWRlZCBhZ2VudCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzTG9jYWwoKSB7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gdGhpcy5ob3N0Lmhvc3RuYW1lO1xuICAgICAgICByZXR1cm4gaG9zdG5hbWUgPT09ICcxMjcuMC4wLjEnIHx8IGhvc3RuYW1lLmVuZHNXaXRoKCcxMjcuMC4wLjEnKTtcbiAgICB9XG4gICAgYWRkVHJhbnNmb3JtKHR5cGUsIGZuLCBwcmlvcml0eSA9IGZuLnByaW9yaXR5IHx8IDApIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgICAgICAvLyBLZWVwIHRoZSBwaXBlbGluZSBzb3J0ZWQgYXQgYWxsIHRpbWUsIGJ5IHByaW9yaXR5LlxuICAgICAgICAgICAgY29uc3QgaSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF91cGRhdGVQaXBlbGluZSwgXCJmXCIpLmZpbmRJbmRleCh4ID0+ICh4LnByaW9yaXR5IHx8IDApIDwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3VwZGF0ZVBpcGVsaW5lLCBcImZcIikuc3BsaWNlKGkgPj0gMCA/IGkgOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdXBkYXRlUGlwZWxpbmUsIFwiZlwiKS5sZW5ndGgsIDAsIE9iamVjdC5hc3NpZ24oZm4sIHsgcHJpb3JpdHkgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdxdWVyeScpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgdGhlIHBpcGVsaW5lIHNvcnRlZCBhdCBhbGwgdGltZSwgYnkgcHJpb3JpdHkuXG4gICAgICAgICAgICBjb25zdCBpID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3F1ZXJ5UGlwZWxpbmUsIFwiZlwiKS5maW5kSW5kZXgoeCA9PiAoeC5wcmlvcml0eSB8fCAwKSA8IHByaW9yaXR5KTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9xdWVyeVBpcGVsaW5lLCBcImZcIikuc3BsaWNlKGkgPj0gMCA/IGkgOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfcXVlcnlQaXBlbGluZSwgXCJmXCIpLmxlbmd0aCwgMCwgT2JqZWN0LmFzc2lnbihmbiwgeyBwcmlvcml0eSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJpbmNpcGFsKCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pZGVudGl0eSwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWRlbnRpdHlJbnZhbGlkRXJyb3IoXCJUaGlzIGlkZW50aXR5IGhhcyBleHBpcmVkIGR1ZSB0aGlzIGFwcGxpY2F0aW9uJ3Mgc2VjdXJpdHkgcG9saWN5LiBQbGVhc2UgcmVmcmVzaCB5b3VyIGF1dGhlbnRpY2F0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pZGVudGl0eSwgXCJmXCIpKS5nZXRQcmluY2lwYWwoKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbChjYW5pc3RlcklkLCBvcHRpb25zLCBpZGVudGl0eSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFRPRE8gLSByZXN0b3JlIHRoaXMgdmFsdWVcbiAgICAgICAgY29uc3QgY2FsbFN5bmMgPSAoX2EgPSBvcHRpb25zLmNhbGxTeW5jKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgICAgICBjb25zdCBpZCA9IGF3YWl0IChpZGVudGl0eSAhPT0gdW5kZWZpbmVkID8gYXdhaXQgaWRlbnRpdHkgOiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfaWRlbnRpdHksIFwiZlwiKSk7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJZGVudGl0eUludmFsaWRFcnJvcihcIlRoaXMgaWRlbnRpdHkgaGFzIGV4cGlyZWQgZHVlIHRoaXMgYXBwbGljYXRpb24ncyBzZWN1cml0eSBwb2xpY3kuIFBsZWFzZSByZWZyZXNoIHlvdXIgYXV0aGVudGljYXRpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmlzdGVyID0gUHJpbmNpcGFsLmZyb20oY2FuaXN0ZXJJZCk7XG4gICAgICAgIGNvbnN0IGVjaWQgPSBvcHRpb25zLmVmZmVjdGl2ZUNhbmlzdGVySWRcbiAgICAgICAgICAgID8gUHJpbmNpcGFsLmZyb20ob3B0aW9ucy5lZmZlY3RpdmVDYW5pc3RlcklkKVxuICAgICAgICAgICAgOiBjYW5pc3RlcjtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gaWQuZ2V0UHJpbmNpcGFsKCkgfHwgUHJpbmNpcGFsLmFub255bW91cygpO1xuICAgICAgICBsZXQgaW5ncmVzc19leHBpcnkgPSBuZXcgRXhwaXJ5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9tYXhJbmdyZXNzRXhwaXJ5SW5NaW51dGVzLCBcImZcIikgKiBNSU5VVEVfVE9fTVNFQ1MpO1xuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgb2ZmIGJ5IG1vcmUgdGhhbiAzMCBzZWNvbmRzLCByZWNvbmNpbGUgc3lzdGVtIHRpbWUgd2l0aCB0aGUgbmV0d29ya1xuICAgICAgICBpZiAoTWF0aC5hYnMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3RpbWVEaWZmTXNlY3MsIFwiZlwiKSkgPiAxMDAwICogMzApIHtcbiAgICAgICAgICAgIGluZ3Jlc3NfZXhwaXJ5ID0gbmV3IEV4cGlyeShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfbWF4SW5ncmVzc0V4cGlyeUluTWludXRlcywgXCJmXCIpICogTUlOVVRFX1RPX01TRUNTICsgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3RpbWVEaWZmTXNlY3MsIFwiZlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VibWl0ID0ge1xuICAgICAgICAgICAgcmVxdWVzdF90eXBlOiBTdWJtaXRSZXF1ZXN0VHlwZS5DYWxsLFxuICAgICAgICAgICAgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyLFxuICAgICAgICAgICAgbWV0aG9kX25hbWU6IG9wdGlvbnMubWV0aG9kTmFtZSxcbiAgICAgICAgICAgIGFyZzogb3B0aW9ucy5hcmcsXG4gICAgICAgICAgICBzZW5kZXIsXG4gICAgICAgICAgICBpbmdyZXNzX2V4cGlyeSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkUmVxdWVzdCA9IChhd2FpdCB0aGlzLl90cmFuc2Zvcm0oe1xuICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgIGJvZHk6IG51bGwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vY2JvcicgfSwgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9jcmVkZW50aWFscywgXCJmXCIpID8geyBBdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIGJ0b2EoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2NyZWRlbnRpYWxzLCBcImZcIikpIH0gOiB7fSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZHBvaW50OiBcImNhbGxcIiAvKiBFbmRwb2ludC5DYWxsICovLFxuICAgICAgICAgICAgYm9keTogc3VibWl0LFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gdHJhbnNmb3JtZWRSZXF1ZXN0LmJvZHkubm9uY2VcbiAgICAgICAgICAgID8gdG9Ob25jZSh0cmFuc2Zvcm1lZFJlcXVlc3QuYm9keS5ub25jZSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBzdWJtaXQubm9uY2UgPSBub25jZTtcbiAgICAgICAgZnVuY3Rpb24gdG9Ob25jZShidWYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGx5IHRyYW5zZm9ybSBmb3IgaWRlbnRpdHkuXG4gICAgICAgIHRyYW5zZm9ybWVkUmVxdWVzdCA9IGF3YWl0IGlkLnRyYW5zZm9ybVJlcXVlc3QodHJhbnNmb3JtZWRSZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgYm9keSA9IGNib3IuZW5jb2RlKHRyYW5zZm9ybWVkUmVxdWVzdC5ib2R5KTtcbiAgICAgICAgY29uc3QgYmFja29mZiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9iYWNrb2ZmU3RyYXRlZ3ksIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB2MyBzeW5jIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RTeW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLnByaW50KGBmZXRjaGluZyBcIi9hcGkvdjMvY2FuaXN0ZXIvJHtlY2lkLnRvVGV4dCgpfS9jYWxsXCIgd2l0aCByZXF1ZXN0OmAsIHRyYW5zZm9ybWVkUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9mZXRjaCwgXCJmXCIpLmNhbGwodGhpcywgJycgKyBuZXcgVVJMKGAvYXBpL3YzL2NhbmlzdGVyLyR7ZWNpZC50b1RleHQoKX0vY2FsbGAsIHRoaXMuaG9zdCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfY2FsbE9wdGlvbnMsIFwiZlwiKSksIHRyYW5zZm9ybWVkUmVxdWVzdC5yZXF1ZXN0KSwgeyBib2R5IH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0QXN5bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cucHJpbnQoYGZldGNoaW5nIFwiL2FwaS92Mi9jYW5pc3Rlci8ke2VjaWQudG9UZXh0KCl9L2NhbGxcIiB3aXRoIHJlcXVlc3Q6YCwgdHJhbnNmb3JtZWRSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2ZldGNoLCBcImZcIikuY2FsbCh0aGlzLCAnJyArIG5ldyBVUkwoYC9hcGkvdjIvY2FuaXN0ZXIvJHtlY2lkLnRvVGV4dCgpfS9jYWxsYCwgdGhpcy5ob3N0KSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9jYWxsT3B0aW9ucywgXCJmXCIpKSwgdHJhbnNmb3JtZWRSZXF1ZXN0LnJlcXVlc3QpLCB7IGJvZHkgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfaW5zdGFuY2VzLCBcIm1cIiwgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnkpLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGNhbGxTeW5jID8gcmVxdWVzdFN5bmMgOiByZXF1ZXN0QXN5bmMsXG4gICAgICAgICAgICAgICAgYmFja29mZixcbiAgICAgICAgICAgICAgICB0cmllczogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgW3Jlc3BvbnNlLCByZXF1ZXN0SWRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3JlcXVlc3QsIHJlcXVlc3RJZE9mKHN1Ym1pdCldKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiByZXNwb25zZUJ1ZmZlci5ieXRlTGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gY2Jvci5kZWNvZGUocmVzcG9uc2VCdWZmZXIpXG4gICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgd2F0ZXJtYXJrIHdpdGggdGhlIGxhdGVzdCB0aW1lIGZyb20gY29uc2Vuc3VzXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VCb2R5ICYmICdjZXJ0aWZpY2F0ZScgaW4gcmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZSA9IGF3YWl0IHRoaXMucGFyc2VUaW1lRnJvbVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IHJlc3BvbnNlQm9keS5jZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9IdHRwQWdlbnRfd2F0ZXJNYXJrLCB0aW1lLCBcImZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICBvazogcmVzcG9uc2Uub2ssXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICBib2R5OiByZXNwb25zZUJvZHksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBIZWFkZXJzVHJhbnNmb3JtKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVxdWVzdERldGFpbHM6IHN1Ym1pdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZXJyb3IgaXMgZHVlIHRvIHRoZSB2MyBhcGkgbm90IGJlaW5nIHN1cHBvcnRlZCwgZmFsbCBiYWNrIHRvIHYyXG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygndjMgYXBpIG5vdCBzdXBwb3J0ZWQuJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKCd2MyBhcGkgbm90IHN1cHBvcnRlZC4gRmFsbCBiYWNrIHRvIHYyJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYW5pc3RlcklkLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IFxuICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHYzIGFwaVxuICAgICAgICAgICAgICAgICAgICBjYWxsU3luYzogZmFsc2UgfSksIGlkZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdFcnJvciB3aGlsZSBtYWtpbmcgY2FsbDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBxdWVyeShjYW5pc3RlcklkLCBmaWVsZHMsIGlkZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IGJhY2tvZmYgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfYmFja29mZlN0cmF0ZWd5LCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgY29uc3QgZWNpZCA9IGZpZWxkcy5lZmZlY3RpdmVDYW5pc3RlcklkXG4gICAgICAgICAgICA/IFByaW5jaXBhbC5mcm9tKGZpZWxkcy5lZmZlY3RpdmVDYW5pc3RlcklkKVxuICAgICAgICAgICAgOiBQcmluY2lwYWwuZnJvbShjYW5pc3RlcklkKTtcbiAgICAgICAgdGhpcy5sb2cucHJpbnQoYGVjaWQgJHtlY2lkLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIHRoaXMubG9nLnByaW50KGBjYW5pc3RlcklkICR7Y2FuaXN0ZXJJZC50b1N0cmluZygpfWApO1xuICAgICAgICBjb25zdCBtYWtlUXVlcnkgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGF3YWl0IChpZGVudGl0eSAhPT0gdW5kZWZpbmVkID8gaWRlbnRpdHkgOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfaWRlbnRpdHksIFwiZlwiKSk7XG4gICAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElkZW50aXR5SW52YWxpZEVycm9yKFwiVGhpcyBpZGVudGl0eSBoYXMgZXhwaXJlZCBkdWUgdGhpcyBhcHBsaWNhdGlvbidzIHNlY3VyaXR5IHBvbGljeS4gUGxlYXNlIHJlZnJlc2ggeW91ciBhdXRoZW50aWNhdGlvbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYW5pc3RlciA9IFByaW5jaXBhbC5mcm9tKGNhbmlzdGVySWQpO1xuICAgICAgICAgICAgY29uc3Qgc2VuZGVyID0gKGlkID09PSBudWxsIHx8IGlkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZC5nZXRQcmluY2lwYWwoKSkgfHwgUHJpbmNpcGFsLmFub255bW91cygpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X3R5cGU6IFwicXVlcnlcIiAvKiBSZWFkUmVxdWVzdFR5cGUuUXVlcnkgKi8sXG4gICAgICAgICAgICAgICAgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyLFxuICAgICAgICAgICAgICAgIG1ldGhvZF9uYW1lOiBmaWVsZHMubWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICBhcmc6IGZpZWxkcy5hcmcsXG4gICAgICAgICAgICAgICAgc2VuZGVyLFxuICAgICAgICAgICAgICAgIGluZ3Jlc3NfZXhwaXJ5OiBuZXcgRXhwaXJ5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9tYXhJbmdyZXNzRXhwaXJ5SW5NaW51dGVzLCBcImZcIikgKiBNSU5VVEVfVE9fTVNFQ1MpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IGF3YWl0IHJlcXVlc3RJZE9mKHJlcXVlc3QpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZFJlcXVlc3QgPSBhd2FpdCB0aGlzLl90cmFuc2Zvcm0oe1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2Nib3InIH0sIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfY3JlZGVudGlhbHMsIFwiZlwiKSA/IHsgQXV0aG9yaXphdGlvbjogJ0Jhc2ljICcgKyBidG9hKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9jcmVkZW50aWFscywgXCJmXCIpKSB9IDoge30pKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBcInJlYWRcIiAvKiBFbmRwb2ludC5RdWVyeSAqLyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBcHBseSB0cmFuc2Zvcm0gZm9yIGlkZW50aXR5LlxuICAgICAgICAgICAgdHJhbnNmb3JtZWRSZXF1ZXN0ID0gKGF3YWl0IChpZCA9PT0gbnVsbCB8fCBpZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWQudHJhbnNmb3JtUmVxdWVzdCh0cmFuc2Zvcm1lZFJlcXVlc3QpKSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2Jvci5lbmNvZGUodHJhbnNmb3JtZWRSZXF1ZXN0LmJvZHkpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgICAgICAgICBjYW5pc3RlcjogY2FuaXN0ZXIudG9UZXh0KCksXG4gICAgICAgICAgICAgICAgZWNpZCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgYmFja29mZixcbiAgICAgICAgICAgICAgICB0cmllczogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3REZXRhaWxzOiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfaW5zdGFuY2VzLCBcIm1cIiwgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnlRdWVyeSkuY2FsbCh0aGlzLCBhcmdzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdldFN1Ym5ldFN0YXR1cyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3ZlcmlmeVF1ZXJ5U2lnbmF0dXJlcywgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1Ym5ldFN0YXR1cyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9zdWJuZXRLZXlzLCBcImZcIikuZ2V0KGVjaWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAoc3VibmV0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Ym5ldFN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hTdWJuZXRLZXlzKGVjaWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3N1Ym5ldEtleXMsIFwiZlwiKS5nZXQoZWNpZC50b1N0cmluZygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBtYWtlIHRoZSBxdWVyeSBpPXJldHJ5VGltZXMgdGltZXNcbiAgICAgICAgLy8gTWFrZSBxdWVyeSBhbmQgZmV0Y2ggc3VibmV0IGtleXMgaW4gcGFyYWxsZWxcbiAgICAgICAgY29uc3QgW3F1ZXJ5UmVzdWx0LCBzdWJuZXRTdGF0dXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW21ha2VRdWVyeSgpLCBnZXRTdWJuZXRTdGF0dXMoKV0pO1xuICAgICAgICBjb25zdCB7IHJlcXVlc3REZXRhaWxzLCBxdWVyeSB9ID0gcXVlcnlSZXN1bHQ7XG4gICAgICAgIGNvbnN0IHF1ZXJ5V2l0aERldGFpbHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHF1ZXJ5KSwgeyByZXF1ZXN0RGV0YWlscyB9KTtcbiAgICAgICAgdGhpcy5sb2cucHJpbnQoJ1F1ZXJ5IHJlc3BvbnNlOicsIHF1ZXJ5V2l0aERldGFpbHMpO1xuICAgICAgICAvLyBTa2lwIHZlcmlmaWNhdGlvbiBpZiB0aGUgdXNlciBoYXMgZGlzYWJsZWQgaXRcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlTaWduYXR1cmVzLCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeVdpdGhEZXRhaWxzO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3ZlcmlmeVF1ZXJ5UmVzcG9uc2UsIFwiZlwiKS5jYWxsKHRoaXMsIHF1ZXJ5V2l0aERldGFpbHMsIHN1Ym5ldFN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBub2RlIHNpZ25hdHVyZXMgaGF2ZSBjaGFuZ2VkLCByZWZyZXNoIHRoZSBzdWJuZXQga2V5cyBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdRdWVyeSByZXNwb25zZSB2ZXJpZmljYXRpb24gZmFpbGVkLiBSZXRyeWluZyB3aXRoIGZyZXNoIHN1Ym5ldCBrZXlzLicpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3N1Ym5ldEtleXMsIFwiZlwiKS5kZWxldGUoY2FuaXN0ZXJJZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hTdWJuZXRLZXlzKGVjaWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkU3VibmV0U3RhdHVzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3N1Ym5ldEtleXMsIFwiZlwiKS5nZXQoY2FuaXN0ZXJJZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlZFN1Ym5ldFN0YXR1cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBmcm9tIHJlcGxpY2Egc2lnbmVkIHF1ZXJ5OiBubyBtYXRjaGluZyBub2RlIGtleSBmb3VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlSZXNwb25zZSwgXCJmXCIpLmNhbGwodGhpcywgcXVlcnlXaXRoRGV0YWlscywgdXBkYXRlZFN1Ym5ldFN0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUmVhZFN0YXRlUmVxdWVzdChmaWVsZHMsIGlkZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IGlkID0gYXdhaXQgKGlkZW50aXR5ICE9PSB1bmRlZmluZWQgPyBhd2FpdCBpZGVudGl0eSA6IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pZGVudGl0eSwgXCJmXCIpKTtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElkZW50aXR5SW52YWxpZEVycm9yKFwiVGhpcyBpZGVudGl0eSBoYXMgZXhwaXJlZCBkdWUgdGhpcyBhcHBsaWNhdGlvbidzIHNlY3VyaXR5IHBvbGljeS4gUGxlYXNlIHJlZnJlc2ggeW91ciBhdXRoZW50aWNhdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGVyID0gKGlkID09PSBudWxsIHx8IGlkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZC5nZXRQcmluY2lwYWwoKSkgfHwgUHJpbmNpcGFsLmFub255bW91cygpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFJlcXVlc3QgPSBhd2FpdCB0aGlzLl90cmFuc2Zvcm0oe1xuICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2Nib3InIH0sIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfY3JlZGVudGlhbHMsIFwiZlwiKSA/IHsgQXV0aG9yaXphdGlvbjogJ0Jhc2ljICcgKyBidG9hKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9jcmVkZW50aWFscywgXCJmXCIpKSB9IDoge30pKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmRwb2ludDogXCJyZWFkX3N0YXRlXCIgLyogRW5kcG9pbnQuUmVhZFN0YXRlICovLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogXCJyZWFkX3N0YXRlXCIgLyogUmVhZFJlcXVlc3RUeXBlLlJlYWRTdGF0ZSAqLyxcbiAgICAgICAgICAgICAgICBwYXRoczogZmllbGRzLnBhdGhzLFxuICAgICAgICAgICAgICAgIHNlbmRlcixcbiAgICAgICAgICAgICAgICBpbmdyZXNzX2V4cGlyeTogbmV3IEV4cGlyeShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfbWF4SW5ncmVzc0V4cGlyeUluTWludXRlcywgXCJmXCIpICogTUlOVVRFX1RPX01TRUNTKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBcHBseSB0cmFuc2Zvcm0gZm9yIGlkZW50aXR5LlxuICAgICAgICByZXR1cm4gaWQgPT09IG51bGwgfHwgaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkLnRyYW5zZm9ybVJlcXVlc3QodHJhbnNmb3JtZWRSZXF1ZXN0KTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFN0YXRlKGNhbmlzdGVySWQsIGZpZWxkcywgaWRlbnRpdHksIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgY2FuaXN0ZXIgPSB0eXBlb2YgY2FuaXN0ZXJJZCA9PT0gJ3N0cmluZycgPyBQcmluY2lwYWwuZnJvbVRleHQoY2FuaXN0ZXJJZCkgOiBjYW5pc3RlcklkO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFJlcXVlc3QgPSByZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiAoYXdhaXQgdGhpcy5jcmVhdGVSZWFkU3RhdGVSZXF1ZXN0KGZpZWxkcywgaWRlbnRpdHkpKTtcbiAgICAgICAgLy8gV2l0aCByZWFkX3N0YXRlLCB3ZSBzaG91bGQgYWx3YXlzIHVzZSBhIGZyZXNoIGV4cGlyeSwgZXZlbiBiZXlvbmQgdGhlIHBvaW50IHdoZXJlIHRoZSBpbml0aWFsIHJlcXVlc3Qgd291bGQgaGF2ZSBleHBpcmVkXG4gICAgICAgIGNvbnN0IGJvZHlXaXRoQWRqdXN0ZWRFeHBpcnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zZm9ybWVkUmVxdWVzdC5ib2R5KSwgeyBpbmdyZXNzX2V4cGlyeTogbmV3IEV4cGlyeShERUZBVUxUX0lOR1JFU1NfRVhQSVJZX0RFTFRBX0lOX01TRUNTKSB9KTtcbiAgICAgICAgY29uc3QgYm9keSA9IGNib3IuZW5jb2RlKGJvZHlXaXRoQWRqdXN0ZWRFeHBpcnkpO1xuICAgICAgICB0aGlzLmxvZy5wcmludChgZmV0Y2hpbmcgXCIvYXBpL3YyL2NhbmlzdGVyLyR7Y2FuaXN0ZXJ9L3JlYWRfc3RhdGVcIiB3aXRoIHJlcXVlc3Q6YCwgdHJhbnNmb3JtZWRSZXF1ZXN0KTtcbiAgICAgICAgLy8gVE9ETyAtIGh0dHBzOi8vZGZpbml0eS5hdGxhc3NpYW4ubmV0L2Jyb3dzZS9TREstMTA5MlxuICAgICAgICBjb25zdCBiYWNrb2ZmID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2JhY2tvZmZTdHJhdGVneSwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pbnN0YW5jZXMsIFwibVwiLCBfSHR0cEFnZW50X3JlcXVlc3RBbmRSZXRyeSkuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogKCkgPT4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2ZldGNoLCBcImZcIikuY2FsbCh0aGlzLCAnJyArIG5ldyBVUkwoYC9hcGkvdjIvY2FuaXN0ZXIvJHtjYW5pc3Rlci50b1N0cmluZygpfS9yZWFkX3N0YXRlYCwgdGhpcy5ob3N0KSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9mZXRjaE9wdGlvbnMsIFwiZlwiKSksIHRyYW5zZm9ybWVkUmVxdWVzdC5yZXF1ZXN0KSwgeyBib2R5IH0pKSxcbiAgICAgICAgICAgICAgICBiYWNrb2ZmLFxuICAgICAgICAgICAgICAgIHRyaWVzOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgcmV0dXJuZWQgYW4gZXJyb3I6XFxuYCArXG4gICAgICAgICAgICAgICAgICAgIGAgIENvZGU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAoJHtyZXNwb25zZS5zdGF0dXNUZXh0fSlcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYCAgQm9keTogJHthd2FpdCByZXNwb25zZS50ZXh0KCl9XFxuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkUmVzcG9uc2UgPSBjYm9yLmRlY29kZShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcbiAgICAgICAgICAgIHRoaXMubG9nLnByaW50KCdSZWFkIHN0YXRlIHJlc3BvbnNlOicsIGRlY29kZWRSZXNwb25zZSk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRUaW1lID0gYXdhaXQgdGhpcy5wYXJzZVRpbWVGcm9tUmVzcG9uc2UoZGVjb2RlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRUaW1lID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLnByaW50KCdSZWFkIHN0YXRlIHJlc3BvbnNlIHRpbWU6JywgcGFyc2VkVGltZSk7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSHR0cEFnZW50X3dhdGVyTWFyaywgcGFyc2VkVGltZSwgXCJmXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZWRSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdDYXVnaHQgZXhjZXB0aW9uIHdoaWxlIGF0dGVtcHRpbmcgdG8gcmVhZCBzdGF0ZScsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlVGltZUZyb21SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICBsZXQgdHJlZTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmNlcnRpZmljYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gY2Jvci5kZWNvZGUocmVzcG9uc2UuY2VydGlmaWNhdGUpO1xuICAgICAgICAgICAgaWYgKGRlY29kZWQgJiYgJ3RyZWUnIGluIGRlY29kZWQpIHtcbiAgICAgICAgICAgICAgICB0cmVlID0gZGVjb2RlZC50cmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGVjb2RlIHRpbWUgZnJvbSByZXNwb25zZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZUxvb2t1cCA9IGxvb2t1cF9wYXRoKFsndGltZSddLCB0cmVlKTtcbiAgICAgICAgICAgIGlmICh0aW1lTG9va3VwLnN0YXR1cyAhPT0gTG9va3VwU3RhdHVzLkZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaW1lIHdhcyBub3QgZm91bmQgaW4gdGhlIHJlc3BvbnNlIG9yIHdhcyBub3QgaW4gaXRzIGV4cGVjdGVkIGZvcm1hdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHRpbWVMb29rdXAudmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiYgIUFycmF5QnVmZmVyLmlzVmlldyh0aW1lTG9va3VwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGltZSB3YXMgbm90IGZvdW5kIGluIHRoZSByZXNwb25zZSBvciB3YXMgbm90IGluIGl0cyBleHBlY3RlZCBmb3JtYXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZGVjb2RlVGltZShidWZGcm9tQnVmTGlrZSh0aW1lTG9va3VwLnZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLmxvZy5wcmludCgnVGltZSBmcm9tIHJlc3BvbnNlOicsIGRhdGUpO1xuICAgICAgICAgICAgdGhpcy5sb2cucHJpbnQoJ1RpbWUgZnJvbSByZXNwb25zZSBpbiBtaWxsaXNlY29uZHM6JywgTnVtYmVyKGRhdGUpKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdObyBjZXJ0aWZpY2F0ZSBmb3VuZCBpbiByZXNwb25zZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgYWdlbnQgdG8gc3luYyBpdHMgdGltZSB3aXRoIHRoZSBuZXR3b3JrLiBDYW4gYmUgY2FsbGVkIGR1cmluZyBpbnRpYWxpemF0aW9uIG9yIG1pZC1saWZlY3ljbGUgaWYgdGhlIGRldmljZSdzIGNsb2NrIGhhcyBkcmlmdGVkIGF3YXkgZnJvbSB0aGUgbmV0d29yayB0aW1lLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBzZXQgdGhlIEV4cGlyeSBmb3IgYSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtQcmluY2lwYWx9IGNhbmlzdGVySWQgLSBQYXNzIGEgY2FuaXN0ZXIgSUQgaWYgeW91IG5lZWQgdG8gc3luYyB0aGUgdGltZSB3aXRoIGEgcGFydGljdWxhciByZXBsaWNhLiBVc2VzIHRoZSBtYW5hZ2VtZW50IGNhbmlzdGVyIGJ5IGRlZmF1bHRcbiAgICAgKi9cbiAgICBhc3luYyBzeW5jVGltZShjYW5pc3RlcklkKSB7XG4gICAgICAgIGNvbnN0IENhbmlzdGVyU3RhdHVzID0gYXdhaXQgaW1wb3J0KCcuLi8uLi9jYW5pc3RlclN0YXR1cycpO1xuICAgICAgICBjb25zdCBjYWxsVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWNhbmlzdGVySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5wcmludCgnU3luY2luZyB0aW1lIHdpdGggdGhlIElDLiBObyBjYW5pc3RlcklkIHByb3ZpZGVkLCBzbyBmYWxsaW5nIGJhY2sgdG8gcnlqbDMtdHlhYWEtYWFhYWEtYWFhYmEtY2FpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBDYW5pc3RlclN0YXR1cy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgd2l0aCBjYW5pc3RlcklkIG9mIHRoZSBJQ1AgTGVkZ2VyXG4gICAgICAgICAgICAgICAgY2FuaXN0ZXJJZDogY2FuaXN0ZXJJZCAhPT0gbnVsbCAmJiBjYW5pc3RlcklkICE9PSB2b2lkIDAgPyBjYW5pc3RlcklkIDogUHJpbmNpcGFsLmZyb20oJ3J5amwzLXR5YWFhLWFhYWFhLWFhYWJhLWNhaScpLFxuICAgICAgICAgICAgICAgIGFnZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgIHBhdGhzOiBbJ3RpbWUnXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVwbGljYVRpbWUgPSBzdGF0dXMuZ2V0KCd0aW1lJyk7XG4gICAgICAgICAgICBpZiAocmVwbGljYVRpbWUpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9IdHRwQWdlbnRfdGltZURpZmZNc2VjcywgTnVtYmVyKHJlcGxpY2FUaW1lKSAtIE51bWJlcihjYWxsVGltZSksIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdDYXVnaHQgZXhjZXB0aW9uIHdoaWxlIGF0dGVtcHRpbmcgdG8gc3luYyB0aW1lJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9jcmVkZW50aWFscywgXCJmXCIpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIGJ0b2EoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2NyZWRlbnRpYWxzLCBcImZcIikpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgdGhpcy5sb2cucHJpbnQoYGZldGNoaW5nIFwiL2FwaS92Mi9zdGF0dXNcImApO1xuICAgICAgICBjb25zdCBiYWNrb2ZmID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2JhY2tvZmZTdHJhdGVneSwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2luc3RhbmNlcywgXCJtXCIsIF9IdHRwQWdlbnRfcmVxdWVzdEFuZFJldHJ5KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGJhY2tvZmYsXG4gICAgICAgICAgICByZXF1ZXN0OiAoKSA9PiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfZmV0Y2gsIFwiZlwiKS5jYWxsKHRoaXMsICcnICsgbmV3IFVSTChgL2FwaS92Mi9zdGF0dXNgLCB0aGlzLmhvc3QpLCBPYmplY3QuYXNzaWduKHsgaGVhZGVycyB9LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfZmV0Y2hPcHRpb25zLCBcImZcIikpKSxcbiAgICAgICAgICAgIHRyaWVzOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNib3IuZGVjb2RlKGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFJvb3RLZXkoKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3Jvb3RLZXlGZXRjaGVkLCBcImZcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMuc3RhdHVzKCk7XG4gICAgICAgICAgICAvLyBIZXgtZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSByZXBsaWNhIHJvb3Qga2V5XG4gICAgICAgICAgICB0aGlzLnJvb3RLZXkgPSBzdGF0dXMucm9vdF9rZXk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9IdHRwQWdlbnRfcm9vdEtleUZldGNoZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb290S2V5O1xuICAgIH1cbiAgICBpbnZhbGlkYXRlSWRlbnRpdHkoKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF9pZGVudGl0eSwgbnVsbCwgXCJmXCIpO1xuICAgIH1cbiAgICByZXBsYWNlSWRlbnRpdHkoaWRlbnRpdHkpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSHR0cEFnZW50X2lkZW50aXR5LCBQcm9taXNlLnJlc29sdmUoaWRlbnRpdHkpLCBcImZcIik7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU3VibmV0S2V5cyhjYW5pc3RlcklkKSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZUNhbmlzdGVySWQgPSBQcmluY2lwYWwuZnJvbShjYW5pc3RlcklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KHtcbiAgICAgICAgICAgIGNhbmlzdGVySWQ6IGVmZmVjdGl2ZUNhbmlzdGVySWQsXG4gICAgICAgICAgICBwYXRoczogWydzdWJuZXQnXSxcbiAgICAgICAgICAgIGFnZW50OiB0aGlzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3VibmV0UmVzcG9uc2UgPSByZXNwb25zZS5nZXQoJ3N1Ym5ldCcpO1xuICAgICAgICBpZiAoc3VibmV0UmVzcG9uc2UgJiYgdHlwZW9mIHN1Ym5ldFJlc3BvbnNlID09PSAnb2JqZWN0JyAmJiAnbm9kZUtleXMnIGluIHN1Ym5ldFJlc3BvbnNlKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfc3VibmV0S2V5cywgXCJmXCIpLnNldChlZmZlY3RpdmVDYW5pc3RlcklkLnRvVGV4dCgpLCBzdWJuZXRSZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gc3VibmV0UmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHN1Ym5ldCBzdGF0dXMgaXMgbm90IHJldHVybmVkLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0ocmVxdWVzdCkge1xuICAgICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZShyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlcXVlc3QuZW5kcG9pbnQgPT09IFwiY2FsbFwiIC8qIEVuZHBvaW50LkNhbGwgKi8pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm4gb2YgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3VwZGF0ZVBpcGVsaW5lLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICBwID0gcC50aGVuKHIgPT4gZm4ocikudGhlbihyMiA9PiByMiB8fCByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9xdWVyeVBpcGVsaW5lLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICBwID0gcC50aGVuKHIgPT4gZm4ocikudGhlbihyMiA9PiByMiB8fCByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxufVxuX0h0dHBBZ2VudF9pZGVudGl0eSA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfZmV0Y2ggPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X2ZldGNoT3B0aW9ucyA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfY2FsbE9wdGlvbnMgPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X3RpbWVEaWZmTXNlY3MgPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X2NyZWRlbnRpYWxzID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF9yb290S2V5RmV0Y2hlZCA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfcmV0cnlUaW1lcyA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfYmFja29mZlN0cmF0ZWd5ID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF9tYXhJbmdyZXNzRXhwaXJ5SW5NaW51dGVzID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF93YXRlck1hcmsgPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X3F1ZXJ5UGlwZWxpbmUgPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X3VwZGF0ZVBpcGVsaW5lID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF9zdWJuZXRLZXlzID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMgPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X3ZlcmlmeVF1ZXJ5UmVzcG9uc2UgPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9IdHRwQWdlbnRfcmVxdWVzdEFuZFJldHJ5UXVlcnkgPSBhc3luYyBmdW5jdGlvbiBfSHR0cEFnZW50X3JlcXVlc3RBbmRSZXRyeVF1ZXJ5KGFyZ3MpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgZWNpZCwgdHJhbnNmb3JtZWRSZXF1ZXN0LCBib2R5LCByZXF1ZXN0SWQsIGJhY2tvZmYsIHRyaWVzIH0gPSBhcmdzO1xuICAgIGNvbnN0IGRlbGF5ID0gdHJpZXMgPT09IDAgPyAwIDogYmFja29mZi5uZXh0KCk7XG4gICAgdGhpcy5sb2cucHJpbnQoYGZldGNoaW5nIFwiL2FwaS92Mi9jYW5pc3Rlci8ke2VjaWQudG9TdHJpbmcoKX0vcXVlcnlcIiB3aXRoIHRyaWVzOmAsIHtcbiAgICAgICAgdHJpZXMsXG4gICAgICAgIGJhY2tvZmYsXG4gICAgICAgIGRlbGF5LFxuICAgIH0pO1xuICAgIC8vIElmIGRlbGF5IGlzIG51bGwsIHRoZSBiYWNrb2ZmIHN0cmF0ZWd5IGlzIGV4aGF1c3RlZCBkdWUgdG8gYSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzLCBkdXJhdGlvbiwgb3Igb3RoZXIgcmVhc29uXG4gICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEVycm9yKGBUaW1lc3RhbXAgZmFpbGVkIHRvIHBhc3MgdGhlIHdhdGVybWFyayBhZnRlciByZXRyeWluZyB0aGUgY29uZmlndXJlZCAke19fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9yZXRyeVRpbWVzLCBcImZcIil9IHRpbWVzLiBXZSBjYW5ub3QgZ3VhcmFudGVlIHRoZSBpbnRlZ3JpdHkgb2YgdGhlIHJlc3BvbnNlIHNpbmNlIGl0IGNvdWxkIGJlIGEgcmVwbGF5IGF0dGFjay5gKTtcbiAgICB9XG4gICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIC8vIE1ha2UgdGhlIHJlcXVlc3QgYW5kIHJldHJ5IGlmIGl0IHRocm93cyBhbiBlcnJvclxuICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9nLnByaW50KGBmZXRjaGluZyBcIi9hcGkvdjIvY2FuaXN0ZXIvJHtlY2lkLnRvU3RyaW5nKCl9L3F1ZXJ5XCIgd2l0aCByZXF1ZXN0OmAsIHRyYW5zZm9ybWVkUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGZldGNoUmVzcG9uc2UgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfZmV0Y2gsIFwiZlwiKS5jYWxsKHRoaXMsICcnICsgbmV3IFVSTChgL2FwaS92Mi9jYW5pc3Rlci8ke2VjaWQudG9TdHJpbmcoKX0vcXVlcnlgLCB0aGlzLmhvc3QpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2ZldGNoT3B0aW9ucywgXCJmXCIpKSwgdHJhbnNmb3JtZWRSZXF1ZXN0LnJlcXVlc3QpLCB7IGJvZHkgfSkpO1xuICAgICAgICBpZiAoZmV0Y2hSZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlSZXNwb25zZSA9IGNib3IuZGVjb2RlKGF3YWl0IGZldGNoUmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG4gICAgICAgICAgICByZXNwb25zZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcXVlcnlSZXNwb25zZSksIHsgaHR0cERldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgb2s6IGZldGNoUmVzcG9uc2Uub2ssXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogZmV0Y2hSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IGZldGNoUmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cEhlYWRlcnNUcmFuc2Zvcm0oZmV0Y2hSZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgICAgICAgICB9LCByZXF1ZXN0SWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRIVFRQUmVzcG9uc2VFcnJvcihgR2F0ZXdheSByZXR1cm5lZCBhbiBlcnJvcjpcXG5gICtcbiAgICAgICAgICAgICAgICBgICBDb2RlOiAke2ZldGNoUmVzcG9uc2Uuc3RhdHVzfSAoJHtmZXRjaFJlc3BvbnNlLnN0YXR1c1RleHR9KVxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIEJvZHk6ICR7YXdhaXQgZmV0Y2hSZXNwb25zZS50ZXh0KCl9XFxuYCwge1xuICAgICAgICAgICAgICAgIG9rOiBmZXRjaFJlc3BvbnNlLm9rLFxuICAgICAgICAgICAgICAgIHN0YXR1czogZmV0Y2hSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogZmV0Y2hSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBIZWFkZXJzVHJhbnNmb3JtKGZldGNoUmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRyaWVzIDwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3JldHJ5VGltZXMsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybihgQ2F1Z2h0IGV4Y2VwdGlvbiB3aGlsZSBhdHRlbXB0aW5nIHRvIG1ha2UgcXVlcnk6XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgJHtlcnJvcn1cXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZXRyeWluZyBxdWVyeS5gKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfaW5zdGFuY2VzLCBcIm1cIiwgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnlRdWVyeSkuY2FsbCh0aGlzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFyZ3MpLCB7IHRyaWVzOiB0cmllcyArIDEgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCB0aW1lc3RhbXAgPSAoX2IgPSAoX2EgPSByZXNwb25zZS5zaWduYXR1cmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50aW1lc3RhbXA7XG4gICAgLy8gU2tpcCB3YXRlcm1hcmsgdmVyaWZpY2F0aW9uIGlmIHRoZSB1c2VyIGhhcyBzZXQgdmVyaWZ5UXVlcnlTaWduYXR1cmVzIHRvIGZhbHNlXG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlTaWduYXR1cmVzLCBcImZcIikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBpZiAoIXRpbWVzdGFtcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWVzdGFtcCBub3QgZm91bmQgaW4gcXVlcnkgcmVzcG9uc2UuIFRoaXMgc3VnZ2VzdHMgYSBtYWxmb3JtZWQgb3IgbWFsaWNpb3VzIHJlc3BvbnNlLicpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSB0aW1lc3RhbXAgdG8gbWlsbGlzZWNvbmRzXG4gICAgY29uc3QgdGltZVN0YW1wSW5NcyA9IE51bWJlcihCaWdJbnQodGltZXN0YW1wKSAvIEJpZ0ludCgxMDAwMDAwKSk7XG4gICAgdGhpcy5sb2cucHJpbnQoJ3dhdGVybWFyayBhbmQgdGltZXN0YW1wJywge1xuICAgICAgICB3YXRlck1hcms6IHRoaXMud2F0ZXJNYXJrLFxuICAgICAgICB0aW1lc3RhbXA6IHRpbWVTdGFtcEluTXMsXG4gICAgfSk7XG4gICAgLy8gSWYgdGhlIHRpbWVzdGFtcCBpcyBsZXNzIHRoYW4gdGhlIHdhdGVybWFyaywgcmV0cnkgdGhlIHJlcXVlc3QgdXAgdG8gdGhlIHJldHJ5IGxpbWl0XG4gICAgaWYgKE51bWJlcih0aGlzLndhdGVyTWFyaykgPiB0aW1lU3RhbXBJbk1zKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEFnZW50RXJyb3IoJ1RpbWVzdGFtcCBpcyBiZWxvdyB0aGUgd2F0ZXJtYXJrLiBSZXRyeWluZyBxdWVyeS4nKTtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ1RpbWVzdGFtcCBpcyBiZWxvdycsIGVycm9yLCB7XG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICB3YXRlck1hcms6IHRoaXMud2F0ZXJNYXJrLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRyaWVzIDwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3JldHJ5VGltZXMsIFwiZlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pbnN0YW5jZXMsIFwibVwiLCBfSHR0cEFnZW50X3JlcXVlc3RBbmRSZXRyeVF1ZXJ5KS5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXJncyksIHsgdHJpZXM6IHRyaWVzICsgMSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFnZW50RXJyb3IoYFRpbWVzdGFtcCBmYWlsZWQgdG8gcGFzcyB0aGUgd2F0ZXJtYXJrIGFmdGVyIHJldHJ5aW5nIHRoZSBjb25maWd1cmVkICR7X19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3JldHJ5VGltZXMsIFwiZlwiKX0gdGltZXMuIFdlIGNhbm5vdCBndWFyYW50ZWUgdGhlIGludGVncml0eSBvZiB0aGUgcmVzcG9uc2Ugc2luY2UgaXQgY291bGQgYmUgYSByZXBsYXkgYXR0YWNrLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn0sIF9IdHRwQWdlbnRfcmVxdWVzdEFuZFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnkoYXJncykge1xuICAgIGNvbnN0IHsgcmVxdWVzdCwgYmFja29mZiwgdHJpZXMgfSA9IGFyZ3M7XG4gICAgY29uc3QgZGVsYXkgPSB0cmllcyA9PT0gMCA/IDAgOiBiYWNrb2ZmLm5leHQoKTtcbiAgICAvLyBJZiBkZWxheSBpcyBudWxsLCB0aGUgYmFja29mZiBzdHJhdGVneSBpcyBleGhhdXN0ZWQgZHVlIHRvIGEgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcywgZHVyYXRpb24sIG9yIG90aGVyIHJlYXNvblxuICAgIGlmIChkZWxheSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRFcnJvcihgVGltZXN0YW1wIGZhaWxlZCB0byBwYXNzIHRoZSB3YXRlcm1hcmsgYWZ0ZXIgcmV0cnlpbmcgdGhlIGNvbmZpZ3VyZWQgJHtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfcmV0cnlUaW1lcywgXCJmXCIpfSB0aW1lcy4gV2UgY2Fubm90IGd1YXJhbnRlZSB0aGUgaW50ZWdyaXR5IG9mIHRoZSByZXNwb25zZSBzaW5jZSBpdCBjb3VsZCBiZSBhIHJlcGxheSBhdHRhY2suYCk7XG4gICAgfVxuICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgfVxuICAgIGxldCByZXNwb25zZTtcbiAgICB0cnkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfcmV0cnlUaW1lcywgXCJmXCIpID4gdHJpZXMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oYENhdWdodCBleGNlcHRpb24gd2hpbGUgYXR0ZW1wdGluZyB0byBtYWtlIHJlcXVlc3Q6XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgJHtlcnJvcn1cXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZXRyeWluZyByZXF1ZXN0LmApO1xuICAgICAgICAgICAgLy8gRGVsYXkgdGhlIHJlcXVlc3QgYnkgdGhlIGNvbmZpZ3VyZWQgYmFja29mZiBzdHJhdGVneVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pbnN0YW5jZXMsIFwibVwiLCBfSHR0cEFnZW50X3JlcXVlc3RBbmRSZXRyeSkuY2FsbCh0aGlzLCB7IHJlcXVlc3QsIGJhY2tvZmYsIHRyaWVzOiB0cmllcyArIDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLmNsb25lKCkudGV4dCgpO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBTZXJ2ZXIgcmV0dXJuZWQgYW4gZXJyb3I6XFxuYCArXG4gICAgICAgIGAgIENvZGU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAoJHtyZXNwb25zZS5zdGF0dXNUZXh0fSlcXG5gICtcbiAgICAgICAgYCAgQm9keTogJHtyZXNwb25zZVRleHR9XFxuYDtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQgJiYgcmVzcG9uc2UudXJsLmluY2x1ZGVzKCdhcGkvdjMnKSkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRIVFRQUmVzcG9uc2VFcnJvcigndjMgYXBpIG5vdCBzdXBwb3J0ZWQuIEZhbGwgYmFjayB0byB2MicsIHtcbiAgICAgICAgICAgIG9rOiByZXNwb25zZS5vayxcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBIZWFkZXJzVHJhbnNmb3JtKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRyaWVzIDwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3JldHJ5VGltZXMsIFwiZlwiKSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2luc3RhbmNlcywgXCJtXCIsIF9IdHRwQWdlbnRfcmVxdWVzdEFuZFJldHJ5KS5jYWxsKHRoaXMsIHsgcmVxdWVzdCwgYmFja29mZiwgdHJpZXM6IHRyaWVzICsgMSB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEFnZW50SFRUUFJlc3BvbnNlRXJyb3IoZXJyb3JNZXNzYWdlLCB7XG4gICAgICAgIG9rOiByZXNwb25zZS5vayxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IGh0dHBIZWFkZXJzVHJhbnNmb3JtKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Expiry: () => (/* binding */ Expiry),\n/* harmony export */   httpHeadersTransform: () => (/* binding */ httpHeadersTransform),\n/* harmony export */   makeExpiryTransform: () => (/* binding */ makeExpiryTransform),\n/* harmony export */   makeNonceTransform: () => (/* binding */ makeNonceTransform)\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! simple-cbor */ \"./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n\n\n\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1000;\nclass Expiry {\n    constructor(deltaInMSec) {\n        // if ingress as seconds is less than 90, round to nearest second\n        if (deltaInMSec < 90 * 1000) {\n            // Raw value without subtraction of REPLICA_PERMITTED_DRIFT_MILLISECONDS\n            const raw_value = BigInt(Date.now() + deltaInMSec) * NANOSECONDS_PER_MILLISECONDS;\n            const ingress_as_seconds = raw_value / BigInt(1000000000);\n            this._value = ingress_as_seconds * BigInt(1000000000);\n            return;\n        }\n        // Use bigint because it can overflow the maximum number allowed in a double float.\n        const raw_value = BigInt(Math.floor(Date.now() + deltaInMSec - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) *\n            NANOSECONDS_PER_MILLISECONDS;\n        // round down to the nearest second (since )\n        const ingress_as_seconds = raw_value / BigInt(1000000000);\n        // round down to nearest minute\n        const ingress_as_minutes = ingress_as_seconds / BigInt(60);\n        const rounded_down_nanos = ingress_as_minutes * BigInt(60) * BigInt(1000000000);\n        this._value = rounded_down_nanos;\n    }\n    toCBOR() {\n        // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n        return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.u64(this._value.toString(16), 16);\n    }\n    toHash() {\n        return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this._value);\n    }\n}\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nfunction makeNonceTransform(nonceFn = _types__WEBPACK_IMPORTED_MODULE_2__.makeNonce) {\n    return async (request) => {\n        // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n        const headers = request.request.headers;\n        // TODO: uncomment this when the http proxy supports it.\n        // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n        request.request.headers = headers;\n        // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n        if (request.endpoint === \"call\" /* Endpoint.Call */) {\n            request.body.nonce = nonceFn();\n        }\n    };\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nfunction makeExpiryTransform(delayInMilliseconds) {\n    return async (request) => {\n        request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n    };\n}\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n *\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nfunction httpHeadersTransform(headers) {\n    const headerFields = [];\n    headers.forEach((value, key) => {\n        headerFields.push([key, value]);\n    });\n    return headerFields;\n}\n//# sourceMappingURL=transforms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvdHJhbnNmb3Jtcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE0QztBQUNSO0FBQ0M7QUFDckM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBVTtBQUN6QjtBQUNBO0FBQ0EsZUFBZSwwREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQyw2Q0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC90cmFuc2Zvcm1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxlYkVuY29kZSB9IGZyb20gJ0BkZmluaXR5L2NhbmRpZCc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJ3NpbXBsZS1jYm9yJztcbmltcG9ydCB7IG1ha2VOb25jZSwgfSBmcm9tICcuL3R5cGVzJztcbmNvbnN0IE5BTk9TRUNPTkRTX1BFUl9NSUxMSVNFQ09ORFMgPSBCaWdJbnQoMTAwMDAwMCk7XG5jb25zdCBSRVBMSUNBX1BFUk1JVFRFRF9EUklGVF9NSUxMSVNFQ09ORFMgPSA2MCAqIDEwMDA7XG5leHBvcnQgY2xhc3MgRXhwaXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihkZWx0YUluTVNlYykge1xuICAgICAgICAvLyBpZiBpbmdyZXNzIGFzIHNlY29uZHMgaXMgbGVzcyB0aGFuIDkwLCByb3VuZCB0byBuZWFyZXN0IHNlY29uZFxuICAgICAgICBpZiAoZGVsdGFJbk1TZWMgPCA5MCAqIDEwMDApIHtcbiAgICAgICAgICAgIC8vIFJhdyB2YWx1ZSB3aXRob3V0IHN1YnRyYWN0aW9uIG9mIFJFUExJQ0FfUEVSTUlUVEVEX0RSSUZUX01JTExJU0VDT05EU1xuICAgICAgICAgICAgY29uc3QgcmF3X3ZhbHVlID0gQmlnSW50KERhdGUubm93KCkgKyBkZWx0YUluTVNlYykgKiBOQU5PU0VDT05EU19QRVJfTUlMTElTRUNPTkRTO1xuICAgICAgICAgICAgY29uc3QgaW5ncmVzc19hc19zZWNvbmRzID0gcmF3X3ZhbHVlIC8gQmlnSW50KDEwMDAwMDAwMDApO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBpbmdyZXNzX2FzX3NlY29uZHMgKiBCaWdJbnQoMTAwMDAwMDAwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGJpZ2ludCBiZWNhdXNlIGl0IGNhbiBvdmVyZmxvdyB0aGUgbWF4aW11bSBudW1iZXIgYWxsb3dlZCBpbiBhIGRvdWJsZSBmbG9hdC5cbiAgICAgICAgY29uc3QgcmF3X3ZhbHVlID0gQmlnSW50KE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIGRlbHRhSW5NU2VjIC0gUkVQTElDQV9QRVJNSVRURURfRFJJRlRfTUlMTElTRUNPTkRTKSkgKlxuICAgICAgICAgICAgTkFOT1NFQ09ORFNfUEVSX01JTExJU0VDT05EUztcbiAgICAgICAgLy8gcm91bmQgZG93biB0byB0aGUgbmVhcmVzdCBzZWNvbmQgKHNpbmNlIClcbiAgICAgICAgY29uc3QgaW5ncmVzc19hc19zZWNvbmRzID0gcmF3X3ZhbHVlIC8gQmlnSW50KDEwMDAwMDAwMDApO1xuICAgICAgICAvLyByb3VuZCBkb3duIHRvIG5lYXJlc3QgbWludXRlXG4gICAgICAgIGNvbnN0IGluZ3Jlc3NfYXNfbWludXRlcyA9IGluZ3Jlc3NfYXNfc2Vjb25kcyAvIEJpZ0ludCg2MCk7XG4gICAgICAgIGNvbnN0IHJvdW5kZWRfZG93bl9uYW5vcyA9IGluZ3Jlc3NfYXNfbWludXRlcyAqIEJpZ0ludCg2MCkgKiBCaWdJbnQoMTAwMDAwMDAwMCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gcm91bmRlZF9kb3duX25hbm9zO1xuICAgIH1cbiAgICB0b0NCT1IoKSB7XG4gICAgICAgIC8vIFRPRE86IGNoYW5nZSB0aGlzIHRvIHRha2UgdGhlIG1pbmltdW0gYW1vdW50IG9mIHNwYWNlIChpdCBhbHdheXMgdGFrZXMgOCBieXRlcyBub3cpLlxuICAgICAgICByZXR1cm4gY2Jvci52YWx1ZS51NjQodGhpcy5fdmFsdWUudG9TdHJpbmcoMTYpLCAxNik7XG4gICAgfVxuICAgIHRvSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIGxlYkVuY29kZSh0aGlzLl92YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBOb25jZSB0cmFuc2Zvcm0sIHdoaWNoIHRha2VzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgQnVmZmVyLCBhbmQgYWRkcyBpdFxuICogYXMgdGhlIG5vbmNlIHRvIGV2ZXJ5IGNhbGwgcmVxdWVzdHMuXG4gKiBAcGFyYW0gbm9uY2VGbiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGJ1ZmZlci4gQnkgZGVmYXVsdCB1c2VzIGEgc2VtaS1yYW5kb20gbWV0aG9kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZU5vbmNlVHJhbnNmb3JtKG5vbmNlRm4gPSBtYWtlTm9uY2UpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgLy8gTm9uY2UgbmVlZHMgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgaGVhZGVyIGZvciBhbGwgcmVxdWVzdHMsIHRvIGVuYWJsZSBsb2dzIHRvIGJlIGNvcnJlbGF0ZWQgd2l0aCByZXF1ZXN0cy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHJlcXVlc3QucmVxdWVzdC5oZWFkZXJzO1xuICAgICAgICAvLyBUT0RPOiB1bmNvbW1lbnQgdGhpcyB3aGVuIHRoZSBodHRwIHByb3h5IHN1cHBvcnRzIGl0LlxuICAgICAgICAvLyBoZWFkZXJzLnNldCgnWC1JQy1SZXF1ZXN0LUlEJywgdG9IZXgobmV3IFVpbnQ4QXJyYXkobm9uY2UpKSk7XG4gICAgICAgIHJlcXVlc3QucmVxdWVzdC5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgLy8gTm9uY2Ugb25seSBuZWVkcyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBib2R5IGZvciBhc3luYyBjYWxscywgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcy5cbiAgICAgICAgaWYgKHJlcXVlc3QuZW5kcG9pbnQgPT09IFwiY2FsbFwiIC8qIEVuZHBvaW50LkNhbGwgKi8pIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYm9keS5ub25jZSA9IG5vbmNlRm4oKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIHRyYW5zZm9ybSB0aGF0IGFkZHMgYSBkZWxheSAoYnkgZGVmYXVsdCA1IG1pbnV0ZXMpIHRvIHRoZSBleHBpcnkuXG4gKlxuICogQHBhcmFtIGRlbGF5SW5NaWxsaXNlY29uZHMgVGhlIGRlbGF5IHRvIGFkZCB0byB0aGUgY2FsbCB0aW1lLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXhwaXJ5VHJhbnNmb3JtKGRlbGF5SW5NaWxsaXNlY29uZHMpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgcmVxdWVzdC5ib2R5LmluZ3Jlc3NfZXhwaXJ5ID0gbmV3IEV4cGlyeShkZWxheUluTWlsbGlzZWNvbmRzKTtcbiAgICB9O1xufVxuLyoqXG4gKiBNYXBzIHRoZSBkZWZhdWx0IGZldGNoIGhlYWRlcnMgZmllbGQgdG8gdGhlIHNlcmlhbGl6YWJsZSBIdHRwSGVhZGVyRmllbGQuXG4gKlxuICogQHBhcmFtIGhlYWRlcnMgRmV0Y2ggZGVmaW5pdGlvbiBvZiB0aGUgaGVhZGVycyB0eXBlXG4gKiBAcmV0dXJucyBhcnJheSBvZiBoZWFkZXIgZmllbGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodHRwSGVhZGVyc1RyYW5zZm9ybShoZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyRmllbGRzID0gW107XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlckZpZWxkcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlckZpZWxkcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/types.js":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/types.js ***!
  \**********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SubmitRequestType: () => (/* binding */ SubmitRequestType),\n/* harmony export */   makeNonce: () => (/* binding */ makeNonce)\n/* harmony export */ });\n/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/random */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/random.js\");\n\n// The types of values allowed in the `request_type` field for submit requests.\nvar SubmitRequestType;\n(function (SubmitRequestType) {\n    SubmitRequestType[\"Call\"] = \"call\";\n})(SubmitRequestType || (SubmitRequestType = {}));\n/**\n * Create a random Nonce, based on random values\n */\nfunction makeNonce() {\n    // Encode 128 bits.\n    const buffer = new ArrayBuffer(16);\n    const view = new DataView(buffer);\n    const rand1 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand2 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand3 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand4 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    view.setUint32(0, rand1);\n    view.setUint32(4, rand2);\n    view.setUint32(8, rand3);\n    view.setUint32(12, rand4);\n    return buffer;\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtEO0FBQ2xEO0FBQ087QUFDUDtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQVk7QUFDOUIsa0JBQWtCLDJEQUFZO0FBQzlCLGtCQUFrQiwyREFBWTtBQUM5QixrQkFBa0IsMkRBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmFuZG9tTnVtYmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvcmFuZG9tJztcbi8vIFRoZSB0eXBlcyBvZiB2YWx1ZXMgYWxsb3dlZCBpbiB0aGUgYHJlcXVlc3RfdHlwZWAgZmllbGQgZm9yIHN1Ym1pdCByZXF1ZXN0cy5cbmV4cG9ydCB2YXIgU3VibWl0UmVxdWVzdFR5cGU7XG4oZnVuY3Rpb24gKFN1Ym1pdFJlcXVlc3RUeXBlKSB7XG4gICAgU3VibWl0UmVxdWVzdFR5cGVbXCJDYWxsXCJdID0gXCJjYWxsXCI7XG59KShTdWJtaXRSZXF1ZXN0VHlwZSB8fCAoU3VibWl0UmVxdWVzdFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBDcmVhdGUgYSByYW5kb20gTm9uY2UsIGJhc2VkIG9uIHJhbmRvbSB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VOb25jZSgpIHtcbiAgICAvLyBFbmNvZGUgMTI4IGJpdHMuXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDE2KTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgY29uc3QgcmFuZDEgPSByYW5kb21OdW1iZXIoKTtcbiAgICBjb25zdCByYW5kMiA9IHJhbmRvbU51bWJlcigpO1xuICAgIGNvbnN0IHJhbmQzID0gcmFuZG9tTnVtYmVyKCk7XG4gICAgY29uc3QgcmFuZDQgPSByYW5kb21OdW1iZXIoKTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCByYW5kMSk7XG4gICAgdmlldy5zZXRVaW50MzIoNCwgcmFuZDIpO1xuICAgIHZpZXcuc2V0VWludDMyKDgsIHJhbmQzKTtcbiAgICB2aWV3LnNldFVpbnQzMigxMiwgcmFuZDQpO1xuICAgIHJldHVybiBidWZmZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/types.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/index.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/index.js ***!
  \*****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultAgent: () => (/* binding */ getDefaultAgent)\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/api.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _api__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"getDefaultAgent\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _api__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./http */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/index.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _http__WEBPACK_IMPORTED_MODULE_1__) if([\"default\",\"getDefaultAgent\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _http__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _http_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./http/errors */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/errors.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _http_errors__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"getDefaultAgent\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _http_errors__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _proxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proxy */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/proxy.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _proxy__WEBPACK_IMPORTED_MODULE_3__) if([\"default\",\"getDefaultAgent\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _proxy__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\nfunction getDefaultAgent() {\n    const agent = typeof window === 'undefined'\n        ? typeof __webpack_require__.g === 'undefined'\n            ? typeof self === 'undefined'\n                ? undefined\n                : self.ic.agent\n            : __webpack_require__.g.ic.agent\n        : window.ic.agent;\n    if (!agent) {\n        throw new Error('No Agent could be found.');\n    }\n    return agent;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNCO0FBQ0M7QUFDTztBQUNOO0FBQ2pCO0FBQ1A7QUFDQSxpQkFBaUIscUJBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9hcGknO1xuZXhwb3J0ICogZnJvbSAnLi9odHRwJztcbmV4cG9ydCAqIGZyb20gJy4vaHR0cC9lcnJvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9wcm94eSc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEFnZW50KCkge1xuICAgIGNvbnN0IGFnZW50ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogc2VsZi5pYy5hZ2VudFxuICAgICAgICAgICAgOiBnbG9iYWwuaWMuYWdlbnRcbiAgICAgICAgOiB3aW5kb3cuaWMuYWdlbnQ7XG4gICAgaWYgKCFhZ2VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEFnZW50IGNvdWxkIGJlIGZvdW5kLicpO1xuICAgIH1cbiAgICByZXR1cm4gYWdlbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/proxy.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/proxy.js ***!
  \*****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProxyAgent: () => (/* binding */ ProxyAgent),\n/* harmony export */   ProxyMessageKind: () => (/* binding */ ProxyMessageKind),\n/* harmony export */   ProxyStubAgent: () => (/* binding */ ProxyStubAgent)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\");\n\nvar ProxyMessageKind;\n(function (ProxyMessageKind) {\n    ProxyMessageKind[\"Error\"] = \"err\";\n    ProxyMessageKind[\"GetPrincipal\"] = \"gp\";\n    ProxyMessageKind[\"GetPrincipalResponse\"] = \"gpr\";\n    ProxyMessageKind[\"Query\"] = \"q\";\n    ProxyMessageKind[\"QueryResponse\"] = \"qr\";\n    ProxyMessageKind[\"Call\"] = \"c\";\n    ProxyMessageKind[\"CallResponse\"] = \"cr\";\n    ProxyMessageKind[\"ReadState\"] = \"rs\";\n    ProxyMessageKind[\"ReadStateResponse\"] = \"rsr\";\n    ProxyMessageKind[\"Status\"] = \"s\";\n    ProxyMessageKind[\"StatusResponse\"] = \"sr\";\n})(ProxyMessageKind || (ProxyMessageKind = {}));\n// A Stub Agent that forwards calls to another Agent implementation.\nclass ProxyStubAgent {\n    constructor(_frontend, _agent) {\n        this._frontend = _frontend;\n        this._agent = _agent;\n    }\n    onmessage(msg) {\n        switch (msg.type) {\n            case ProxyMessageKind.GetPrincipal:\n                this._agent.getPrincipal().then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.GetPrincipalResponse,\n                        response: response.toText(),\n                    });\n                });\n                break;\n            case ProxyMessageKind.Query:\n                this._agent.query(...msg.args).then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.QueryResponse,\n                        response,\n                    });\n                });\n                break;\n            case ProxyMessageKind.Call:\n                this._agent.call(...msg.args).then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.CallResponse,\n                        response,\n                    });\n                });\n                break;\n            case ProxyMessageKind.ReadState:\n                this._agent.readState(...msg.args).then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.ReadStateResponse,\n                        response,\n                    });\n                });\n                break;\n            case ProxyMessageKind.Status:\n                this._agent.status().then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.StatusResponse,\n                        response,\n                    });\n                });\n                break;\n            default:\n                throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);\n        }\n    }\n}\n// An Agent that forwards calls to a backend. The calls are serialized\nclass ProxyAgent {\n    constructor(_backend) {\n        this._backend = _backend;\n        this._nextId = 0;\n        this._pendingCalls = new Map();\n        this.rootKey = null;\n    }\n    onmessage(msg) {\n        const id = msg.id;\n        const maybePromise = this._pendingCalls.get(id);\n        if (!maybePromise) {\n            throw new Error('A proxy get the same message twice...');\n        }\n        this._pendingCalls.delete(id);\n        const [resolve, reject] = maybePromise;\n        switch (msg.type) {\n            case ProxyMessageKind.Error:\n                return reject(msg.error);\n            case ProxyMessageKind.GetPrincipalResponse:\n            case ProxyMessageKind.CallResponse:\n            case ProxyMessageKind.QueryResponse:\n            case ProxyMessageKind.ReadStateResponse:\n            case ProxyMessageKind.StatusResponse:\n                return resolve(msg.response);\n            default:\n                throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);\n        }\n    }\n    async getPrincipal() {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.GetPrincipal,\n        }).then(principal => {\n            if (typeof principal !== 'string') {\n                throw new Error('Invalid principal received.');\n            }\n            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(principal);\n        });\n    }\n    readState(canisterId, fields) {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.ReadState,\n            args: [canisterId.toString(), fields],\n        });\n    }\n    call(canisterId, fields) {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.Call,\n            args: [canisterId.toString(), fields],\n        });\n    }\n    status() {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.Status,\n        });\n    }\n    query(canisterId, fields) {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.Query,\n            args: [canisterId.toString(), fields],\n        });\n    }\n    async _sendAndWait(msg) {\n        return new Promise((resolve, reject) => {\n            this._pendingCalls.set(msg.id, [resolve, reject]);\n            this._backend(msg);\n        });\n    }\n    async fetchRootKey() {\n        // Hex-encoded version of the replica root key\n        const rootKey = (await this.status()).root_key;\n        this.rootKey = rootKey;\n        return rootKey;\n    }\n}\n//# sourceMappingURL=proxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L3Byb3h5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0M7QUFDeEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxvQkFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBUztBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvcHJveHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmV4cG9ydCB2YXIgUHJveHlNZXNzYWdlS2luZDtcbihmdW5jdGlvbiAoUHJveHlNZXNzYWdlS2luZCkge1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJFcnJvclwiXSA9IFwiZXJyXCI7XG4gICAgUHJveHlNZXNzYWdlS2luZFtcIkdldFByaW5jaXBhbFwiXSA9IFwiZ3BcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiR2V0UHJpbmNpcGFsUmVzcG9uc2VcIl0gPSBcImdwclwiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJRdWVyeVwiXSA9IFwicVwiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJRdWVyeVJlc3BvbnNlXCJdID0gXCJxclwiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJDYWxsXCJdID0gXCJjXCI7XG4gICAgUHJveHlNZXNzYWdlS2luZFtcIkNhbGxSZXNwb25zZVwiXSA9IFwiY3JcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiUmVhZFN0YXRlXCJdID0gXCJyc1wiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJSZWFkU3RhdGVSZXNwb25zZVwiXSA9IFwicnNyXCI7XG4gICAgUHJveHlNZXNzYWdlS2luZFtcIlN0YXR1c1wiXSA9IFwic1wiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJTdGF0dXNSZXNwb25zZVwiXSA9IFwic3JcIjtcbn0pKFByb3h5TWVzc2FnZUtpbmQgfHwgKFByb3h5TWVzc2FnZUtpbmQgPSB7fSkpO1xuLy8gQSBTdHViIEFnZW50IHRoYXQgZm9yd2FyZHMgY2FsbHMgdG8gYW5vdGhlciBBZ2VudCBpbXBsZW1lbnRhdGlvbi5cbmV4cG9ydCBjbGFzcyBQcm94eVN0dWJBZ2VudCB7XG4gICAgY29uc3RydWN0b3IoX2Zyb250ZW5kLCBfYWdlbnQpIHtcbiAgICAgICAgdGhpcy5fZnJvbnRlbmQgPSBfZnJvbnRlbmQ7XG4gICAgICAgIHRoaXMuX2FnZW50ID0gX2FnZW50O1xuICAgIH1cbiAgICBvbm1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5HZXRQcmluY2lwYWw6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWdlbnQuZ2V0UHJpbmNpcGFsKCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zyb250ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtc2cuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLkdldFByaW5jaXBhbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLnRvVGV4dCgpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5RdWVyeTpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZ2VudC5xdWVyeSguLi5tc2cuYXJncykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zyb250ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtc2cuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLlF1ZXJ5UmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuQ2FsbDpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZ2VudC5jYWxsKC4uLm1zZy5hcmdzKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZnJvbnRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1zZy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFByb3h5TWVzc2FnZUtpbmQuQ2FsbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcm94eU1lc3NhZ2VLaW5kLlJlYWRTdGF0ZTpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZ2VudC5yZWFkU3RhdGUoLi4ubXNnLmFyZ3MpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcm9udGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbXNnLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5SZWFkU3RhdGVSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5TdGF0dXM6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWdlbnQuc3RhdHVzKCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zyb250ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtc2cuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLlN0YXR1c1Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSByZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShtc2cpfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQW4gQWdlbnQgdGhhdCBmb3J3YXJkcyBjYWxscyB0byBhIGJhY2tlbmQuIFRoZSBjYWxscyBhcmUgc2VyaWFsaXplZFxuZXhwb3J0IGNsYXNzIFByb3h5QWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKF9iYWNrZW5kKSB7XG4gICAgICAgIHRoaXMuX2JhY2tlbmQgPSBfYmFja2VuZDtcbiAgICAgICAgdGhpcy5fbmV4dElkID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NhbGxzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJvb3RLZXkgPSBudWxsO1xuICAgIH1cbiAgICBvbm1lc3NhZ2UobXNnKSB7XG4gICAgICAgIGNvbnN0IGlkID0gbXNnLmlkO1xuICAgICAgICBjb25zdCBtYXliZVByb21pc2UgPSB0aGlzLl9wZW5kaW5nQ2FsbHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFtYXliZVByb21pc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBwcm94eSBnZXQgdGhlIHNhbWUgbWVzc2FnZSB0d2ljZS4uLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDYWxscy5kZWxldGUoaWQpO1xuICAgICAgICBjb25zdCBbcmVzb2x2ZSwgcmVqZWN0XSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBQcm94eU1lc3NhZ2VLaW5kLkVycm9yOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobXNnLmVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5HZXRQcmluY2lwYWxSZXNwb25zZTpcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5DYWxsUmVzcG9uc2U6XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuUXVlcnlSZXNwb25zZTpcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5SZWFkU3RhdGVSZXNwb25zZTpcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5TdGF0dXNSZXNwb25zZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShtc2cucmVzcG9uc2UpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSBiZWluZyBzZW50IHRvIFByb3h5QWdlbnQ6ICR7SlNPTi5zdHJpbmdpZnkobXNnKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRQcmluY2lwYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kQW5kV2FpdCh7XG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dElkKyssXG4gICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLkdldFByaW5jaXBhbCxcbiAgICAgICAgfSkudGhlbihwcmluY2lwYWwgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmluY2lwYWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaW5jaXBhbCByZWNlaXZlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcmluY2lwYWwuZnJvbVRleHQocHJpbmNpcGFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlYWRTdGF0ZShjYW5pc3RlcklkLCBmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRBbmRXYWl0KHtcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0SWQrKyxcbiAgICAgICAgICAgIHR5cGU6IFByb3h5TWVzc2FnZUtpbmQuUmVhZFN0YXRlLFxuICAgICAgICAgICAgYXJnczogW2NhbmlzdGVySWQudG9TdHJpbmcoKSwgZmllbGRzXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhbGwoY2FuaXN0ZXJJZCwgZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kQW5kV2FpdCh7XG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dElkKyssXG4gICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLkNhbGwsXG4gICAgICAgICAgICBhcmdzOiBbY2FuaXN0ZXJJZC50b1N0cmluZygpLCBmaWVsZHNdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEFuZFdhaXQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxuICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5TdGF0dXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBxdWVyeShjYW5pc3RlcklkLCBmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRBbmRXYWl0KHtcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0SWQrKyxcbiAgICAgICAgICAgIHR5cGU6IFByb3h5TWVzc2FnZUtpbmQuUXVlcnksXG4gICAgICAgICAgICBhcmdzOiBbY2FuaXN0ZXJJZC50b1N0cmluZygpLCBmaWVsZHNdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmRBbmRXYWl0KG1zZykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NhbGxzLnNldChtc2cuaWQsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tlbmQobXNnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUm9vdEtleSgpIHtcbiAgICAgICAgLy8gSGV4LWVuY29kZWQgdmVyc2lvbiBvZiB0aGUgcmVwbGljYSByb290IGtleVxuICAgICAgICBjb25zdCByb290S2V5ID0gKGF3YWl0IHRoaXMuc3RhdHVzKCkpLnJvb3Rfa2V5O1xuICAgICAgICB0aGlzLnJvb3RLZXkgPSByb290S2V5O1xuICAgICAgICByZXR1cm4gcm9vdEtleTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm94eS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/proxy.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/auth.js":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/auth.js ***!
  \**********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousIdentity: () => (/* binding */ AnonymousIdentity),\n/* harmony export */   SignIdentity: () => (/* binding */ SignIdentity),\n/* harmony export */   createIdentityDescriptor: () => (/* binding */ createIdentityDescriptor)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./request_id */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\nconst domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n/**\n * An Identity that can sign blobs.\n */\nclass SignIdentity {\n    /**\n     * Get the principal represented by this identity. Normally should be a\n     * `Principal.selfAuthenticating()`.\n     */\n    getPrincipal() {\n        if (!this._principal) {\n            this._principal = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n        }\n        return this._principal;\n    }\n    /**\n     * Transform a request into a signed version of the request. This is done last\n     * after the transforms on the body of a request. The returned object can be\n     * anything, but must be serializable to CBOR.\n     * @param request - internet computer request to transform\n     */\n    async transformRequest(request) {\n        const { body } = request, fields = __rest(request, [\"body\"]);\n        const requestId = await (0,_request_id__WEBPACK_IMPORTED_MODULE_1__.requestIdOf)(body);\n        return Object.assign(Object.assign({}, fields), { body: {\n                content: body,\n                sender_pubkey: this.getPublicKey().toDer(),\n                sender_sig: await this.sign((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(domainSeparator, requestId)),\n            } });\n    }\n}\nclass AnonymousIdentity {\n    getPrincipal() {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n    }\n    async transformRequest(request) {\n        return Object.assign(Object.assign({}, request), { body: { content: request.body } });\n    }\n}\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nfunction createIdentityDescriptor(identity) {\n    const identityIndicator = 'getPublicKey' in identity\n        ? { type: 'PublicKeyIdentity', publicKey: (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(identity.getPublicKey().toDer()) }\n        : { type: 'AnonymousIdentity' };\n    return identityIndicator;\n}\n//# sourceMappingURL=auth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2F1dGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsY0FBYyxTQUFJLElBQUksU0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFDSjtBQUNJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQ0FBZ0Msd0RBQVc7QUFDM0MsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLDRDQUE0QyxxREFBTTtBQUNsRCxlQUFlO0FBQ2Y7QUFDQTtBQUNPO0FBQ1A7QUFDQSxlQUFlLHlEQUFTO0FBQ3hCO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxRQUFRLHlCQUF5QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSxzQ0FBc0Msb0RBQUs7QUFDdkQsWUFBWTtBQUNaO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYXV0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5pbXBvcnQgeyBQcmluY2lwYWwgfSBmcm9tICdAZGZpbml0eS9wcmluY2lwYWwnO1xuaW1wb3J0IHsgcmVxdWVzdElkT2YgfSBmcm9tICcuL3JlcXVlc3RfaWQnO1xuaW1wb3J0IHsgY29uY2F0LCB0b0hleCB9IGZyb20gJy4vdXRpbHMvYnVmZmVyJztcbmNvbnN0IGRvbWFpblNlcGFyYXRvciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnXFx4MEFpYy1yZXF1ZXN0Jyk7XG4vKipcbiAqIEFuIElkZW50aXR5IHRoYXQgY2FuIHNpZ24gYmxvYnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduSWRlbnRpdHkge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJpbmNpcGFsIHJlcHJlc2VudGVkIGJ5IHRoaXMgaWRlbnRpdHkuIE5vcm1hbGx5IHNob3VsZCBiZSBhXG4gICAgICogYFByaW5jaXBhbC5zZWxmQXV0aGVudGljYXRpbmcoKWAuXG4gICAgICovXG4gICAgZ2V0UHJpbmNpcGFsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByaW5jaXBhbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJpbmNpcGFsID0gUHJpbmNpcGFsLnNlbGZBdXRoZW50aWNhdGluZyhuZXcgVWludDhBcnJheSh0aGlzLmdldFB1YmxpY0tleSgpLnRvRGVyKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpbmNpcGFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYSByZXF1ZXN0IGludG8gYSBzaWduZWQgdmVyc2lvbiBvZiB0aGUgcmVxdWVzdC4gVGhpcyBpcyBkb25lIGxhc3RcbiAgICAgKiBhZnRlciB0aGUgdHJhbnNmb3JtcyBvbiB0aGUgYm9keSBvZiBhIHJlcXVlc3QuIFRoZSByZXR1cm5lZCBvYmplY3QgY2FuIGJlXG4gICAgICogYW55dGhpbmcsIGJ1dCBtdXN0IGJlIHNlcmlhbGl6YWJsZSB0byBDQk9SLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gaW50ZXJuZXQgY29tcHV0ZXIgcmVxdWVzdCB0byB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1SZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgeyBib2R5IH0gPSByZXF1ZXN0LCBmaWVsZHMgPSBfX3Jlc3QocmVxdWVzdCwgW1wiYm9keVwiXSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IGF3YWl0IHJlcXVlc3RJZE9mKGJvZHkpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZHMpLCB7IGJvZHk6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBib2R5LFxuICAgICAgICAgICAgICAgIHNlbmRlcl9wdWJrZXk6IHRoaXMuZ2V0UHVibGljS2V5KCkudG9EZXIoKSxcbiAgICAgICAgICAgICAgICBzZW5kZXJfc2lnOiBhd2FpdCB0aGlzLnNpZ24oY29uY2F0KGRvbWFpblNlcGFyYXRvciwgcmVxdWVzdElkKSksXG4gICAgICAgICAgICB9IH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNJZGVudGl0eSB7XG4gICAgZ2V0UHJpbmNpcGFsKCkge1xuICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmFub255bW91cygpO1xuICAgIH1cbiAgICBhc3luYyB0cmFuc2Zvcm1SZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgYm9keTogeyBjb250ZW50OiByZXF1ZXN0LmJvZHkgfSB9KTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBJZGVudGl0eURlc2NyaXB0b3IgZnJvbSBhIEBkZmluaXR5L2lkZW50aXR5IElkZW50aXR5XG4gKiBAcGFyYW0gaWRlbnRpdHkgLSBpZGVudGl0eSBkZXNjcmliZSBpbiByZXR1cm5lZCBkZXNjcmlwdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJZGVudGl0eURlc2NyaXB0b3IoaWRlbnRpdHkpIHtcbiAgICBjb25zdCBpZGVudGl0eUluZGljYXRvciA9ICdnZXRQdWJsaWNLZXknIGluIGlkZW50aXR5XG4gICAgICAgID8geyB0eXBlOiAnUHVibGljS2V5SWRlbnRpdHknLCBwdWJsaWNLZXk6IHRvSGV4KGlkZW50aXR5LmdldFB1YmxpY0tleSgpLnRvRGVyKCkpIH1cbiAgICAgICAgOiB7IHR5cGU6ICdBbm9ueW1vdXNJZGVudGl0eScgfTtcbiAgICByZXR1cm4gaWRlbnRpdHlJbmRpY2F0b3I7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/auth.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js":
/*!**************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js ***!
  \**************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomPath: () => (/* binding */ CustomPath),\n/* harmony export */   encodePath: () => (/* binding */ encodePath),\n/* harmony export */   fetchNodeKeys: () => (/* binding */ fetchNodeKeys),\n/* harmony export */   request: () => (/* binding */ request)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../certificate */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cbor */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _utils_leb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/leb */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n/** @module CanisterStatus */\n\n\n\n\n\n\n/**\n * Interface to define a custom path. Nested paths will be represented as individual buffers, and can be created from text using TextEncoder.\n * @param {string} key the key to use to access the returned value in the canisterStatus map\n * @param {ArrayBuffer[]} path the path to the desired value, represented as an array of buffers\n * @param {string} decodeStrategy the strategy to use to decode the returned value\n */\nclass CustomPath {\n    constructor(key, path, decodeStrategy) {\n        this.key = key;\n        this.path = path;\n        this.decodeStrategy = decodeStrategy;\n    }\n}\n/**\n * Request information in the request_status state tree for a given canister.\n * Can be used to request information about the canister's controllers, time, module hash, candid interface, and more.\n * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}\n * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}\n * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private\n * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}\n * @returns {Status} object populated with data from the requested paths\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nconst request = async (options) => {\n    const { agent, paths } = options;\n    const canisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(options.canisterId);\n    const uniquePaths = [...new Set(paths)];\n    // Map path options to their correct formats\n    const encodedPaths = uniquePaths.map(path => {\n        return encodePath(path, canisterId);\n    });\n    const status = new Map();\n    const promises = uniquePaths.map((path, index) => {\n        return (async () => {\n            var _a;\n            try {\n                const response = await agent.readState(canisterId, {\n                    paths: [encodedPaths[index]],\n                });\n                const cert = await _certificate__WEBPACK_IMPORTED_MODULE_2__.Certificate.create({\n                    certificate: response.certificate,\n                    rootKey: agent.rootKey,\n                    canisterId: canisterId,\n                });\n                const lookup = (cert, path) => {\n                    if (path === 'subnet') {\n                        const data = fetchNodeKeys(response.certificate, canisterId, agent.rootKey);\n                        return {\n                            path: path,\n                            data,\n                        };\n                    }\n                    else {\n                        return {\n                            path: path,\n                            data: (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookupResultToBuffer)(cert.lookup(encodePath(path, canisterId))),\n                        };\n                    }\n                };\n                // must pass in the rootKey if we have no delegation\n                const { path, data } = lookup(cert, uniquePaths[index]);\n                if (!data) {\n                    // Typically, the cert lookup will throw\n                    console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n                    if (typeof path === 'string') {\n                        status.set(path, null);\n                    }\n                    else {\n                        status.set(path.key, null);\n                    }\n                }\n                else {\n                    switch (path) {\n                        case 'time': {\n                            status.set(path, (0,_utils_leb__WEBPACK_IMPORTED_MODULE_5__.decodeTime)(data));\n                            break;\n                        }\n                        case 'controllers': {\n                            status.set(path, decodeControllers(data));\n                            break;\n                        }\n                        case 'module_hash': {\n                            status.set(path, decodeHex(data));\n                            break;\n                        }\n                        case 'subnet': {\n                            status.set(path, data);\n                            break;\n                        }\n                        case 'candid': {\n                            status.set(path, new TextDecoder().decode(data));\n                            break;\n                        }\n                        default: {\n                            // Check for CustomPath signature\n                            if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                                switch (path.decodeStrategy) {\n                                    case 'raw':\n                                        status.set(path.key, data);\n                                        break;\n                                    case 'leb128': {\n                                        status.set(path.key, (0,_utils_leb__WEBPACK_IMPORTED_MODULE_5__.decodeLeb128)(data));\n                                        break;\n                                    }\n                                    case 'cbor': {\n                                        status.set(path.key, decodeCbor(data));\n                                        break;\n                                    }\n                                    case 'hex': {\n                                        status.set(path.key, decodeHex(data));\n                                        break;\n                                    }\n                                    case 'utf-8': {\n                                        status.set(path.key, decodeUtf8(data));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                // Break on signature verification errors\n                if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes('Invalid certificate')) {\n                    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(error.message);\n                }\n                if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                    status.set(path.key, null);\n                }\n                else {\n                    status.set(path, null);\n                }\n                console.group();\n                console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n                console.warn(error);\n                console.groupEnd();\n            }\n        })();\n    });\n    // Fetch all values separately, as each option can fail\n    await Promise.all(promises);\n    return status;\n};\nconst fetchNodeKeys = (certificate, canisterId, root_key) => {\n    if (!canisterId._isPrincipal) {\n        throw new Error('Invalid canisterId');\n    }\n    const cert = _cbor__WEBPACK_IMPORTED_MODULE_4__.decode(new Uint8Array(certificate));\n    const tree = cert.tree;\n    let delegation = cert.delegation;\n    let subnetId;\n    if (delegation && delegation.subnet_id) {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));\n    }\n    // On local replica, with System type subnet, there is no delegation\n    else if (!delegation && typeof root_key !== 'undefined') {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(new Uint8Array(root_key));\n        delegation = {\n            subnet_id: subnetId.toUint8Array(),\n            certificate: new ArrayBuffer(0),\n        };\n    }\n    // otherwise use default NNS subnet id\n    else {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(_dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText('tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe').toUint8Array());\n        delegation = {\n            subnet_id: subnetId.toUint8Array(),\n            certificate: new ArrayBuffer(0),\n        };\n    }\n    const canisterInRange = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.check_canister_ranges)({ canisterId, subnetId, tree });\n    if (!canisterInRange) {\n        throw new Error('Canister not in range');\n    }\n    const subnetLookupResult = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookup_path)(['subnet', delegation.subnet_id, 'node'], tree);\n    if (subnetLookupResult.status !== _certificate__WEBPACK_IMPORTED_MODULE_2__.LookupStatus.Found) {\n        throw new Error('Node not found');\n    }\n    if (subnetLookupResult.value instanceof ArrayBuffer) {\n        throw new Error('Invalid node tree');\n    }\n    const nodeForks = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.flatten_forks)(subnetLookupResult.value);\n    const nodeKeys = new Map();\n    nodeForks.forEach(fork => {\n        const node_id = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(new Uint8Array(fork[1])).toText();\n        const publicKeyLookupResult = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookup_path)(['public_key'], fork[2]);\n        if (publicKeyLookupResult.status !== _certificate__WEBPACK_IMPORTED_MODULE_2__.LookupStatus.Found) {\n            throw new Error('Public key not found');\n        }\n        const derEncodedPublicKey = publicKeyLookupResult.value;\n        if (derEncodedPublicKey.byteLength !== 44) {\n            throw new Error('Invalid public key length');\n        }\n        else {\n            nodeKeys.set(node_id, derEncodedPublicKey);\n        }\n    });\n    return {\n        subnetId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),\n        nodeKeys,\n    };\n};\nconst encodePath = (path, canisterId) => {\n    const encoder = new TextEncoder();\n    const encode = (arg) => {\n        return new DataView(encoder.encode(arg).buffer).buffer;\n    };\n    const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;\n    switch (path) {\n        case 'time':\n            return [encode('time')];\n        case 'controllers':\n            return [encode('canister'), canisterBuffer, encode('controllers')];\n        case 'module_hash':\n            return [encode('canister'), canisterBuffer, encode('module_hash')];\n        case 'subnet':\n            return [encode('subnet')];\n        case 'candid':\n            return [encode('canister'), canisterBuffer, encode('metadata'), encode('candid:service')];\n        default: {\n            // Check for CustomPath signature\n            if ('key' in path && 'path' in path) {\n                // For simplified metadata queries\n                if (typeof path['path'] === 'string' || path['path'] instanceof ArrayBuffer) {\n                    const metaPath = path.path;\n                    const encoded = typeof metaPath === 'string' ? encode(metaPath) : metaPath;\n                    return [encode('canister'), canisterBuffer, encode('metadata'), encoded];\n                    // For non-metadata, return the provided custompath\n                }\n                else {\n                    return path['path'];\n                }\n            }\n        }\n    }\n    throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);\n};\nconst decodeHex = (buf) => {\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(buf);\n};\nconst decodeCbor = (buf) => {\n    return _cbor__WEBPACK_IMPORTED_MODULE_4__.decode(buf);\n};\nconst decodeUtf8 = (buf) => {\n    return new TextDecoder().decode(buf);\n};\n// Controllers are CBOR-encoded buffers\nconst decodeControllers = (buf) => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const controllersRaw = decodeCbor(buf);\n    return controllersRaw.map((buf) => {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(buf));\n    });\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVyU3RhdHVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMrQztBQUNSO0FBQzhGO0FBQzdGO0FBQ1I7QUFDd0I7QUFDeEQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QixTQUFTO0FBQzNDLFdBQVcscUNBQXFDLG9CQUFvQjtBQUNwRSxXQUFXLGdDQUFnQyxlQUFlLGlCQUFpQjtBQUMzRSxXQUFXLGdDQUFnQyxlQUFlO0FBQzFELGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksZUFBZTtBQUMzQix1QkFBdUIseURBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsbUNBQW1DLHFEQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQSxxRUFBcUUsS0FBSztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzREFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHdEQUFZO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUNBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFTLG9CQUFvQix5REFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1FQUFxQixHQUFHLDRCQUE0QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQVc7QUFDMUMsc0NBQXNDLHNEQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQWE7QUFDbkM7QUFDQTtBQUNBLHdCQUF3Qix5REFBUztBQUNqQyxzQ0FBc0MseURBQVc7QUFDakQsNkNBQTZDLHNEQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQix5REFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksTUFBTTtBQUM5STtBQUNBO0FBQ0EsV0FBVyxvREFBSztBQUNoQjtBQUNBO0FBQ0EsV0FBVyx5Q0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFTO0FBQ3hCLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2FnZW50QDIuMS4zX0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjNfX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9jYW5pc3RlclN0YXR1cy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQG1vZHVsZSBDYW5pc3RlclN0YXR1cyAqL1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCB7IEFnZW50RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgQ2VydGlmaWNhdGUsIGZsYXR0ZW5fZm9ya3MsIGNoZWNrX2NhbmlzdGVyX3JhbmdlcywgTG9va3VwU3RhdHVzLCBsb29rdXBfcGF0aCwgbG9va3VwUmVzdWx0VG9CdWZmZXIsIH0gZnJvbSAnLi4vY2VydGlmaWNhdGUnO1xuaW1wb3J0IHsgdG9IZXggfSBmcm9tICcuLi91dGlscy9idWZmZXInO1xuaW1wb3J0ICogYXMgQ2JvciBmcm9tICcuLi9jYm9yJztcbmltcG9ydCB7IGRlY29kZUxlYjEyOCwgZGVjb2RlVGltZSB9IGZyb20gJy4uL3V0aWxzL2xlYic7XG4vKipcbiAqIEludGVyZmFjZSB0byBkZWZpbmUgYSBjdXN0b20gcGF0aC4gTmVzdGVkIHBhdGhzIHdpbGwgYmUgcmVwcmVzZW50ZWQgYXMgaW5kaXZpZHVhbCBidWZmZXJzLCBhbmQgY2FuIGJlIGNyZWF0ZWQgZnJvbSB0ZXh0IHVzaW5nIFRleHRFbmNvZGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUga2V5IHRvIHVzZSB0byBhY2Nlc3MgdGhlIHJldHVybmVkIHZhbHVlIGluIHRoZSBjYW5pc3RlclN0YXR1cyBtYXBcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJbXX0gcGF0aCB0aGUgcGF0aCB0byB0aGUgZGVzaXJlZCB2YWx1ZSwgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgYnVmZmVyc1xuICogQHBhcmFtIHtzdHJpbmd9IGRlY29kZVN0cmF0ZWd5IHRoZSBzdHJhdGVneSB0byB1c2UgdG8gZGVjb2RlIHRoZSByZXR1cm5lZCB2YWx1ZVxuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tUGF0aCB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBwYXRoLCBkZWNvZGVTdHJhdGVneSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5kZWNvZGVTdHJhdGVneSA9IGRlY29kZVN0cmF0ZWd5O1xuICAgIH1cbn1cbi8qKlxuICogUmVxdWVzdCBpbmZvcm1hdGlvbiBpbiB0aGUgcmVxdWVzdF9zdGF0dXMgc3RhdGUgdHJlZSBmb3IgYSBnaXZlbiBjYW5pc3Rlci5cbiAqIENhbiBiZSB1c2VkIHRvIHJlcXVlc3QgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNhbmlzdGVyJ3MgY29udHJvbGxlcnMsIHRpbWUsIG1vZHVsZSBoYXNoLCBjYW5kaWQgaW50ZXJmYWNlLCBhbmQgbW9yZS5cbiAqIEBwYXJhbSB7Q2FuaXN0ZXJTdGF0dXNPcHRpb25zfSBvcHRpb25zIHtAbGluayBDYW5pc3RlclN0YXR1c09wdGlvbnN9XG4gKiBAcGFyYW0ge0NhbmlzdGVyU3RhdHVzT3B0aW9uc1snY2FuaXN0ZXJJZCddfSBvcHRpb25zLmNhbmlzdGVySWQge0BsaW5rIFByaW5jaXBhbH1cbiAqIEBwYXJhbSB7Q2FuaXN0ZXJTdGF0dXNPcHRpb25zWydhZ2VudCddfSBvcHRpb25zLmFnZW50IHtAbGluayBIdHRwQWdlbnR9IG9wdGlvbmFsIGF1dGhlbnRpY2F0ZWQgYWdlbnQgdG8gdXNlIHRvIG1ha2UgdGhlIGNhbmlzdGVyIHJlcXVlc3QuIFVzZWZ1bCBmb3IgYWNjZXNzaW5nIHByaXZhdGUgbWV0YWRhdGEgdW5kZXIgaWNwOnByaXZhdGVcbiAqIEBwYXJhbSB7Q2FuaXN0ZXJTdGF0dXNPcHRpb25zWydwYXRocyddfSBvcHRpb25zLnBhdGhzIHtAbGluayBQYXRoW119XG4gKiBAcmV0dXJucyB7U3RhdHVzfSBvYmplY3QgcG9wdWxhdGVkIHdpdGggZGF0YSBmcm9tIHRoZSByZXF1ZXN0ZWQgcGF0aHNcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzdGF0dXMgPSBhd2FpdCBjYW5pc3RlclN0YXR1cyh7XG4gKiAgIHBhdGhzOiBbJ2NvbnRyb2xsZXJzJywgJ2NhbmRpZCddLFxuICogICAuLi5vcHRpb25zXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjb250cm9sbGVycyA9IHN0YXR1cy5nZXQoJ2NvbnRyb2xsZXJzJyk7XG4gKi9cbmV4cG9ydCBjb25zdCByZXF1ZXN0ID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IGFnZW50LCBwYXRocyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjYW5pc3RlcklkID0gUHJpbmNpcGFsLmZyb20ob3B0aW9ucy5jYW5pc3RlcklkKTtcbiAgICBjb25zdCB1bmlxdWVQYXRocyA9IFsuLi5uZXcgU2V0KHBhdGhzKV07XG4gICAgLy8gTWFwIHBhdGggb3B0aW9ucyB0byB0aGVpciBjb3JyZWN0IGZvcm1hdHNcbiAgICBjb25zdCBlbmNvZGVkUGF0aHMgPSB1bmlxdWVQYXRocy5tYXAocGF0aCA9PiB7XG4gICAgICAgIHJldHVybiBlbmNvZGVQYXRoKHBhdGgsIGNhbmlzdGVySWQpO1xuICAgIH0pO1xuICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IHVuaXF1ZVBhdGhzLm1hcCgocGF0aCwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWdlbnQucmVhZFN0YXRlKGNhbmlzdGVySWQsIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHM6IFtlbmNvZGVkUGF0aHNbaW5kZXhdXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZXJ0ID0gYXdhaXQgQ2VydGlmaWNhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IHJlc3BvbnNlLmNlcnRpZmljYXRlLFxuICAgICAgICAgICAgICAgICAgICByb290S2V5OiBhZ2VudC5yb290S2V5LFxuICAgICAgICAgICAgICAgICAgICBjYW5pc3RlcklkOiBjYW5pc3RlcklkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IChjZXJ0LCBwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSAnc3VibmV0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGZldGNoTm9kZUtleXMocmVzcG9uc2UuY2VydGlmaWNhdGUsIGNhbmlzdGVySWQsIGFnZW50LnJvb3RLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnQubG9va3VwKGVuY29kZVBhdGgocGF0aCwgY2FuaXN0ZXJJZCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIG11c3QgcGFzcyBpbiB0aGUgcm9vdEtleSBpZiB3ZSBoYXZlIG5vIGRlbGVnYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGgsIGRhdGEgfSA9IGxvb2t1cChjZXJ0LCB1bmlxdWVQYXRoc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUeXBpY2FsbHksIHRoZSBjZXJ0IGxvb2t1cCB3aWxsIHRocm93XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXhwZWN0ZWQgdG8gZmluZCByZXN1bHQgZm9yIHBhdGggJHtwYXRofSwgYnV0IGluc3RlYWQgZm91bmQgbm90aGluZy5gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aC5rZXksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RpbWUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLCBkZWNvZGVUaW1lKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnRyb2xsZXJzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgZGVjb2RlQ29udHJvbGxlcnMoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW9kdWxlX2hhc2gnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLCBkZWNvZGVIZXgoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3VibmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjYW5kaWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLCBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBDdXN0b21QYXRoIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycgJiYgJ2tleScgaW4gcGF0aCAmJiAncGF0aCcgaW4gcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGguZGVjb2RlU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLmtleSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWIxMjgnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLmtleSwgZGVjb2RlTGViMTI4KGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nib3InOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLmtleSwgZGVjb2RlQ2JvcihkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoZXgnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLmtleSwgZGVjb2RlSGV4KGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0Zi04Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aC5rZXksIGRlY29kZVV0ZjgoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQnJlYWsgb24gc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZiAoKF9hID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnSW52YWxpZCBjZXJ0aWZpY2F0ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnICYmICdrZXknIGluIHBhdGggJiYgJ3BhdGgnIGluIHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLmtleSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBFeHBlY3RlZCB0byBmaW5kIHJlc3VsdCBmb3IgcGF0aCAke3BhdGh9LCBidXQgaW5zdGVhZCBmb3VuZCBub3RoaW5nLmApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0pO1xuICAgIC8vIEZldGNoIGFsbCB2YWx1ZXMgc2VwYXJhdGVseSwgYXMgZWFjaCBvcHRpb24gY2FuIGZhaWxcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgcmV0dXJuIHN0YXR1cztcbn07XG5leHBvcnQgY29uc3QgZmV0Y2hOb2RlS2V5cyA9IChjZXJ0aWZpY2F0ZSwgY2FuaXN0ZXJJZCwgcm9vdF9rZXkpID0+IHtcbiAgICBpZiAoIWNhbmlzdGVySWQuX2lzUHJpbmNpcGFsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjYW5pc3RlcklkJyk7XG4gICAgfVxuICAgIGNvbnN0IGNlcnQgPSBDYm9yLmRlY29kZShuZXcgVWludDhBcnJheShjZXJ0aWZpY2F0ZSkpO1xuICAgIGNvbnN0IHRyZWUgPSBjZXJ0LnRyZWU7XG4gICAgbGV0IGRlbGVnYXRpb24gPSBjZXJ0LmRlbGVnYXRpb247XG4gICAgbGV0IHN1Ym5ldElkO1xuICAgIGlmIChkZWxlZ2F0aW9uICYmIGRlbGVnYXRpb24uc3VibmV0X2lkKSB7XG4gICAgICAgIHN1Ym5ldElkID0gUHJpbmNpcGFsLmZyb21VaW50OEFycmF5KG5ldyBVaW50OEFycmF5KGRlbGVnYXRpb24uc3VibmV0X2lkKSk7XG4gICAgfVxuICAgIC8vIE9uIGxvY2FsIHJlcGxpY2EsIHdpdGggU3lzdGVtIHR5cGUgc3VibmV0LCB0aGVyZSBpcyBubyBkZWxlZ2F0aW9uXG4gICAgZWxzZSBpZiAoIWRlbGVnYXRpb24gJiYgdHlwZW9mIHJvb3Rfa2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdWJuZXRJZCA9IFByaW5jaXBhbC5zZWxmQXV0aGVudGljYXRpbmcobmV3IFVpbnQ4QXJyYXkocm9vdF9rZXkpKTtcbiAgICAgICAgZGVsZWdhdGlvbiA9IHtcbiAgICAgICAgICAgIHN1Ym5ldF9pZDogc3VibmV0SWQudG9VaW50OEFycmF5KCksXG4gICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbmV3IEFycmF5QnVmZmVyKDApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgdXNlIGRlZmF1bHQgTk5TIHN1Ym5ldCBpZFxuICAgIGVsc2Uge1xuICAgICAgICBzdWJuZXRJZCA9IFByaW5jaXBhbC5zZWxmQXV0aGVudGljYXRpbmcoUHJpbmNpcGFsLmZyb21UZXh0KCd0ZGIyNi1qb3A2ay1hb2dsbC03bHRncy1lcnVpZi02a2s3bS1xcGt0Zi1nZGlxeC1teHRyZi12YjVlNi1lcWUnKS50b1VpbnQ4QXJyYXkoKSk7XG4gICAgICAgIGRlbGVnYXRpb24gPSB7XG4gICAgICAgICAgICBzdWJuZXRfaWQ6IHN1Ym5ldElkLnRvVWludDhBcnJheSgpLFxuICAgICAgICAgICAgY2VydGlmaWNhdGU6IG5ldyBBcnJheUJ1ZmZlcigwKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY2FuaXN0ZXJJblJhbmdlID0gY2hlY2tfY2FuaXN0ZXJfcmFuZ2VzKHsgY2FuaXN0ZXJJZCwgc3VibmV0SWQsIHRyZWUgfSk7XG4gICAgaWYgKCFjYW5pc3RlckluUmFuZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5pc3RlciBub3QgaW4gcmFuZ2UnKTtcbiAgICB9XG4gICAgY29uc3Qgc3VibmV0TG9va3VwUmVzdWx0ID0gbG9va3VwX3BhdGgoWydzdWJuZXQnLCBkZWxlZ2F0aW9uLnN1Ym5ldF9pZCwgJ25vZGUnXSwgdHJlZSk7XG4gICAgaWYgKHN1Ym5ldExvb2t1cFJlc3VsdC5zdGF0dXMgIT09IExvb2t1cFN0YXR1cy5Gb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGlmIChzdWJuZXRMb29rdXBSZXN1bHQudmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbm9kZSB0cmVlJyk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVGb3JrcyA9IGZsYXR0ZW5fZm9ya3Moc3VibmV0TG9va3VwUmVzdWx0LnZhbHVlKTtcbiAgICBjb25zdCBub2RlS2V5cyA9IG5ldyBNYXAoKTtcbiAgICBub2RlRm9ya3MuZm9yRWFjaChmb3JrID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZV9pZCA9IFByaW5jaXBhbC5mcm9tKG5ldyBVaW50OEFycmF5KGZvcmtbMV0pKS50b1RleHQoKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5TG9va3VwUmVzdWx0ID0gbG9va3VwX3BhdGgoWydwdWJsaWNfa2V5J10sIGZvcmtbMl0pO1xuICAgICAgICBpZiAocHVibGljS2V5TG9va3VwUmVzdWx0LnN0YXR1cyAhPT0gTG9va3VwU3RhdHVzLkZvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1B1YmxpYyBrZXkgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVyRW5jb2RlZFB1YmxpY0tleSA9IHB1YmxpY0tleUxvb2t1cFJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKGRlckVuY29kZWRQdWJsaWNLZXkuYnl0ZUxlbmd0aCAhPT0gNDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwdWJsaWMga2V5IGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZUtleXMuc2V0KG5vZGVfaWQsIGRlckVuY29kZWRQdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VibmV0SWQ6IFByaW5jaXBhbC5mcm9tVWludDhBcnJheShuZXcgVWludDhBcnJheShkZWxlZ2F0aW9uLnN1Ym5ldF9pZCkpLnRvVGV4dCgpLFxuICAgICAgICBub2RlS2V5cyxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVQYXRoID0gKHBhdGgsIGNhbmlzdGVySWQpID0+IHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlID0gKGFyZykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGVuY29kZXIuZW5jb2RlKGFyZykuYnVmZmVyKS5idWZmZXI7XG4gICAgfTtcbiAgICBjb25zdCBjYW5pc3RlckJ1ZmZlciA9IG5ldyBEYXRhVmlldyhjYW5pc3RlcklkLnRvVWludDhBcnJheSgpLmJ1ZmZlcikuYnVmZmVyO1xuICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICBjYXNlICd0aW1lJzpcbiAgICAgICAgICAgIHJldHVybiBbZW5jb2RlKCd0aW1lJyldO1xuICAgICAgICBjYXNlICdjb250cm9sbGVycyc6XG4gICAgICAgICAgICByZXR1cm4gW2VuY29kZSgnY2FuaXN0ZXInKSwgY2FuaXN0ZXJCdWZmZXIsIGVuY29kZSgnY29udHJvbGxlcnMnKV07XG4gICAgICAgIGNhc2UgJ21vZHVsZV9oYXNoJzpcbiAgICAgICAgICAgIHJldHVybiBbZW5jb2RlKCdjYW5pc3RlcicpLCBjYW5pc3RlckJ1ZmZlciwgZW5jb2RlKCdtb2R1bGVfaGFzaCcpXTtcbiAgICAgICAgY2FzZSAnc3VibmV0JzpcbiAgICAgICAgICAgIHJldHVybiBbZW5jb2RlKCdzdWJuZXQnKV07XG4gICAgICAgIGNhc2UgJ2NhbmRpZCc6XG4gICAgICAgICAgICByZXR1cm4gW2VuY29kZSgnY2FuaXN0ZXInKSwgY2FuaXN0ZXJCdWZmZXIsIGVuY29kZSgnbWV0YWRhdGEnKSwgZW5jb2RlKCdjYW5kaWQ6c2VydmljZScpXTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEN1c3RvbVBhdGggc2lnbmF0dXJlXG4gICAgICAgICAgICBpZiAoJ2tleScgaW4gcGF0aCAmJiAncGF0aCcgaW4gcGF0aCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBzaW1wbGlmaWVkIG1ldGFkYXRhIHF1ZXJpZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGhbJ3BhdGgnXSA9PT0gJ3N0cmluZycgfHwgcGF0aFsncGF0aCddIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YVBhdGggPSBwYXRoLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSB0eXBlb2YgbWV0YVBhdGggPT09ICdzdHJpbmcnID8gZW5jb2RlKG1ldGFQYXRoKSA6IG1ldGFQYXRoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VuY29kZSgnY2FuaXN0ZXInKSwgY2FuaXN0ZXJCdWZmZXIsIGVuY29kZSgnbWV0YWRhdGEnKSwgZW5jb2RlZF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBub24tbWV0YWRhdGEsIHJldHVybiB0aGUgcHJvdmlkZWQgY3VzdG9tcGF0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhbJ3BhdGgnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBbiB1bmV4cGVlY3RlZCBlcnJvciB3YXMgZW5jb3VudGVyZWQgd2hpbGUgZW5jb2RpbmcgeW91ciBwYXRoIGZvciBjYW5pc3RlciBzdGF0dXMuIFBsZWFzZSBlbnN1cmUgdGhhdCB5b3VyIHBhdGgsICR7cGF0aH0gd2FzIGZvcm1hdHRlZCBjb3JyZWN0bHkuYCk7XG59O1xuY29uc3QgZGVjb2RlSGV4ID0gKGJ1ZikgPT4ge1xuICAgIHJldHVybiB0b0hleChidWYpO1xufTtcbmNvbnN0IGRlY29kZUNib3IgPSAoYnVmKSA9PiB7XG4gICAgcmV0dXJuIENib3IuZGVjb2RlKGJ1Zik7XG59O1xuY29uc3QgZGVjb2RlVXRmOCA9IChidWYpID0+IHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1Zik7XG59O1xuLy8gQ29udHJvbGxlcnMgYXJlIENCT1ItZW5jb2RlZCBidWZmZXJzXG5jb25zdCBkZWNvZGVDb250cm9sbGVycyA9IChidWYpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgY29uc3QgY29udHJvbGxlcnNSYXcgPSBkZWNvZGVDYm9yKGJ1Zik7XG4gICAgcmV0dXJuIGNvbnRyb2xsZXJzUmF3Lm1hcCgoYnVmKSA9PiB7XG4gICAgICAgIHJldHVybiBQcmluY2lwYWwuZnJvbVVpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/asset.js":
/*!*********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/asset.js ***!
  \*********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAssetCanisterActor: () => (/* binding */ createAssetCanisterActor)\n/* harmony export */ });\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actor */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/actor.js\");\n/* harmony import */ var _asset_idl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asset_idl */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js\");\n\n\n/**\n * Create a management canister actor.\n * @param config\n */\nfunction createAssetCanisterActor(config) {\n    return _actor__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_asset_idl__WEBPACK_IMPORTED_MODULE_1__[\"default\"], config);\n}\n//# sourceMappingURL=asset.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVycy9hc3NldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyx5Q0FBSyxhQUFhLGtEQUFhO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVycy9hc3NldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBY3RvciB9IGZyb20gJy4uL2FjdG9yJztcbmltcG9ydCBhc3NldENhbmlzdGVyIGZyb20gJy4vYXNzZXRfaWRsJztcbi8qKlxuICogQ3JlYXRlIGEgbWFuYWdlbWVudCBjYW5pc3RlciBhY3Rvci5cbiAqIEBwYXJhbSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFzc2V0Q2FuaXN0ZXJBY3Rvcihjb25maWcpIHtcbiAgICByZXR1cm4gQWN0b3IuY3JlYXRlQWN0b3IoYXNzZXRDYW5pc3RlciwgY29uZmlnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2V0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/asset.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js":
/*!*************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js ***!
  \*************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * This file is generated from the candid for asset management.\n */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (({ IDL }) => {\n    return IDL.Service({\n        retrieve: IDL.Func([IDL.Text], [IDL.Vec(IDL.Nat8)], ['query']),\n        store: IDL.Func([IDL.Text, IDL.Vec(IDL.Nat8)], [], []),\n    });\n});\n//# sourceMappingURL=asset_idl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVycy9hc3NldF9pZGwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxHQUFHLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsRUFBQztBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2FnZW50QDIuMS4zX0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjNfX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9jYW5pc3RlcnMvYXNzZXRfaWRsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBjYW5kaWQgZm9yIGFzc2V0IG1hbmFnZW1lbnQuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBkZWZhdWx0ICh7IElETCB9KSA9PiB7XG4gICAgcmV0dXJuIElETC5TZXJ2aWNlKHtcbiAgICAgICAgcmV0cmlldmU6IElETC5GdW5jKFtJREwuVGV4dF0sIFtJREwuVmVjKElETC5OYXQ4KV0sIFsncXVlcnknXSksXG4gICAgICAgIHN0b3JlOiBJREwuRnVuYyhbSURMLlRleHQsIElETC5WZWMoSURMLk5hdDgpXSwgW10sIFtdKSxcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NldF9pZGwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js":
/*!******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js ***!
  \******************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n * This file is generated from the candid for asset management.\n * didc version: 0.4.0\n */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (({ IDL }) => {\n    const bitcoin_network = IDL.Variant({\n        mainnet: IDL.Null,\n        testnet: IDL.Null,\n    });\n    const bitcoin_address = IDL.Text;\n    const bitcoin_get_balance_args = IDL.Record({\n        network: bitcoin_network,\n        address: bitcoin_address,\n        min_confirmations: IDL.Opt(IDL.Nat32),\n    });\n    const satoshi = IDL.Nat64;\n    const bitcoin_get_balance_result = satoshi;\n    const bitcoin_get_current_fee_percentiles_args = IDL.Record({\n        network: bitcoin_network,\n    });\n    const millisatoshi_per_byte = IDL.Nat64;\n    const bitcoin_get_current_fee_percentiles_result = IDL.Vec(millisatoshi_per_byte);\n    const bitcoin_get_utxos_args = IDL.Record({\n        network: bitcoin_network,\n        filter: IDL.Opt(IDL.Variant({\n            page: IDL.Vec(IDL.Nat8),\n            min_confirmations: IDL.Nat32,\n        })),\n        address: bitcoin_address,\n    });\n    const block_hash = IDL.Vec(IDL.Nat8);\n    const outpoint = IDL.Record({\n        txid: IDL.Vec(IDL.Nat8),\n        vout: IDL.Nat32,\n    });\n    const utxo = IDL.Record({\n        height: IDL.Nat32,\n        value: satoshi,\n        outpoint: outpoint,\n    });\n    const bitcoin_get_utxos_result = IDL.Record({\n        next_page: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        tip_height: IDL.Nat32,\n        tip_block_hash: block_hash,\n        utxos: IDL.Vec(utxo),\n    });\n    const bitcoin_send_transaction_args = IDL.Record({\n        transaction: IDL.Vec(IDL.Nat8),\n        network: bitcoin_network,\n    });\n    const canister_id = IDL.Principal;\n    const canister_info_args = IDL.Record({\n        canister_id: canister_id,\n        num_requested_changes: IDL.Opt(IDL.Nat64),\n    });\n    const change_origin = IDL.Variant({\n        from_user: IDL.Record({ user_id: IDL.Principal }),\n        from_canister: IDL.Record({\n            canister_version: IDL.Opt(IDL.Nat64),\n            canister_id: IDL.Principal,\n        }),\n    });\n    const change_details = IDL.Variant({\n        creation: IDL.Record({ controllers: IDL.Vec(IDL.Principal) }),\n        code_deployment: IDL.Record({\n            mode: IDL.Variant({\n                reinstall: IDL.Null,\n                upgrade: IDL.Null,\n                install: IDL.Null,\n            }),\n            module_hash: IDL.Vec(IDL.Nat8),\n        }),\n        controllers_change: IDL.Record({\n            controllers: IDL.Vec(IDL.Principal),\n        }),\n        code_uninstall: IDL.Null,\n    });\n    const change = IDL.Record({\n        timestamp_nanos: IDL.Nat64,\n        canister_version: IDL.Nat64,\n        origin: change_origin,\n        details: change_details,\n    });\n    const canister_info_result = IDL.Record({\n        controllers: IDL.Vec(IDL.Principal),\n        module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        recent_changes: IDL.Vec(change),\n        total_num_changes: IDL.Nat64,\n    });\n    const canister_status_args = IDL.Record({ canister_id: canister_id });\n    const log_visibility = IDL.Variant({\n        controllers: IDL.Null,\n        public: IDL.Null,\n    });\n    const definite_canister_settings = IDL.Record({\n        freezing_threshold: IDL.Nat,\n        controllers: IDL.Vec(IDL.Principal),\n        reserved_cycles_limit: IDL.Nat,\n        log_visibility: log_visibility,\n        wasm_memory_limit: IDL.Nat,\n        memory_allocation: IDL.Nat,\n        compute_allocation: IDL.Nat,\n    });\n    const canister_status_result = IDL.Record({\n        status: IDL.Variant({\n            stopped: IDL.Null,\n            stopping: IDL.Null,\n            running: IDL.Null,\n        }),\n        memory_size: IDL.Nat,\n        cycles: IDL.Nat,\n        settings: definite_canister_settings,\n        query_stats: IDL.Record({\n            response_payload_bytes_total: IDL.Nat,\n            num_instructions_total: IDL.Nat,\n            num_calls_total: IDL.Nat,\n            request_payload_bytes_total: IDL.Nat,\n        }),\n        idle_cycles_burned_per_day: IDL.Nat,\n        module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        reserved_cycles: IDL.Nat,\n    });\n    const clear_chunk_store_args = IDL.Record({ canister_id: canister_id });\n    const canister_settings = IDL.Record({\n        freezing_threshold: IDL.Opt(IDL.Nat),\n        controllers: IDL.Opt(IDL.Vec(IDL.Principal)),\n        reserved_cycles_limit: IDL.Opt(IDL.Nat),\n        log_visibility: IDL.Opt(log_visibility),\n        wasm_memory_limit: IDL.Opt(IDL.Nat),\n        memory_allocation: IDL.Opt(IDL.Nat),\n        compute_allocation: IDL.Opt(IDL.Nat),\n    });\n    const create_canister_args = IDL.Record({\n        settings: IDL.Opt(canister_settings),\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const create_canister_result = IDL.Record({ canister_id: canister_id });\n    const delete_canister_args = IDL.Record({ canister_id: canister_id });\n    const deposit_cycles_args = IDL.Record({ canister_id: canister_id });\n    const ecdsa_curve = IDL.Variant({ secp256k1: IDL.Null });\n    const ecdsa_public_key_args = IDL.Record({\n        key_id: IDL.Record({ name: IDL.Text, curve: ecdsa_curve }),\n        canister_id: IDL.Opt(canister_id),\n        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),\n    });\n    const ecdsa_public_key_result = IDL.Record({\n        public_key: IDL.Vec(IDL.Nat8),\n        chain_code: IDL.Vec(IDL.Nat8),\n    });\n    const fetch_canister_logs_args = IDL.Record({ canister_id: canister_id });\n    const canister_log_record = IDL.Record({\n        idx: IDL.Nat64,\n        timestamp_nanos: IDL.Nat64,\n        content: IDL.Vec(IDL.Nat8),\n    });\n    const fetch_canister_logs_result = IDL.Record({\n        canister_log_records: IDL.Vec(canister_log_record),\n    });\n    const http_header = IDL.Record({ value: IDL.Text, name: IDL.Text });\n    const http_request_result = IDL.Record({\n        status: IDL.Nat,\n        body: IDL.Vec(IDL.Nat8),\n        headers: IDL.Vec(http_header),\n    });\n    const http_request_args = IDL.Record({\n        url: IDL.Text,\n        method: IDL.Variant({\n            get: IDL.Null,\n            head: IDL.Null,\n            post: IDL.Null,\n        }),\n        max_response_bytes: IDL.Opt(IDL.Nat64),\n        body: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        transform: IDL.Opt(IDL.Record({\n            function: IDL.Func([\n                IDL.Record({\n                    context: IDL.Vec(IDL.Nat8),\n                    response: http_request_result,\n                }),\n            ], [http_request_result], ['query']),\n            context: IDL.Vec(IDL.Nat8),\n        })),\n        headers: IDL.Vec(http_header),\n    });\n    const canister_install_mode = IDL.Variant({\n        reinstall: IDL.Null,\n        upgrade: IDL.Opt(IDL.Record({\n            wasm_memory_persistence: IDL.Opt(IDL.Variant({ keep: IDL.Null, replace: IDL.Null })),\n            skip_pre_upgrade: IDL.Opt(IDL.Bool),\n        })),\n        install: IDL.Null,\n    });\n    const chunk_hash = IDL.Record({ hash: IDL.Vec(IDL.Nat8) });\n    const install_chunked_code_args = IDL.Record({\n        arg: IDL.Vec(IDL.Nat8),\n        wasm_module_hash: IDL.Vec(IDL.Nat8),\n        mode: canister_install_mode,\n        chunk_hashes_list: IDL.Vec(chunk_hash),\n        target_canister: canister_id,\n        store_canister: IDL.Opt(canister_id),\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const wasm_module = IDL.Vec(IDL.Nat8);\n    const install_code_args = IDL.Record({\n        arg: IDL.Vec(IDL.Nat8),\n        wasm_module: wasm_module,\n        mode: canister_install_mode,\n        canister_id: canister_id,\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const node_metrics_history_args = IDL.Record({\n        start_at_timestamp_nanos: IDL.Nat64,\n        subnet_id: IDL.Principal,\n    });\n    const node_metrics = IDL.Record({\n        num_block_failures_total: IDL.Nat64,\n        node_id: IDL.Principal,\n        num_blocks_proposed_total: IDL.Nat64,\n    });\n    const node_metrics_history_result = IDL.Vec(IDL.Record({\n        timestamp_nanos: IDL.Nat64,\n        node_metrics: IDL.Vec(node_metrics),\n    }));\n    const provisional_create_canister_with_cycles_args = IDL.Record({\n        settings: IDL.Opt(canister_settings),\n        specified_id: IDL.Opt(canister_id),\n        amount: IDL.Opt(IDL.Nat),\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const provisional_create_canister_with_cycles_result = IDL.Record({\n        canister_id: canister_id,\n    });\n    const provisional_top_up_canister_args = IDL.Record({\n        canister_id: canister_id,\n        amount: IDL.Nat,\n    });\n    const raw_rand_result = IDL.Vec(IDL.Nat8);\n    const schnorr_algorithm = IDL.Variant({\n        ed25519: IDL.Null,\n        bip340secp256k1: IDL.Null,\n    });\n    const schnorr_public_key_args = IDL.Record({\n        key_id: IDL.Record({\n            algorithm: schnorr_algorithm,\n            name: IDL.Text,\n        }),\n        canister_id: IDL.Opt(canister_id),\n        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),\n    });\n    const schnorr_public_key_result = IDL.Record({\n        public_key: IDL.Vec(IDL.Nat8),\n        chain_code: IDL.Vec(IDL.Nat8),\n    });\n    const sign_with_ecdsa_args = IDL.Record({\n        key_id: IDL.Record({ name: IDL.Text, curve: ecdsa_curve }),\n        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),\n        message_hash: IDL.Vec(IDL.Nat8),\n    });\n    const sign_with_ecdsa_result = IDL.Record({\n        signature: IDL.Vec(IDL.Nat8),\n    });\n    const sign_with_schnorr_args = IDL.Record({\n        key_id: IDL.Record({\n            algorithm: schnorr_algorithm,\n            name: IDL.Text,\n        }),\n        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),\n        message: IDL.Vec(IDL.Nat8),\n    });\n    const sign_with_schnorr_result = IDL.Record({\n        signature: IDL.Vec(IDL.Nat8),\n    });\n    const start_canister_args = IDL.Record({ canister_id: canister_id });\n    const stop_canister_args = IDL.Record({ canister_id: canister_id });\n    const stored_chunks_args = IDL.Record({ canister_id: canister_id });\n    const stored_chunks_result = IDL.Vec(chunk_hash);\n    const uninstall_code_args = IDL.Record({\n        canister_id: canister_id,\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const update_settings_args = IDL.Record({\n        canister_id: IDL.Principal,\n        settings: canister_settings,\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const upload_chunk_args = IDL.Record({\n        chunk: IDL.Vec(IDL.Nat8),\n        canister_id: IDL.Principal,\n    });\n    const upload_chunk_result = chunk_hash;\n    return IDL.Service({\n        bitcoin_get_balance: IDL.Func([bitcoin_get_balance_args], [bitcoin_get_balance_result], []),\n        bitcoin_get_current_fee_percentiles: IDL.Func([bitcoin_get_current_fee_percentiles_args], [bitcoin_get_current_fee_percentiles_result], []),\n        bitcoin_get_utxos: IDL.Func([bitcoin_get_utxos_args], [bitcoin_get_utxos_result], []),\n        bitcoin_send_transaction: IDL.Func([bitcoin_send_transaction_args], [], []),\n        canister_info: IDL.Func([canister_info_args], [canister_info_result], []),\n        canister_status: IDL.Func([canister_status_args], [canister_status_result], []),\n        clear_chunk_store: IDL.Func([clear_chunk_store_args], [], []),\n        create_canister: IDL.Func([create_canister_args], [create_canister_result], []),\n        delete_canister: IDL.Func([delete_canister_args], [], []),\n        deposit_cycles: IDL.Func([deposit_cycles_args], [], []),\n        ecdsa_public_key: IDL.Func([ecdsa_public_key_args], [ecdsa_public_key_result], []),\n        fetch_canister_logs: IDL.Func([fetch_canister_logs_args], [fetch_canister_logs_result], ['query']),\n        http_request: IDL.Func([http_request_args], [http_request_result], []),\n        install_chunked_code: IDL.Func([install_chunked_code_args], [], []),\n        install_code: IDL.Func([install_code_args], [], []),\n        node_metrics_history: IDL.Func([node_metrics_history_args], [node_metrics_history_result], []),\n        provisional_create_canister_with_cycles: IDL.Func([provisional_create_canister_with_cycles_args], [provisional_create_canister_with_cycles_result], []),\n        provisional_top_up_canister: IDL.Func([provisional_top_up_canister_args], [], []),\n        raw_rand: IDL.Func([], [raw_rand_result], []),\n        schnorr_public_key: IDL.Func([schnorr_public_key_args], [schnorr_public_key_result], []),\n        sign_with_ecdsa: IDL.Func([sign_with_ecdsa_args], [sign_with_ecdsa_result], []),\n        sign_with_schnorr: IDL.Func([sign_with_schnorr_args], [sign_with_schnorr_result], []),\n        start_canister: IDL.Func([start_canister_args], [], []),\n        stop_canister: IDL.Func([stop_canister_args], [], []),\n        stored_chunks: IDL.Func([stored_chunks_args], [stored_chunks_result], []),\n        uninstall_code: IDL.Func([uninstall_code_args], [], []),\n        update_settings: IDL.Func([update_settings_args], [], []),\n        upload_chunk: IDL.Func([upload_chunk_args], [upload_chunk_result], []),\n    });\n});\n//# sourceMappingURL=management_idl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVycy9tYW5hZ2VtZW50X2lkbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsR0FBRyxLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhDQUE4QywwQkFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnREFBZ0QsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdEQUFnRCwwQkFBMEI7QUFDMUUsOENBQThDLDBCQUEwQjtBQUN4RSw2Q0FBNkMsMEJBQTBCO0FBQ3ZFLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQSw2QkFBNkIsb0NBQW9DO0FBQ2pFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtQ0FBbUM7QUFDOUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QixvQ0FBb0M7QUFDakU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCw2Q0FBNkMsMEJBQTBCO0FBQ3ZFLDRDQUE0QywwQkFBMEI7QUFDdEUsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsRUFBQztBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2FnZW50QDIuMS4zX0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjNfX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9jYW5pc3RlcnMvbWFuYWdlbWVudF9pZGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgY2FuZGlkIGZvciBhc3NldCBtYW5hZ2VtZW50LlxuICogZGlkYyB2ZXJzaW9uOiAwLjQuMFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlXG5leHBvcnQgZGVmYXVsdCAoeyBJREwgfSkgPT4ge1xuICAgIGNvbnN0IGJpdGNvaW5fbmV0d29yayA9IElETC5WYXJpYW50KHtcbiAgICAgICAgbWFpbm5ldDogSURMLk51bGwsXG4gICAgICAgIHRlc3RuZXQ6IElETC5OdWxsLFxuICAgIH0pO1xuICAgIGNvbnN0IGJpdGNvaW5fYWRkcmVzcyA9IElETC5UZXh0O1xuICAgIGNvbnN0IGJpdGNvaW5fZ2V0X2JhbGFuY2VfYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBuZXR3b3JrOiBiaXRjb2luX25ldHdvcmssXG4gICAgICAgIGFkZHJlc3M6IGJpdGNvaW5fYWRkcmVzcyxcbiAgICAgICAgbWluX2NvbmZpcm1hdGlvbnM6IElETC5PcHQoSURMLk5hdDMyKSxcbiAgICB9KTtcbiAgICBjb25zdCBzYXRvc2hpID0gSURMLk5hdDY0O1xuICAgIGNvbnN0IGJpdGNvaW5fZ2V0X2JhbGFuY2VfcmVzdWx0ID0gc2F0b3NoaTtcbiAgICBjb25zdCBiaXRjb2luX2dldF9jdXJyZW50X2ZlZV9wZXJjZW50aWxlc19hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIG5ldHdvcms6IGJpdGNvaW5fbmV0d29yayxcbiAgICB9KTtcbiAgICBjb25zdCBtaWxsaXNhdG9zaGlfcGVyX2J5dGUgPSBJREwuTmF0NjQ7XG4gICAgY29uc3QgYml0Y29pbl9nZXRfY3VycmVudF9mZWVfcGVyY2VudGlsZXNfcmVzdWx0ID0gSURMLlZlYyhtaWxsaXNhdG9zaGlfcGVyX2J5dGUpO1xuICAgIGNvbnN0IGJpdGNvaW5fZ2V0X3V0eG9zX2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgbmV0d29yazogYml0Y29pbl9uZXR3b3JrLFxuICAgICAgICBmaWx0ZXI6IElETC5PcHQoSURMLlZhcmlhbnQoe1xuICAgICAgICAgICAgcGFnZTogSURMLlZlYyhJREwuTmF0OCksXG4gICAgICAgICAgICBtaW5fY29uZmlybWF0aW9uczogSURMLk5hdDMyLFxuICAgICAgICB9KSksXG4gICAgICAgIGFkZHJlc3M6IGJpdGNvaW5fYWRkcmVzcyxcbiAgICB9KTtcbiAgICBjb25zdCBibG9ja19oYXNoID0gSURMLlZlYyhJREwuTmF0OCk7XG4gICAgY29uc3Qgb3V0cG9pbnQgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgdHhpZDogSURMLlZlYyhJREwuTmF0OCksXG4gICAgICAgIHZvdXQ6IElETC5OYXQzMixcbiAgICB9KTtcbiAgICBjb25zdCB1dHhvID0gSURMLlJlY29yZCh7XG4gICAgICAgIGhlaWdodDogSURMLk5hdDMyLFxuICAgICAgICB2YWx1ZTogc2F0b3NoaSxcbiAgICAgICAgb3V0cG9pbnQ6IG91dHBvaW50LFxuICAgIH0pO1xuICAgIGNvbnN0IGJpdGNvaW5fZ2V0X3V0eG9zX3Jlc3VsdCA9IElETC5SZWNvcmQoe1xuICAgICAgICBuZXh0X3BhZ2U6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxuICAgICAgICB0aXBfaGVpZ2h0OiBJREwuTmF0MzIsXG4gICAgICAgIHRpcF9ibG9ja19oYXNoOiBibG9ja19oYXNoLFxuICAgICAgICB1dHhvczogSURMLlZlYyh1dHhvKSxcbiAgICB9KTtcbiAgICBjb25zdCBiaXRjb2luX3NlbmRfdHJhbnNhY3Rpb25fYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICB0cmFuc2FjdGlvbjogSURMLlZlYyhJREwuTmF0OCksXG4gICAgICAgIG5ldHdvcms6IGJpdGNvaW5fbmV0d29yayxcbiAgICB9KTtcbiAgICBjb25zdCBjYW5pc3Rlcl9pZCA9IElETC5QcmluY2lwYWw7XG4gICAgY29uc3QgY2FuaXN0ZXJfaW5mb19hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCxcbiAgICAgICAgbnVtX3JlcXVlc3RlZF9jaGFuZ2VzOiBJREwuT3B0KElETC5OYXQ2NCksXG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlX29yaWdpbiA9IElETC5WYXJpYW50KHtcbiAgICAgICAgZnJvbV91c2VyOiBJREwuUmVjb3JkKHsgdXNlcl9pZDogSURMLlByaW5jaXBhbCB9KSxcbiAgICAgICAgZnJvbV9jYW5pc3RlcjogSURMLlJlY29yZCh7XG4gICAgICAgICAgICBjYW5pc3Rlcl92ZXJzaW9uOiBJREwuT3B0KElETC5OYXQ2NCksXG4gICAgICAgICAgICBjYW5pc3Rlcl9pZDogSURMLlByaW5jaXBhbCxcbiAgICAgICAgfSksXG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlX2RldGFpbHMgPSBJREwuVmFyaWFudCh7XG4gICAgICAgIGNyZWF0aW9uOiBJREwuUmVjb3JkKHsgY29udHJvbGxlcnM6IElETC5WZWMoSURMLlByaW5jaXBhbCkgfSksXG4gICAgICAgIGNvZGVfZGVwbG95bWVudDogSURMLlJlY29yZCh7XG4gICAgICAgICAgICBtb2RlOiBJREwuVmFyaWFudCh7XG4gICAgICAgICAgICAgICAgcmVpbnN0YWxsOiBJREwuTnVsbCxcbiAgICAgICAgICAgICAgICB1cGdyYWRlOiBJREwuTnVsbCxcbiAgICAgICAgICAgICAgICBpbnN0YWxsOiBJREwuTnVsbCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbW9kdWxlX2hhc2g6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICB9KSxcbiAgICAgICAgY29udHJvbGxlcnNfY2hhbmdlOiBJREwuUmVjb3JkKHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXJzOiBJREwuVmVjKElETC5QcmluY2lwYWwpLFxuICAgICAgICB9KSxcbiAgICAgICAgY29kZV91bmluc3RhbGw6IElETC5OdWxsLFxuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZSA9IElETC5SZWNvcmQoe1xuICAgICAgICB0aW1lc3RhbXBfbmFub3M6IElETC5OYXQ2NCxcbiAgICAgICAgY2FuaXN0ZXJfdmVyc2lvbjogSURMLk5hdDY0LFxuICAgICAgICBvcmlnaW46IGNoYW5nZV9vcmlnaW4sXG4gICAgICAgIGRldGFpbHM6IGNoYW5nZV9kZXRhaWxzLFxuICAgIH0pO1xuICAgIGNvbnN0IGNhbmlzdGVyX2luZm9fcmVzdWx0ID0gSURMLlJlY29yZCh7XG4gICAgICAgIGNvbnRyb2xsZXJzOiBJREwuVmVjKElETC5QcmluY2lwYWwpLFxuICAgICAgICBtb2R1bGVfaGFzaDogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXG4gICAgICAgIHJlY2VudF9jaGFuZ2VzOiBJREwuVmVjKGNoYW5nZSksXG4gICAgICAgIHRvdGFsX251bV9jaGFuZ2VzOiBJREwuTmF0NjQsXG4gICAgfSk7XG4gICAgY29uc3QgY2FuaXN0ZXJfc3RhdHVzX2FyZ3MgPSBJREwuUmVjb3JkKHsgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkIH0pO1xuICAgIGNvbnN0IGxvZ192aXNpYmlsaXR5ID0gSURMLlZhcmlhbnQoe1xuICAgICAgICBjb250cm9sbGVyczogSURMLk51bGwsXG4gICAgICAgIHB1YmxpYzogSURMLk51bGwsXG4gICAgfSk7XG4gICAgY29uc3QgZGVmaW5pdGVfY2FuaXN0ZXJfc2V0dGluZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgZnJlZXppbmdfdGhyZXNob2xkOiBJREwuTmF0LFxuICAgICAgICBjb250cm9sbGVyczogSURMLlZlYyhJREwuUHJpbmNpcGFsKSxcbiAgICAgICAgcmVzZXJ2ZWRfY3ljbGVzX2xpbWl0OiBJREwuTmF0LFxuICAgICAgICBsb2dfdmlzaWJpbGl0eTogbG9nX3Zpc2liaWxpdHksXG4gICAgICAgIHdhc21fbWVtb3J5X2xpbWl0OiBJREwuTmF0LFxuICAgICAgICBtZW1vcnlfYWxsb2NhdGlvbjogSURMLk5hdCxcbiAgICAgICAgY29tcHV0ZV9hbGxvY2F0aW9uOiBJREwuTmF0LFxuICAgIH0pO1xuICAgIGNvbnN0IGNhbmlzdGVyX3N0YXR1c19yZXN1bHQgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgc3RhdHVzOiBJREwuVmFyaWFudCh7XG4gICAgICAgICAgICBzdG9wcGVkOiBJREwuTnVsbCxcbiAgICAgICAgICAgIHN0b3BwaW5nOiBJREwuTnVsbCxcbiAgICAgICAgICAgIHJ1bm5pbmc6IElETC5OdWxsLFxuICAgICAgICB9KSxcbiAgICAgICAgbWVtb3J5X3NpemU6IElETC5OYXQsXG4gICAgICAgIGN5Y2xlczogSURMLk5hdCxcbiAgICAgICAgc2V0dGluZ3M6IGRlZmluaXRlX2NhbmlzdGVyX3NldHRpbmdzLFxuICAgICAgICBxdWVyeV9zdGF0czogSURMLlJlY29yZCh7XG4gICAgICAgICAgICByZXNwb25zZV9wYXlsb2FkX2J5dGVzX3RvdGFsOiBJREwuTmF0LFxuICAgICAgICAgICAgbnVtX2luc3RydWN0aW9uc190b3RhbDogSURMLk5hdCxcbiAgICAgICAgICAgIG51bV9jYWxsc190b3RhbDogSURMLk5hdCxcbiAgICAgICAgICAgIHJlcXVlc3RfcGF5bG9hZF9ieXRlc190b3RhbDogSURMLk5hdCxcbiAgICAgICAgfSksXG4gICAgICAgIGlkbGVfY3ljbGVzX2J1cm5lZF9wZXJfZGF5OiBJREwuTmF0LFxuICAgICAgICBtb2R1bGVfaGFzaDogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXG4gICAgICAgIHJlc2VydmVkX2N5Y2xlczogSURMLk5hdCxcbiAgICB9KTtcbiAgICBjb25zdCBjbGVhcl9jaHVua19zdG9yZV9hcmdzID0gSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KTtcbiAgICBjb25zdCBjYW5pc3Rlcl9zZXR0aW5ncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBmcmVlemluZ190aHJlc2hvbGQ6IElETC5PcHQoSURMLk5hdCksXG4gICAgICAgIGNvbnRyb2xsZXJzOiBJREwuT3B0KElETC5WZWMoSURMLlByaW5jaXBhbCkpLFxuICAgICAgICByZXNlcnZlZF9jeWNsZXNfbGltaXQ6IElETC5PcHQoSURMLk5hdCksXG4gICAgICAgIGxvZ192aXNpYmlsaXR5OiBJREwuT3B0KGxvZ192aXNpYmlsaXR5KSxcbiAgICAgICAgd2FzbV9tZW1vcnlfbGltaXQ6IElETC5PcHQoSURMLk5hdCksXG4gICAgICAgIG1lbW9yeV9hbGxvY2F0aW9uOiBJREwuT3B0KElETC5OYXQpLFxuICAgICAgICBjb21wdXRlX2FsbG9jYXRpb246IElETC5PcHQoSURMLk5hdCksXG4gICAgfSk7XG4gICAgY29uc3QgY3JlYXRlX2NhbmlzdGVyX2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgc2V0dGluZ3M6IElETC5PcHQoY2FuaXN0ZXJfc2V0dGluZ3MpLFxuICAgICAgICBzZW5kZXJfY2FuaXN0ZXJfdmVyc2lvbjogSURMLk9wdChJREwuTmF0NjQpLFxuICAgIH0pO1xuICAgIGNvbnN0IGNyZWF0ZV9jYW5pc3Rlcl9yZXN1bHQgPSBJREwuUmVjb3JkKHsgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkIH0pO1xuICAgIGNvbnN0IGRlbGV0ZV9jYW5pc3Rlcl9hcmdzID0gSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KTtcbiAgICBjb25zdCBkZXBvc2l0X2N5Y2xlc19hcmdzID0gSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KTtcbiAgICBjb25zdCBlY2RzYV9jdXJ2ZSA9IElETC5WYXJpYW50KHsgc2VjcDI1NmsxOiBJREwuTnVsbCB9KTtcbiAgICBjb25zdCBlY2RzYV9wdWJsaWNfa2V5X2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAga2V5X2lkOiBJREwuUmVjb3JkKHsgbmFtZTogSURMLlRleHQsIGN1cnZlOiBlY2RzYV9jdXJ2ZSB9KSxcbiAgICAgICAgY2FuaXN0ZXJfaWQ6IElETC5PcHQoY2FuaXN0ZXJfaWQpLFxuICAgICAgICBkZXJpdmF0aW9uX3BhdGg6IElETC5WZWMoSURMLlZlYyhJREwuTmF0OCkpLFxuICAgIH0pO1xuICAgIGNvbnN0IGVjZHNhX3B1YmxpY19rZXlfcmVzdWx0ID0gSURMLlJlY29yZCh7XG4gICAgICAgIHB1YmxpY19rZXk6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICBjaGFpbl9jb2RlOiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICB9KTtcbiAgICBjb25zdCBmZXRjaF9jYW5pc3Rlcl9sb2dzX2FyZ3MgPSBJREwuUmVjb3JkKHsgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkIH0pO1xuICAgIGNvbnN0IGNhbmlzdGVyX2xvZ19yZWNvcmQgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgaWR4OiBJREwuTmF0NjQsXG4gICAgICAgIHRpbWVzdGFtcF9uYW5vczogSURMLk5hdDY0LFxuICAgICAgICBjb250ZW50OiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICB9KTtcbiAgICBjb25zdCBmZXRjaF9jYW5pc3Rlcl9sb2dzX3Jlc3VsdCA9IElETC5SZWNvcmQoe1xuICAgICAgICBjYW5pc3Rlcl9sb2dfcmVjb3JkczogSURMLlZlYyhjYW5pc3Rlcl9sb2dfcmVjb3JkKSxcbiAgICB9KTtcbiAgICBjb25zdCBodHRwX2hlYWRlciA9IElETC5SZWNvcmQoeyB2YWx1ZTogSURMLlRleHQsIG5hbWU6IElETC5UZXh0IH0pO1xuICAgIGNvbnN0IGh0dHBfcmVxdWVzdF9yZXN1bHQgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgc3RhdHVzOiBJREwuTmF0LFxuICAgICAgICBib2R5OiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICAgICAgaGVhZGVyczogSURMLlZlYyhodHRwX2hlYWRlciksXG4gICAgfSk7XG4gICAgY29uc3QgaHR0cF9yZXF1ZXN0X2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgdXJsOiBJREwuVGV4dCxcbiAgICAgICAgbWV0aG9kOiBJREwuVmFyaWFudCh7XG4gICAgICAgICAgICBnZXQ6IElETC5OdWxsLFxuICAgICAgICAgICAgaGVhZDogSURMLk51bGwsXG4gICAgICAgICAgICBwb3N0OiBJREwuTnVsbCxcbiAgICAgICAgfSksXG4gICAgICAgIG1heF9yZXNwb25zZV9ieXRlczogSURMLk9wdChJREwuTmF0NjQpLFxuICAgICAgICBib2R5OiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcbiAgICAgICAgdHJhbnNmb3JtOiBJREwuT3B0KElETC5SZWNvcmQoe1xuICAgICAgICAgICAgZnVuY3Rpb246IElETC5GdW5jKFtcbiAgICAgICAgICAgICAgICBJREwuUmVjb3JkKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogSURMLlZlYyhJREwuTmF0OCksXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBodHRwX3JlcXVlc3RfcmVzdWx0LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSwgW2h0dHBfcmVxdWVzdF9yZXN1bHRdLCBbJ3F1ZXJ5J10pLFxuICAgICAgICAgICAgY29udGV4dDogSURMLlZlYyhJREwuTmF0OCksXG4gICAgICAgIH0pKSxcbiAgICAgICAgaGVhZGVyczogSURMLlZlYyhodHRwX2hlYWRlciksXG4gICAgfSk7XG4gICAgY29uc3QgY2FuaXN0ZXJfaW5zdGFsbF9tb2RlID0gSURMLlZhcmlhbnQoe1xuICAgICAgICByZWluc3RhbGw6IElETC5OdWxsLFxuICAgICAgICB1cGdyYWRlOiBJREwuT3B0KElETC5SZWNvcmQoe1xuICAgICAgICAgICAgd2FzbV9tZW1vcnlfcGVyc2lzdGVuY2U6IElETC5PcHQoSURMLlZhcmlhbnQoeyBrZWVwOiBJREwuTnVsbCwgcmVwbGFjZTogSURMLk51bGwgfSkpLFxuICAgICAgICAgICAgc2tpcF9wcmVfdXBncmFkZTogSURMLk9wdChJREwuQm9vbCksXG4gICAgICAgIH0pKSxcbiAgICAgICAgaW5zdGFsbDogSURMLk51bGwsXG4gICAgfSk7XG4gICAgY29uc3QgY2h1bmtfaGFzaCA9IElETC5SZWNvcmQoeyBoYXNoOiBJREwuVmVjKElETC5OYXQ4KSB9KTtcbiAgICBjb25zdCBpbnN0YWxsX2NodW5rZWRfY29kZV9hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIGFyZzogSURMLlZlYyhJREwuTmF0OCksXG4gICAgICAgIHdhc21fbW9kdWxlX2hhc2g6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICBtb2RlOiBjYW5pc3Rlcl9pbnN0YWxsX21vZGUsXG4gICAgICAgIGNodW5rX2hhc2hlc19saXN0OiBJREwuVmVjKGNodW5rX2hhc2gpLFxuICAgICAgICB0YXJnZXRfY2FuaXN0ZXI6IGNhbmlzdGVyX2lkLFxuICAgICAgICBzdG9yZV9jYW5pc3RlcjogSURMLk9wdChjYW5pc3Rlcl9pZCksXG4gICAgICAgIHNlbmRlcl9jYW5pc3Rlcl92ZXJzaW9uOiBJREwuT3B0KElETC5OYXQ2NCksXG4gICAgfSk7XG4gICAgY29uc3Qgd2FzbV9tb2R1bGUgPSBJREwuVmVjKElETC5OYXQ4KTtcbiAgICBjb25zdCBpbnN0YWxsX2NvZGVfYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBhcmc6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICB3YXNtX21vZHVsZTogd2FzbV9tb2R1bGUsXG4gICAgICAgIG1vZGU6IGNhbmlzdGVyX2luc3RhbGxfbW9kZSxcbiAgICAgICAgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkLFxuICAgICAgICBzZW5kZXJfY2FuaXN0ZXJfdmVyc2lvbjogSURMLk9wdChJREwuTmF0NjQpLFxuICAgIH0pO1xuICAgIGNvbnN0IG5vZGVfbWV0cmljc19oaXN0b3J5X2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgc3RhcnRfYXRfdGltZXN0YW1wX25hbm9zOiBJREwuTmF0NjQsXG4gICAgICAgIHN1Ym5ldF9pZDogSURMLlByaW5jaXBhbCxcbiAgICB9KTtcbiAgICBjb25zdCBub2RlX21ldHJpY3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgbnVtX2Jsb2NrX2ZhaWx1cmVzX3RvdGFsOiBJREwuTmF0NjQsXG4gICAgICAgIG5vZGVfaWQ6IElETC5QcmluY2lwYWwsXG4gICAgICAgIG51bV9ibG9ja3NfcHJvcG9zZWRfdG90YWw6IElETC5OYXQ2NCxcbiAgICB9KTtcbiAgICBjb25zdCBub2RlX21ldHJpY3NfaGlzdG9yeV9yZXN1bHQgPSBJREwuVmVjKElETC5SZWNvcmQoe1xuICAgICAgICB0aW1lc3RhbXBfbmFub3M6IElETC5OYXQ2NCxcbiAgICAgICAgbm9kZV9tZXRyaWNzOiBJREwuVmVjKG5vZGVfbWV0cmljcyksXG4gICAgfSkpO1xuICAgIGNvbnN0IHByb3Zpc2lvbmFsX2NyZWF0ZV9jYW5pc3Rlcl93aXRoX2N5Y2xlc19hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIHNldHRpbmdzOiBJREwuT3B0KGNhbmlzdGVyX3NldHRpbmdzKSxcbiAgICAgICAgc3BlY2lmaWVkX2lkOiBJREwuT3B0KGNhbmlzdGVyX2lkKSxcbiAgICAgICAgYW1vdW50OiBJREwuT3B0KElETC5OYXQpLFxuICAgICAgICBzZW5kZXJfY2FuaXN0ZXJfdmVyc2lvbjogSURMLk9wdChJREwuTmF0NjQpLFxuICAgIH0pO1xuICAgIGNvbnN0IHByb3Zpc2lvbmFsX2NyZWF0ZV9jYW5pc3Rlcl93aXRoX2N5Y2xlc19yZXN1bHQgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkLFxuICAgIH0pO1xuICAgIGNvbnN0IHByb3Zpc2lvbmFsX3RvcF91cF9jYW5pc3Rlcl9hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCxcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxuICAgIH0pO1xuICAgIGNvbnN0IHJhd19yYW5kX3Jlc3VsdCA9IElETC5WZWMoSURMLk5hdDgpO1xuICAgIGNvbnN0IHNjaG5vcnJfYWxnb3JpdGhtID0gSURMLlZhcmlhbnQoe1xuICAgICAgICBlZDI1NTE5OiBJREwuTnVsbCxcbiAgICAgICAgYmlwMzQwc2VjcDI1NmsxOiBJREwuTnVsbCxcbiAgICB9KTtcbiAgICBjb25zdCBzY2hub3JyX3B1YmxpY19rZXlfYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBrZXlfaWQ6IElETC5SZWNvcmQoe1xuICAgICAgICAgICAgYWxnb3JpdGhtOiBzY2hub3JyX2FsZ29yaXRobSxcbiAgICAgICAgICAgIG5hbWU6IElETC5UZXh0LFxuICAgICAgICB9KSxcbiAgICAgICAgY2FuaXN0ZXJfaWQ6IElETC5PcHQoY2FuaXN0ZXJfaWQpLFxuICAgICAgICBkZXJpdmF0aW9uX3BhdGg6IElETC5WZWMoSURMLlZlYyhJREwuTmF0OCkpLFxuICAgIH0pO1xuICAgIGNvbnN0IHNjaG5vcnJfcHVibGljX2tleV9yZXN1bHQgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgcHVibGljX2tleTogSURMLlZlYyhJREwuTmF0OCksXG4gICAgICAgIGNoYWluX2NvZGU6IElETC5WZWMoSURMLk5hdDgpLFxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25fd2l0aF9lY2RzYV9hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIGtleV9pZDogSURMLlJlY29yZCh7IG5hbWU6IElETC5UZXh0LCBjdXJ2ZTogZWNkc2FfY3VydmUgfSksXG4gICAgICAgIGRlcml2YXRpb25fcGF0aDogSURMLlZlYyhJREwuVmVjKElETC5OYXQ4KSksXG4gICAgICAgIG1lc3NhZ2VfaGFzaDogSURMLlZlYyhJREwuTmF0OCksXG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbl93aXRoX2VjZHNhX3Jlc3VsdCA9IElETC5SZWNvcmQoe1xuICAgICAgICBzaWduYXR1cmU6IElETC5WZWMoSURMLk5hdDgpLFxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25fd2l0aF9zY2hub3JyX2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAga2V5X2lkOiBJREwuUmVjb3JkKHtcbiAgICAgICAgICAgIGFsZ29yaXRobTogc2Nobm9ycl9hbGdvcml0aG0sXG4gICAgICAgICAgICBuYW1lOiBJREwuVGV4dCxcbiAgICAgICAgfSksXG4gICAgICAgIGRlcml2YXRpb25fcGF0aDogSURMLlZlYyhJREwuVmVjKElETC5OYXQ4KSksXG4gICAgICAgIG1lc3NhZ2U6IElETC5WZWMoSURMLk5hdDgpLFxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25fd2l0aF9zY2hub3JyX3Jlc3VsdCA9IElETC5SZWNvcmQoe1xuICAgICAgICBzaWduYXR1cmU6IElETC5WZWMoSURMLk5hdDgpLFxuICAgIH0pO1xuICAgIGNvbnN0IHN0YXJ0X2NhbmlzdGVyX2FyZ3MgPSBJREwuUmVjb3JkKHsgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkIH0pO1xuICAgIGNvbnN0IHN0b3BfY2FuaXN0ZXJfYXJncyA9IElETC5SZWNvcmQoeyBjYW5pc3Rlcl9pZDogY2FuaXN0ZXJfaWQgfSk7XG4gICAgY29uc3Qgc3RvcmVkX2NodW5rc19hcmdzID0gSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KTtcbiAgICBjb25zdCBzdG9yZWRfY2h1bmtzX3Jlc3VsdCA9IElETC5WZWMoY2h1bmtfaGFzaCk7XG4gICAgY29uc3QgdW5pbnN0YWxsX2NvZGVfYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBjYW5pc3Rlcl9pZDogY2FuaXN0ZXJfaWQsXG4gICAgICAgIHNlbmRlcl9jYW5pc3Rlcl92ZXJzaW9uOiBJREwuT3B0KElETC5OYXQ2NCksXG4gICAgfSk7XG4gICAgY29uc3QgdXBkYXRlX3NldHRpbmdzX2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgY2FuaXN0ZXJfaWQ6IElETC5QcmluY2lwYWwsXG4gICAgICAgIHNldHRpbmdzOiBjYW5pc3Rlcl9zZXR0aW5ncyxcbiAgICAgICAgc2VuZGVyX2NhbmlzdGVyX3ZlcnNpb246IElETC5PcHQoSURMLk5hdDY0KSxcbiAgICB9KTtcbiAgICBjb25zdCB1cGxvYWRfY2h1bmtfYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBjaHVuazogSURMLlZlYyhJREwuTmF0OCksXG4gICAgICAgIGNhbmlzdGVyX2lkOiBJREwuUHJpbmNpcGFsLFxuICAgIH0pO1xuICAgIGNvbnN0IHVwbG9hZF9jaHVua19yZXN1bHQgPSBjaHVua19oYXNoO1xuICAgIHJldHVybiBJREwuU2VydmljZSh7XG4gICAgICAgIGJpdGNvaW5fZ2V0X2JhbGFuY2U6IElETC5GdW5jKFtiaXRjb2luX2dldF9iYWxhbmNlX2FyZ3NdLCBbYml0Y29pbl9nZXRfYmFsYW5jZV9yZXN1bHRdLCBbXSksXG4gICAgICAgIGJpdGNvaW5fZ2V0X2N1cnJlbnRfZmVlX3BlcmNlbnRpbGVzOiBJREwuRnVuYyhbYml0Y29pbl9nZXRfY3VycmVudF9mZWVfcGVyY2VudGlsZXNfYXJnc10sIFtiaXRjb2luX2dldF9jdXJyZW50X2ZlZV9wZXJjZW50aWxlc19yZXN1bHRdLCBbXSksXG4gICAgICAgIGJpdGNvaW5fZ2V0X3V0eG9zOiBJREwuRnVuYyhbYml0Y29pbl9nZXRfdXR4b3NfYXJnc10sIFtiaXRjb2luX2dldF91dHhvc19yZXN1bHRdLCBbXSksXG4gICAgICAgIGJpdGNvaW5fc2VuZF90cmFuc2FjdGlvbjogSURMLkZ1bmMoW2JpdGNvaW5fc2VuZF90cmFuc2FjdGlvbl9hcmdzXSwgW10sIFtdKSxcbiAgICAgICAgY2FuaXN0ZXJfaW5mbzogSURMLkZ1bmMoW2NhbmlzdGVyX2luZm9fYXJnc10sIFtjYW5pc3Rlcl9pbmZvX3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgY2FuaXN0ZXJfc3RhdHVzOiBJREwuRnVuYyhbY2FuaXN0ZXJfc3RhdHVzX2FyZ3NdLCBbY2FuaXN0ZXJfc3RhdHVzX3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgY2xlYXJfY2h1bmtfc3RvcmU6IElETC5GdW5jKFtjbGVhcl9jaHVua19zdG9yZV9hcmdzXSwgW10sIFtdKSxcbiAgICAgICAgY3JlYXRlX2NhbmlzdGVyOiBJREwuRnVuYyhbY3JlYXRlX2NhbmlzdGVyX2FyZ3NdLCBbY3JlYXRlX2NhbmlzdGVyX3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgZGVsZXRlX2NhbmlzdGVyOiBJREwuRnVuYyhbZGVsZXRlX2NhbmlzdGVyX2FyZ3NdLCBbXSwgW10pLFxuICAgICAgICBkZXBvc2l0X2N5Y2xlczogSURMLkZ1bmMoW2RlcG9zaXRfY3ljbGVzX2FyZ3NdLCBbXSwgW10pLFxuICAgICAgICBlY2RzYV9wdWJsaWNfa2V5OiBJREwuRnVuYyhbZWNkc2FfcHVibGljX2tleV9hcmdzXSwgW2VjZHNhX3B1YmxpY19rZXlfcmVzdWx0XSwgW10pLFxuICAgICAgICBmZXRjaF9jYW5pc3Rlcl9sb2dzOiBJREwuRnVuYyhbZmV0Y2hfY2FuaXN0ZXJfbG9nc19hcmdzXSwgW2ZldGNoX2NhbmlzdGVyX2xvZ3NfcmVzdWx0XSwgWydxdWVyeSddKSxcbiAgICAgICAgaHR0cF9yZXF1ZXN0OiBJREwuRnVuYyhbaHR0cF9yZXF1ZXN0X2FyZ3NdLCBbaHR0cF9yZXF1ZXN0X3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgaW5zdGFsbF9jaHVua2VkX2NvZGU6IElETC5GdW5jKFtpbnN0YWxsX2NodW5rZWRfY29kZV9hcmdzXSwgW10sIFtdKSxcbiAgICAgICAgaW5zdGFsbF9jb2RlOiBJREwuRnVuYyhbaW5zdGFsbF9jb2RlX2FyZ3NdLCBbXSwgW10pLFxuICAgICAgICBub2RlX21ldHJpY3NfaGlzdG9yeTogSURMLkZ1bmMoW25vZGVfbWV0cmljc19oaXN0b3J5X2FyZ3NdLCBbbm9kZV9tZXRyaWNzX2hpc3RvcnlfcmVzdWx0XSwgW10pLFxuICAgICAgICBwcm92aXNpb25hbF9jcmVhdGVfY2FuaXN0ZXJfd2l0aF9jeWNsZXM6IElETC5GdW5jKFtwcm92aXNpb25hbF9jcmVhdGVfY2FuaXN0ZXJfd2l0aF9jeWNsZXNfYXJnc10sIFtwcm92aXNpb25hbF9jcmVhdGVfY2FuaXN0ZXJfd2l0aF9jeWNsZXNfcmVzdWx0XSwgW10pLFxuICAgICAgICBwcm92aXNpb25hbF90b3BfdXBfY2FuaXN0ZXI6IElETC5GdW5jKFtwcm92aXNpb25hbF90b3BfdXBfY2FuaXN0ZXJfYXJnc10sIFtdLCBbXSksXG4gICAgICAgIHJhd19yYW5kOiBJREwuRnVuYyhbXSwgW3Jhd19yYW5kX3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgc2Nobm9ycl9wdWJsaWNfa2V5OiBJREwuRnVuYyhbc2Nobm9ycl9wdWJsaWNfa2V5X2FyZ3NdLCBbc2Nobm9ycl9wdWJsaWNfa2V5X3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgc2lnbl93aXRoX2VjZHNhOiBJREwuRnVuYyhbc2lnbl93aXRoX2VjZHNhX2FyZ3NdLCBbc2lnbl93aXRoX2VjZHNhX3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgc2lnbl93aXRoX3NjaG5vcnI6IElETC5GdW5jKFtzaWduX3dpdGhfc2Nobm9ycl9hcmdzXSwgW3NpZ25fd2l0aF9zY2hub3JyX3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgc3RhcnRfY2FuaXN0ZXI6IElETC5GdW5jKFtzdGFydF9jYW5pc3Rlcl9hcmdzXSwgW10sIFtdKSxcbiAgICAgICAgc3RvcF9jYW5pc3RlcjogSURMLkZ1bmMoW3N0b3BfY2FuaXN0ZXJfYXJnc10sIFtdLCBbXSksXG4gICAgICAgIHN0b3JlZF9jaHVua3M6IElETC5GdW5jKFtzdG9yZWRfY2h1bmtzX2FyZ3NdLCBbc3RvcmVkX2NodW5rc19yZXN1bHRdLCBbXSksXG4gICAgICAgIHVuaW5zdGFsbF9jb2RlOiBJREwuRnVuYyhbdW5pbnN0YWxsX2NvZGVfYXJnc10sIFtdLCBbXSksXG4gICAgICAgIHVwZGF0ZV9zZXR0aW5nczogSURMLkZ1bmMoW3VwZGF0ZV9zZXR0aW5nc19hcmdzXSwgW10sIFtdKSxcbiAgICAgICAgdXBsb2FkX2NodW5rOiBJREwuRnVuYyhbdXBsb2FkX2NodW5rX2FyZ3NdLCBbdXBsb2FkX2NodW5rX3Jlc3VsdF0sIFtdKSxcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYW5hZ2VtZW50X2lkbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/cbor.js":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/cbor.js ***!
  \**********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CborTag: () => (/* binding */ CborTag),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! borc */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! simple-cbor */ \"./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n// This file is based on:\n// https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses\n\n\n\n\n// We are using hansl/simple-cbor for CBOR serialization, to avoid issues with\n// encoding the uint64 values that the HTTP handler of the client expects for\n// canister IDs. However, simple-cbor does not yet provide deserialization so\n// we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR\n// decoder.\nclass PrincipalEncoder {\n    get name() {\n        return 'Principal';\n    }\n    get priority() {\n        return 0;\n    }\n    match(value) {\n        return value && value._isPrincipal === true;\n    }\n    encode(v) {\n        return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes(v.toUint8Array());\n    }\n}\nclass BufferEncoder {\n    get name() {\n        return 'Buffer';\n    }\n    get priority() {\n        return 1;\n    }\n    match(value) {\n        return value instanceof ArrayBuffer || ArrayBuffer.isView(value);\n    }\n    encode(v) {\n        return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes(new Uint8Array(v));\n    }\n}\nclass BigIntEncoder {\n    get name() {\n        return 'BigInt';\n    }\n    get priority() {\n        return 1;\n    }\n    match(value) {\n        return typeof value === `bigint`;\n    }\n    encode(v) {\n        // Always use a bigint encoding.\n        if (v > BigInt(0)) {\n            return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.tagged(2, simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.fromHex)(v.toString(16))));\n        }\n        else {\n            return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.tagged(3, simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.fromHex)((BigInt('-1') * v).toString(16))));\n        }\n    }\n}\nconst serializer = simple_cbor__WEBPACK_IMPORTED_MODULE_1__.SelfDescribeCborSerializer.withDefaultEncoders(true);\nserializer.addEncoder(new PrincipalEncoder());\nserializer.addEncoder(new BufferEncoder());\nserializer.addEncoder(new BigIntEncoder());\nvar CborTag;\n(function (CborTag) {\n    CborTag[CborTag[\"Uint64LittleEndian\"] = 71] = \"Uint64LittleEndian\";\n    CborTag[CborTag[\"Semantic\"] = 55799] = \"Semantic\";\n})(CborTag || (CborTag = {}));\n/**\n * Encode a JavaScript value into CBOR.\n */\nfunction encode(value) {\n    return serializer.serialize(value);\n}\nfunction decodePositiveBigInt(buf) {\n    const len = buf.byteLength;\n    let res = BigInt(0);\n    for (let i = 0; i < len; i++) {\n        res = res * BigInt(0x100) + BigInt(buf[i]);\n    }\n    return res;\n}\n// A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.\nclass Uint8ArrayDecoder extends borc__WEBPACK_IMPORTED_MODULE_0__.Decoder {\n    createByteString(raw) {\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...raw);\n    }\n    createByteStringFromHeap(start, end) {\n        if (start === end) {\n            return new ArrayBuffer(0);\n        }\n        return new Uint8Array(this._heap.slice(start, end));\n    }\n}\nfunction decode(input) {\n    const buffer = new Uint8Array(input);\n    const decoder = new Uint8ArrayDecoder({\n        size: buffer.byteLength,\n        tags: {\n            // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).\n            2: val => decodePositiveBigInt(val),\n            3: val => -decodePositiveBigInt(val),\n            [CborTag.Semantic]: (value) => value,\n        },\n    });\n    try {\n        return decoder.decodeFirst(buffer);\n    }\n    catch (e) {\n        throw new Error(`Failed to decode CBOR: ${e}, input: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(buffer)}`);\n    }\n}\n//# sourceMappingURL=cbor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Nib3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDd0I7QUFDWTtBQUNxQjtBQUNEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFVLFdBQVcsOENBQVUsT0FBTyxzREFBTztBQUNoRTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFVLFdBQVcsOENBQVUsT0FBTyxzREFBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUVBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5Q0FBWTtBQUM1QztBQUNBLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRSxXQUFXLG9EQUFLLFNBQVM7QUFDN0U7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2FnZW50QDIuMS4zX0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjNfX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9jYm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbjpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmluaXR5LWxhYi9kZmluaXR5L2Jsb2IvOWJjYTY1ZjhlZGQ2NTcwMWVhNmJkYjAwZTA3NTJmOTE4NmJiYzg5My9kb2NzL3NwZWMvcHVibGljL2luZGV4LmFkb2MjY2Jvci1lbmNvZGluZy1vZi1yZXF1ZXN0cy1hbmQtcmVzcG9uc2VzXG5pbXBvcnQgYm9yYyBmcm9tICdib3JjJztcbmltcG9ydCAqIGFzIGNib3IgZnJvbSAnc2ltcGxlLWNib3InO1xuaW1wb3J0IHsgU2VsZkRlc2NyaWJlQ2JvclNlcmlhbGl6ZXIgfSBmcm9tICdzaW1wbGUtY2Jvcic7XG5pbXBvcnQgeyBjb25jYXQsIGZyb21IZXgsIHRvSGV4IH0gZnJvbSAnLi91dGlscy9idWZmZXInO1xuLy8gV2UgYXJlIHVzaW5nIGhhbnNsL3NpbXBsZS1jYm9yIGZvciBDQk9SIHNlcmlhbGl6YXRpb24sIHRvIGF2b2lkIGlzc3VlcyB3aXRoXG4vLyBlbmNvZGluZyB0aGUgdWludDY0IHZhbHVlcyB0aGF0IHRoZSBIVFRQIGhhbmRsZXIgb2YgdGhlIGNsaWVudCBleHBlY3RzIGZvclxuLy8gY2FuaXN0ZXIgSURzLiBIb3dldmVyLCBzaW1wbGUtY2JvciBkb2VzIG5vdCB5ZXQgcHJvdmlkZSBkZXNlcmlhbGl6YXRpb24gc29cbi8vIHdlIGFyZSB1c2luZyBgVWludDhBcnJheWAgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZSBkaWduaWZpZWRxdWlyZS9ib3JjIENCT1Jcbi8vIGRlY29kZXIuXG5jbGFzcyBQcmluY2lwYWxFbmNvZGVyIHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdQcmluY2lwYWwnO1xuICAgIH1cbiAgICBnZXQgcHJpb3JpdHkoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBtYXRjaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX2lzUHJpbmNpcGFsID09PSB0cnVlO1xuICAgIH1cbiAgICBlbmNvZGUodikge1xuICAgICAgICByZXR1cm4gY2Jvci52YWx1ZS5ieXRlcyh2LnRvVWludDhBcnJheSgpKTtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJFbmNvZGVyIHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdCdWZmZXInO1xuICAgIH1cbiAgICBnZXQgcHJpb3JpdHkoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBtYXRjaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICAgIH1cbiAgICBlbmNvZGUodikge1xuICAgICAgICByZXR1cm4gY2Jvci52YWx1ZS5ieXRlcyhuZXcgVWludDhBcnJheSh2KSk7XG4gICAgfVxufVxuY2xhc3MgQmlnSW50RW5jb2RlciB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQmlnSW50JztcbiAgICB9XG4gICAgZ2V0IHByaW9yaXR5KCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gYGJpZ2ludGA7XG4gICAgfVxuICAgIGVuY29kZSh2KSB7XG4gICAgICAgIC8vIEFsd2F5cyB1c2UgYSBiaWdpbnQgZW5jb2RpbmcuXG4gICAgICAgIGlmICh2ID4gQmlnSW50KDApKSB7XG4gICAgICAgICAgICByZXR1cm4gY2Jvci52YWx1ZS50YWdnZWQoMiwgY2Jvci52YWx1ZS5ieXRlcyhmcm9tSGV4KHYudG9TdHJpbmcoMTYpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNib3IudmFsdWUudGFnZ2VkKDMsIGNib3IudmFsdWUuYnl0ZXMoZnJvbUhleCgoQmlnSW50KCctMScpICogdikudG9TdHJpbmcoMTYpKSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3Qgc2VyaWFsaXplciA9IFNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyLndpdGhEZWZhdWx0RW5jb2RlcnModHJ1ZSk7XG5zZXJpYWxpemVyLmFkZEVuY29kZXIobmV3IFByaW5jaXBhbEVuY29kZXIoKSk7XG5zZXJpYWxpemVyLmFkZEVuY29kZXIobmV3IEJ1ZmZlckVuY29kZXIoKSk7XG5zZXJpYWxpemVyLmFkZEVuY29kZXIobmV3IEJpZ0ludEVuY29kZXIoKSk7XG5leHBvcnQgdmFyIENib3JUYWc7XG4oZnVuY3Rpb24gKENib3JUYWcpIHtcbiAgICBDYm9yVGFnW0Nib3JUYWdbXCJVaW50NjRMaXR0bGVFbmRpYW5cIl0gPSA3MV0gPSBcIlVpbnQ2NExpdHRsZUVuZGlhblwiO1xuICAgIENib3JUYWdbQ2JvclRhZ1tcIlNlbWFudGljXCJdID0gNTU3OTldID0gXCJTZW1hbnRpY1wiO1xufSkoQ2JvclRhZyB8fCAoQ2JvclRhZyA9IHt9KSk7XG4vKipcbiAqIEVuY29kZSBhIEphdmFTY3JpcHQgdmFsdWUgaW50byBDQk9SLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVBvc2l0aXZlQmlnSW50KGJ1Zikge1xuICAgIGNvbnN0IGxlbiA9IGJ1Zi5ieXRlTGVuZ3RoO1xuICAgIGxldCByZXMgPSBCaWdJbnQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXMgPSByZXMgKiBCaWdJbnQoMHgxMDApICsgQmlnSW50KGJ1ZltpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBBIEJPUkMgc3ViY2xhc3MgdGhhdCBkZWNvZGVzIGJ5dGUgc3RyaW5ncyB0byBBcnJheUJ1ZmZlciBpbnN0ZWFkIG9mIHRoZSBCdWZmZXIgY2xhc3MuXG5jbGFzcyBVaW50OEFycmF5RGVjb2RlciBleHRlbmRzIGJvcmMuRGVjb2RlciB7XG4gICAgY3JlYXRlQnl0ZVN0cmluZyhyYXcpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCguLi5yYXcpO1xuICAgIH1cbiAgICBjcmVhdGVCeXRlU3RyaW5nRnJvbUhlYXAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5faGVhcC5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFVpbnQ4QXJyYXlEZWNvZGVyKHtcbiAgICAgICAgc2l6ZTogYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgIHRhZ3M6IHtcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRhZ3MgMiBhbmQgMyBmb3IgQmlnSW50IHN1cHBvcnQgKGJvcmMgc3VwcG9ydHMgb25seSBCaWdOdW1iZXIpLlxuICAgICAgICAgICAgMjogdmFsID0+IGRlY29kZVBvc2l0aXZlQmlnSW50KHZhbCksXG4gICAgICAgICAgICAzOiB2YWwgPT4gLWRlY29kZVBvc2l0aXZlQmlnSW50KHZhbCksXG4gICAgICAgICAgICBbQ2JvclRhZy5TZW1hbnRpY106ICh2YWx1ZSkgPT4gdmFsdWUsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlRmlyc3QoYnVmZmVyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVjb2RlIENCT1I6ICR7ZX0sIGlucHV0OiAke3RvSGV4KGJ1ZmZlcil9YCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2Jvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/cbor.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/certificate.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/certificate.js ***!
  \*****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Certificate: () => (/* binding */ Certificate),\n/* harmony export */   CertificateVerificationError: () => (/* binding */ CertificateVerificationError),\n/* harmony export */   LookupStatus: () => (/* binding */ LookupStatus),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   check_canister_ranges: () => (/* binding */ check_canister_ranges),\n/* harmony export */   find_label: () => (/* binding */ find_label),\n/* harmony export */   flatten_forks: () => (/* binding */ flatten_forks),\n/* harmony export */   hashTreeToString: () => (/* binding */ hashTreeToString),\n/* harmony export */   lookupResultToBuffer: () => (/* binding */ lookupResultToBuffer),\n/* harmony export */   lookup_path: () => (/* binding */ lookup_path),\n/* harmony export */   reconstruct: () => (/* binding */ reconstruct)\n/* harmony export */ });\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./request_id */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dfinity/principal */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _utils_bls__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/bls */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/bls.js\");\n/* harmony import */ var _utils_leb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/leb */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./agent */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/index.js\");\n\n\n\n\n\n\n\n\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nclass CertificateVerificationError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {\n    constructor(reason) {\n        super(`Invalid certificate: ${reason}`);\n    }\n}\nvar NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Empty\"] = 0] = \"Empty\";\n    NodeType[NodeType[\"Fork\"] = 1] = \"Fork\";\n    NodeType[NodeType[\"Labeled\"] = 2] = \"Labeled\";\n    NodeType[NodeType[\"Leaf\"] = 3] = \"Leaf\";\n    NodeType[NodeType[\"Pruned\"] = 4] = \"Pruned\";\n})(NodeType || (NodeType = {}));\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nfunction hashTreeToString(tree) {\n    const indent = (s) => s\n        .split('\\n')\n        .map(x => '  ' + x)\n        .join('\\n');\n    function labelToString(label) {\n        const decoder = new TextDecoder(undefined, { fatal: true });\n        try {\n            return JSON.stringify(decoder.decode(label));\n        }\n        catch (e) {\n            return `data(...${label.byteLength} bytes)`;\n        }\n    }\n    switch (tree[0]) {\n        case NodeType.Empty:\n            return '()';\n        case NodeType.Fork: {\n            if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {\n                const left = hashTreeToString(tree[1]);\n                const right = hashTreeToString(tree[2]);\n                return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n            }\n            else {\n                throw new Error('Invalid tree structure for fork');\n            }\n        }\n        case NodeType.Labeled: {\n            if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {\n                const label = labelToString(tree[1]);\n                const sub = hashTreeToString(tree[2]);\n                return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n            }\n            else {\n                throw new Error('Invalid tree structure for labeled');\n            }\n        }\n        case NodeType.Leaf: {\n            if (!tree[1]) {\n                throw new Error('Invalid tree structure for leaf');\n            }\n            else if (Array.isArray(tree[1])) {\n                return JSON.stringify(tree[1]);\n            }\n            return `leaf(...${tree[1].byteLength} bytes)`;\n        }\n        case NodeType.Pruned: {\n            if (!tree[1]) {\n                throw new Error('Invalid tree structure for pruned');\n            }\n            else if (Array.isArray(tree[1])) {\n                return JSON.stringify(tree[1]);\n            }\n            return `pruned(${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(new Uint8Array(tree[1]))}`;\n        }\n        default: {\n            return `unknown(${JSON.stringify(tree[0])})`;\n        }\n    }\n}\nfunction isBufferGreaterThan(a, b) {\n    const a8 = new Uint8Array(a);\n    const b8 = new Uint8Array(b);\n    for (let i = 0; i < a8.length; i++) {\n        if (a8[i] > b8[i]) {\n            return true;\n        }\n    }\n    return false;\n}\nclass Certificate {\n    constructor(certificate, _rootKey, _canisterId, _blsVerify, \n    // Default to 5 minutes\n    _maxAgeInMinutes = 5) {\n        this._rootKey = _rootKey;\n        this._canisterId = _canisterId;\n        this._blsVerify = _blsVerify;\n        this._maxAgeInMinutes = _maxAgeInMinutes;\n        this.cert = _cbor__WEBPACK_IMPORTED_MODULE_0__.decode(new Uint8Array(certificate));\n    }\n    /**\n     * Create a new instance of a certificate, automatically verifying it. Throws a\n     * CertificateVerificationError if the certificate cannot be verified.\n     * @constructs  Certificate\n     * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n     * @param {ArrayBuffer} options.certificate The bytes of the certificate\n     * @param {ArrayBuffer} options.rootKey The root key to verify against\n     * @param {Principal} options.canisterId The effective or signing canister ID\n     * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n     * @throws {CertificateVerificationError}\n     */\n    static async create(options) {\n        const cert = Certificate.createUnverified(options);\n        await cert.verify();\n        return cert;\n    }\n    static createUnverified(options) {\n        let blsVerify = options.blsVerify;\n        if (!blsVerify) {\n            blsVerify = _utils_bls__WEBPACK_IMPORTED_MODULE_5__.blsVerify;\n        }\n        return new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify, options.maxAgeInMinutes);\n    }\n    lookup(path) {\n        // constrain the type of the result, so that empty HashTree is undefined\n        return lookup_path(path, this.cert.tree);\n    }\n    lookup_label(label) {\n        return this.lookup([label]);\n    }\n    async verify() {\n        const rootHash = await reconstruct(this.cert.tree);\n        const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n        const sig = this.cert.signature;\n        const key = extractDER(derKey);\n        const msg = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-state-root'), rootHash);\n        let sigVer = false;\n        const lookupTime = lookupResultToBuffer(this.lookup(['time']));\n        if (!lookupTime) {\n            // Should never happen - time is always present in IC certificates\n            throw new CertificateVerificationError('Certificate does not contain a time');\n        }\n        const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n        const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n        const now = Date.now();\n        const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n        const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n        const certTime = (0,_utils_leb__WEBPACK_IMPORTED_MODULE_6__.decodeTime)(lookupTime);\n        if (certTime.getTime() < earliestCertificateTime) {\n            throw new CertificateVerificationError(`Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` +\n                certTime.toISOString() +\n                ' Current time: ' +\n                new Date(now).toISOString());\n        }\n        else if (certTime.getTime() > fiveMinutesFromNow) {\n            throw new CertificateVerificationError('Certificate is signed more than 5 minutes in the future. Certificate time: ' +\n                certTime.toISOString() +\n                ' Current time: ' +\n                new Date(now).toISOString());\n        }\n        try {\n            sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n        }\n        catch (err) {\n            sigVer = false;\n        }\n        if (!sigVer) {\n            throw new CertificateVerificationError('Signature verification failed');\n        }\n    }\n    async _checkDelegationAndGetKey(d) {\n        if (!d) {\n            return this._rootKey;\n        }\n        const cert = await Certificate.createUnverified({\n            certificate: d.certificate,\n            rootKey: this._rootKey,\n            canisterId: this._canisterId,\n            blsVerify: this._blsVerify,\n            // Do not check max age for delegation certificates\n            maxAgeInMinutes: Infinity,\n        });\n        if (cert.cert.delegation) {\n            throw new CertificateVerificationError('Delegation certificates cannot be nested');\n        }\n        await cert.verify();\n        if (this._canisterId.toString() !== _agent__WEBPACK_IMPORTED_MODULE_7__.MANAGEMENT_CANISTER_ID) {\n            const canisterInRange = check_canister_ranges({\n                canisterId: this._canisterId,\n                subnetId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n                tree: cert.cert.tree,\n            });\n            if (!canisterInRange) {\n                throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(d.subnet_id)}`);\n            }\n        }\n        const publicKeyLookup = lookupResultToBuffer(cert.lookup(['subnet', d.subnet_id, 'public_key']));\n        if (!publicKeyLookup) {\n            throw new Error(`Could not find subnet key for subnet 0x${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(d.subnet_id)}`);\n        }\n        return publicKeyLookup;\n    }\n}\nconst DER_PREFIX = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.fromHex)('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\nfunction extractDER(buf) {\n    const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n    if (buf.byteLength !== expectedLength) {\n        throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n    }\n    const prefix = buf.slice(0, DER_PREFIX.byteLength);\n    if (!(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.bufEquals)(prefix, DER_PREFIX)) {\n        throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);\n    }\n    return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * utility function to constrain the type of a path\n * @param {ArrayBuffer | HashTree | undefined} result - the result of a lookup\n * @returns ArrayBuffer or Undefined\n */\nfunction lookupResultToBuffer(result) {\n    if (result.status !== LookupStatus.Found) {\n        return undefined;\n    }\n    if (result.value instanceof ArrayBuffer) {\n        return result.value;\n    }\n    if (result.value instanceof Uint8Array) {\n        return result.value.buffer;\n    }\n    return undefined;\n}\n/**\n * @param t\n */\nasync function reconstruct(t) {\n    switch (t[0]) {\n        case NodeType.Empty:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)(domain_sep('ic-hashtree-empty'));\n        case NodeType.Pruned:\n            return t[1];\n        case NodeType.Leaf:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-leaf'), t[1]));\n        case NodeType.Labeled:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n        case NodeType.Fork:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction domain_sep(s) {\n    const len = new Uint8Array([s.length]);\n    const str = new TextEncoder().encode(s);\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(len, str);\n}\nvar LookupStatus;\n(function (LookupStatus) {\n    LookupStatus[\"Unknown\"] = \"unknown\";\n    LookupStatus[\"Absent\"] = \"absent\";\n    LookupStatus[\"Found\"] = \"found\";\n})(LookupStatus || (LookupStatus = {}));\nvar LabelLookupStatus;\n(function (LabelLookupStatus) {\n    LabelLookupStatus[\"Less\"] = \"less\";\n    LabelLookupStatus[\"Greater\"] = \"greater\";\n})(LabelLookupStatus || (LabelLookupStatus = {}));\nfunction lookup_path(path, tree) {\n    if (path.length === 0) {\n        switch (tree[0]) {\n            case NodeType.Leaf: {\n                if (!tree[1]) {\n                    throw new Error('Invalid tree structure for leaf');\n                }\n                if (tree[1] instanceof ArrayBuffer) {\n                    return {\n                        status: LookupStatus.Found,\n                        value: tree[1],\n                    };\n                }\n                if (tree[1] instanceof Uint8Array) {\n                    return {\n                        status: LookupStatus.Found,\n                        value: tree[1].buffer,\n                    };\n                }\n                return {\n                    status: LookupStatus.Found,\n                    value: tree[1],\n                };\n            }\n            default: {\n                return {\n                    status: LookupStatus.Found,\n                    value: tree,\n                };\n            }\n        }\n    }\n    const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n    const lookupResult = find_label(label, tree);\n    switch (lookupResult.status) {\n        case LookupStatus.Found: {\n            return lookup_path(path.slice(1), lookupResult.value);\n        }\n        case LabelLookupStatus.Greater:\n        case LabelLookupStatus.Less: {\n            return {\n                status: LookupStatus.Absent,\n            };\n        }\n        default: {\n            return lookupResult;\n        }\n    }\n}\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param t - the tree to flatten\n * @returns HashTree[] - the flattened tree\n */\nfunction flatten_forks(t) {\n    switch (t[0]) {\n        case NodeType.Empty:\n            return [];\n        case NodeType.Fork:\n            return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n        default:\n            return [t];\n    }\n}\nfunction find_label(label, tree) {\n    switch (tree[0]) {\n        // if we have a labelled node, compare the node's label to the one we are\n        // looking for\n        case NodeType.Labeled:\n            // if the label we're searching for is greater than this node's label,\n            // we need to keep searching\n            if (isBufferGreaterThan(label, tree[1])) {\n                return {\n                    status: LabelLookupStatus.Greater,\n                };\n            }\n            // if the label we're searching for is equal this node's label, we can\n            // stop searching and return the found node\n            if ((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.bufEquals)(label, tree[1])) {\n                return {\n                    status: LookupStatus.Found,\n                    value: tree[2],\n                };\n            }\n            // if the label we're searching for is not greater than or equal to this\n            // node's label, then it's less than this node's label, and we can stop\n            // searching because we've looked too far\n            return {\n                status: LabelLookupStatus.Less,\n            };\n        // if we have a fork node, we need to search both sides, starting with the left\n        case NodeType.Fork:\n            // search in the left node\n            const leftLookupResult = find_label(label, tree[1]);\n            switch (leftLookupResult.status) {\n                // if the label we're searching for is greater than the left node lookup,\n                // we need to search the right node\n                case LabelLookupStatus.Greater: {\n                    const rightLookupResult = find_label(label, tree[2]);\n                    // if the label we're searching for is less than the right node lookup,\n                    // then we can stop searching and say that the label is provably Absent\n                    if (rightLookupResult.status === LabelLookupStatus.Less) {\n                        return {\n                            status: LookupStatus.Absent,\n                        };\n                    }\n                    // if the label we're searching for is less than or equal to the right\n                    // node lookup, then we let the caller handle it\n                    return rightLookupResult;\n                }\n                // if the left node returns an uncertain result, we need to search the\n                // right node\n                case LookupStatus.Unknown: {\n                    let rightLookupResult = find_label(label, tree[2]);\n                    // if the label we're searching for is less than the right node lookup,\n                    // then we also need to return an uncertain result\n                    if (rightLookupResult.status === LabelLookupStatus.Less) {\n                        return {\n                            status: LookupStatus.Unknown,\n                        };\n                    }\n                    // if the label we're searching for is less than or equal to the right\n                    // node lookup, then we let the caller handle it\n                    return rightLookupResult;\n                }\n                // if the label we're searching for is not greater than the left node\n                // lookup, or the result is not uncertain, we stop searching and return\n                // whatever the result of the left node lookup was, which can be either\n                // Found or Absent\n                default: {\n                    return leftLookupResult;\n                }\n            }\n        // if we encounter a Pruned node, we can't know for certain if the label\n        // we're searching for is present or not\n        case NodeType.Pruned:\n            return {\n                status: LookupStatus.Unknown,\n            };\n        // if the current node is Empty, or a Leaf, we can stop searching because\n        // we know for sure that the label we're searching for is not present\n        default:\n            return {\n                status: LookupStatus.Absent,\n            };\n    }\n}\n/**\n * Check if a canister falls within a range of canisters\n * @param canisterId Principal\n * @param ranges [Principal, Principal][]\n * @returns\n */\nfunction check_canister_ranges(params) {\n    const { canisterId, subnetId, tree } = params;\n    const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n    if (rangeLookup.status !== LookupStatus.Found || !(rangeLookup.value instanceof ArrayBuffer)) {\n        throw new Error(`Could not find canister ranges for subnet ${subnetId}`);\n    }\n    const ranges_arr = _cbor__WEBPACK_IMPORTED_MODULE_0__.decode(rangeLookup.value);\n    const ranges = ranges_arr.map(v => [\n        _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(v[0]),\n        _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(v[1]),\n    ]);\n    const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n    return canisterInRange;\n}\n//# sourceMappingURL=certificate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NlcnRpZmljYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDTztBQUNGO0FBQytCO0FBQ3BCO0FBQ1o7QUFDTTtBQUNRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNPLDJDQUEyQywrQ0FBVTtBQUM1RDtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGFBQWE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhLGtCQUFrQixjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjLFdBQVcsWUFBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQUssMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCLFNBQVM7QUFDbEQsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQVU7QUFDbkM7QUFDQSxzRkFBc0YsdUJBQXVCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBEQUFzQjtBQUNsRTtBQUNBO0FBQ0EsMEJBQTBCLHlEQUFTO0FBQ25DO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUVBQW1FLGtCQUFrQiwyQ0FBMkMsb0RBQUssY0FBYztBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxvREFBSyxjQUFjO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBO0FBQ0EsU0FBUyx3REFBUztBQUNsQixtR0FBbUcsV0FBVyxZQUFZLE9BQU87QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsaURBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFJLENBQUMscURBQU07QUFDOUI7QUFDQSxtQkFBbUIsaURBQUksQ0FBQyxxREFBTTtBQUM5QjtBQUNBLG1CQUFtQixpREFBSSxDQUFDLHFEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBTTtBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQ3hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0EscUVBQXFFLFNBQVM7QUFDOUU7QUFDQSx1QkFBdUIseUNBQVc7QUFDbEM7QUFDQSxRQUFRLHlEQUFTO0FBQ2pCLFFBQVEseURBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2VydGlmaWNhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY2JvciBmcm9tICcuL2Nib3InO1xuaW1wb3J0IHsgQWdlbnRFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGhhc2ggfSBmcm9tICcuL3JlcXVlc3RfaWQnO1xuaW1wb3J0IHsgYnVmRXF1YWxzLCBjb25jYXQsIGZyb21IZXgsIHRvSGV4IH0gZnJvbSAnLi91dGlscy9idWZmZXInO1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCAqIGFzIGJscyBmcm9tICcuL3V0aWxzL2Jscyc7XG5pbXBvcnQgeyBkZWNvZGVUaW1lIH0gZnJvbSAnLi91dGlscy9sZWInO1xuaW1wb3J0IHsgTUFOQUdFTUVOVF9DQU5JU1RFUl9JRCB9IGZyb20gJy4vYWdlbnQnO1xuLyoqXG4gKiBBIGNlcnRpZmljYXRlIG1heSBmYWlsIHZlcmlmaWNhdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXlcbiAqL1xuZXhwb3J0IGNsYXNzIENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IgZXh0ZW5kcyBBZ2VudEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICAgICAgc3VwZXIoYEludmFsaWQgY2VydGlmaWNhdGU6ICR7cmVhc29ufWApO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgTm9kZVR5cGU7XG4oZnVuY3Rpb24gKE5vZGVUeXBlKSB7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJFbXB0eVwiXSA9IDBdID0gXCJFbXB0eVwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRm9ya1wiXSA9IDFdID0gXCJGb3JrXCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJMYWJlbGVkXCJdID0gMl0gPSBcIkxhYmVsZWRcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkxlYWZcIl0gPSAzXSA9IFwiTGVhZlwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiUHJ1bmVkXCJdID0gNF0gPSBcIlBydW5lZFwiO1xufSkoTm9kZVR5cGUgfHwgKE5vZGVUeXBlID0ge30pKTtcbi8qKlxuICogTWFrZSBhIGh1bWFuIHJlYWRhYmxlIHN0cmluZyBvdXQgb2YgYSBoYXNoIHRyZWUuXG4gKiBAcGFyYW0gdHJlZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRyZWVUb1N0cmluZyh0cmVlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gKHMpID0+IHNcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKHggPT4gJyAgJyArIHgpXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICBmdW5jdGlvbiBsYWJlbFRvU3RyaW5nKGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIodW5kZWZpbmVkLCB7IGZhdGFsOiB0cnVlIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlY29kZXIuZGVjb2RlKGxhYmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBgZGF0YSguLi4ke2xhYmVsLmJ5dGVMZW5ndGh9IGJ5dGVzKWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0cmVlWzBdKSB7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRW1wdHk6XG4gICAgICAgICAgICByZXR1cm4gJygpJztcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5Gb3JrOiB7XG4gICAgICAgICAgICBpZiAodHJlZVsxXSBpbnN0YW5jZW9mIEFycmF5ICYmIHRyZWVbMl0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBoYXNoVHJlZVRvU3RyaW5nKHRyZWVbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaGFzaFRyZWVUb1N0cmluZyh0cmVlWzJdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYHN1YihcXG4gbGVmdDpcXG4ke2luZGVudChsZWZ0KX1cXG4tLS1cXG4gcmlnaHQ6XFxuJHtpbmRlbnQocmlnaHQpfVxcbilgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyZWUgc3RydWN0dXJlIGZvciBmb3JrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBOb2RlVHlwZS5MYWJlbGVkOiB7XG4gICAgICAgICAgICBpZiAodHJlZVsxXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICYmIHRyZWVbMl0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gbGFiZWxUb1N0cmluZyh0cmVlWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWIgPSBoYXNoVHJlZVRvU3RyaW5nKHRyZWVbMl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBgbGFiZWwoXFxuIGxhYmVsOlxcbiR7aW5kZW50KGxhYmVsKX1cXG4gc3ViOlxcbiR7aW5kZW50KHN1Yil9XFxuKWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJlZSBzdHJ1Y3R1cmUgZm9yIGxhYmVsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlIE5vZGVUeXBlLkxlYWY6IHtcbiAgICAgICAgICAgIGlmICghdHJlZVsxXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmVlIHN0cnVjdHVyZSBmb3IgbGVhZicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0cmVlWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0cmVlWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgbGVhZiguLi4ke3RyZWVbMV0uYnl0ZUxlbmd0aH0gYnl0ZXMpYDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE5vZGVUeXBlLlBydW5lZDoge1xuICAgICAgICAgICAgaWYgKCF0cmVlWzFdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyZWUgc3RydWN0dXJlIGZvciBwcnVuZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHJlZVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodHJlZVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHBydW5lZCgke3RvSGV4KG5ldyBVaW50OEFycmF5KHRyZWVbMV0pKX1gO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHJldHVybiBgdW5rbm93bigke0pTT04uc3RyaW5naWZ5KHRyZWVbMF0pfSlgO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNCdWZmZXJHcmVhdGVyVGhhbihhLCBiKSB7XG4gICAgY29uc3QgYTggPSBuZXcgVWludDhBcnJheShhKTtcbiAgICBjb25zdCBiOCA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYTgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGE4W2ldID4gYjhbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBjbGFzcyBDZXJ0aWZpY2F0ZSB7XG4gICAgY29uc3RydWN0b3IoY2VydGlmaWNhdGUsIF9yb290S2V5LCBfY2FuaXN0ZXJJZCwgX2Jsc1ZlcmlmeSwgXG4gICAgLy8gRGVmYXVsdCB0byA1IG1pbnV0ZXNcbiAgICBfbWF4QWdlSW5NaW51dGVzID0gNSkge1xuICAgICAgICB0aGlzLl9yb290S2V5ID0gX3Jvb3RLZXk7XG4gICAgICAgIHRoaXMuX2NhbmlzdGVySWQgPSBfY2FuaXN0ZXJJZDtcbiAgICAgICAgdGhpcy5fYmxzVmVyaWZ5ID0gX2Jsc1ZlcmlmeTtcbiAgICAgICAgdGhpcy5fbWF4QWdlSW5NaW51dGVzID0gX21heEFnZUluTWludXRlcztcbiAgICAgICAgdGhpcy5jZXJ0ID0gY2Jvci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoY2VydGlmaWNhdGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgY2VydGlmaWNhdGUsIGF1dG9tYXRpY2FsbHkgdmVyaWZ5aW5nIGl0LiBUaHJvd3MgYVxuICAgICAqIENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IgaWYgdGhlIGNlcnRpZmljYXRlIGNhbm5vdCBiZSB2ZXJpZmllZC5cbiAgICAgKiBAY29uc3RydWN0cyAgQ2VydGlmaWNhdGVcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUNlcnRpZmljYXRlT3B0aW9uc30gb3B0aW9ucyB7QGxpbmsgQ3JlYXRlQ2VydGlmaWNhdGVPcHRpb25zfVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IG9wdGlvbnMuY2VydGlmaWNhdGUgVGhlIGJ5dGVzIG9mIHRoZSBjZXJ0aWZpY2F0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IG9wdGlvbnMucm9vdEtleSBUaGUgcm9vdCBrZXkgdG8gdmVyaWZ5IGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge1ByaW5jaXBhbH0gb3B0aW9ucy5jYW5pc3RlcklkIFRoZSBlZmZlY3RpdmUgb3Igc2lnbmluZyBjYW5pc3RlciBJRFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heEFnZUluTWludXRlcyBUaGUgbWF4aW11bSBhZ2Ugb2YgdGhlIGNlcnRpZmljYXRlIGluIG1pbnV0ZXMuIERlZmF1bHQgaXMgNSBtaW51dGVzLlxuICAgICAqIEB0aHJvd3Mge0NlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3J9XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNlcnQgPSBDZXJ0aWZpY2F0ZS5jcmVhdGVVbnZlcmlmaWVkKG9wdGlvbnMpO1xuICAgICAgICBhd2FpdCBjZXJ0LnZlcmlmeSgpO1xuICAgICAgICByZXR1cm4gY2VydDtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVVudmVyaWZpZWQob3B0aW9ucykge1xuICAgICAgICBsZXQgYmxzVmVyaWZ5ID0gb3B0aW9ucy5ibHNWZXJpZnk7XG4gICAgICAgIGlmICghYmxzVmVyaWZ5KSB7XG4gICAgICAgICAgICBibHNWZXJpZnkgPSBibHMuYmxzVmVyaWZ5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2VydGlmaWNhdGUob3B0aW9ucy5jZXJ0aWZpY2F0ZSwgb3B0aW9ucy5yb290S2V5LCBvcHRpb25zLmNhbmlzdGVySWQsIGJsc1ZlcmlmeSwgb3B0aW9ucy5tYXhBZ2VJbk1pbnV0ZXMpO1xuICAgIH1cbiAgICBsb29rdXAocGF0aCkge1xuICAgICAgICAvLyBjb25zdHJhaW4gdGhlIHR5cGUgb2YgdGhlIHJlc3VsdCwgc28gdGhhdCBlbXB0eSBIYXNoVHJlZSBpcyB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIGxvb2t1cF9wYXRoKHBhdGgsIHRoaXMuY2VydC50cmVlKTtcbiAgICB9XG4gICAgbG9va3VwX2xhYmVsKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2t1cChbbGFiZWxdKTtcbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5KCkge1xuICAgICAgICBjb25zdCByb290SGFzaCA9IGF3YWl0IHJlY29uc3RydWN0KHRoaXMuY2VydC50cmVlKTtcbiAgICAgICAgY29uc3QgZGVyS2V5ID0gYXdhaXQgdGhpcy5fY2hlY2tEZWxlZ2F0aW9uQW5kR2V0S2V5KHRoaXMuY2VydC5kZWxlZ2F0aW9uKTtcbiAgICAgICAgY29uc3Qgc2lnID0gdGhpcy5jZXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZXh0cmFjdERFUihkZXJLZXkpO1xuICAgICAgICBjb25zdCBtc2cgPSBjb25jYXQoZG9tYWluX3NlcCgnaWMtc3RhdGUtcm9vdCcpLCByb290SGFzaCk7XG4gICAgICAgIGxldCBzaWdWZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbG9va3VwVGltZSA9IGxvb2t1cFJlc3VsdFRvQnVmZmVyKHRoaXMubG9va3VwKFsndGltZSddKSk7XG4gICAgICAgIGlmICghbG9va3VwVGltZSkge1xuICAgICAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGhhcHBlbiAtIHRpbWUgaXMgYWx3YXlzIHByZXNlbnQgaW4gSUMgY2VydGlmaWNhdGVzXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvcignQ2VydGlmaWNhdGUgZG9lcyBub3QgY29udGFpbiBhIHRpbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBGSVZFX01JTlVURVNfSU5fTVNFQyA9IDUgKiA2MCAqIDEwMDA7XG4gICAgICAgIGNvbnN0IE1BWF9BR0VfSU5fTVNFQyA9IHRoaXMuX21heEFnZUluTWludXRlcyAqIDYwICogMTAwMDtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZWFybGllc3RDZXJ0aWZpY2F0ZVRpbWUgPSBub3cgLSBNQVhfQUdFX0lOX01TRUM7XG4gICAgICAgIGNvbnN0IGZpdmVNaW51dGVzRnJvbU5vdyA9IG5vdyArIEZJVkVfTUlOVVRFU19JTl9NU0VDO1xuICAgICAgICBjb25zdCBjZXJ0VGltZSA9IGRlY29kZVRpbWUobG9va3VwVGltZSk7XG4gICAgICAgIGlmIChjZXJ0VGltZS5nZXRUaW1lKCkgPCBlYXJsaWVzdENlcnRpZmljYXRlVGltZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoYENlcnRpZmljYXRlIGlzIHNpZ25lZCBtb3JlIHRoYW4gJHt0aGlzLl9tYXhBZ2VJbk1pbnV0ZXN9IG1pbnV0ZXMgaW4gdGhlIHBhc3QuIENlcnRpZmljYXRlIHRpbWU6IGAgK1xuICAgICAgICAgICAgICAgIGNlcnRUaW1lLnRvSVNPU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICcgQ3VycmVudCB0aW1lOiAnICtcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShub3cpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNlcnRUaW1lLmdldFRpbWUoKSA+IGZpdmVNaW51dGVzRnJvbU5vdykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoJ0NlcnRpZmljYXRlIGlzIHNpZ25lZCBtb3JlIHRoYW4gNSBtaW51dGVzIGluIHRoZSBmdXR1cmUuIENlcnRpZmljYXRlIHRpbWU6ICcgK1xuICAgICAgICAgICAgICAgIGNlcnRUaW1lLnRvSVNPU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICcgQ3VycmVudCB0aW1lOiAnICtcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShub3cpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzaWdWZXIgPSBhd2FpdCB0aGlzLl9ibHNWZXJpZnkobmV3IFVpbnQ4QXJyYXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnKSwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc2lnVmVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaWdWZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yKCdTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9jaGVja0RlbGVnYXRpb25BbmRHZXRLZXkoZCkge1xuICAgICAgICBpZiAoIWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290S2V5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlcnQgPSBhd2FpdCBDZXJ0aWZpY2F0ZS5jcmVhdGVVbnZlcmlmaWVkKHtcbiAgICAgICAgICAgIGNlcnRpZmljYXRlOiBkLmNlcnRpZmljYXRlLFxuICAgICAgICAgICAgcm9vdEtleTogdGhpcy5fcm9vdEtleSxcbiAgICAgICAgICAgIGNhbmlzdGVySWQ6IHRoaXMuX2NhbmlzdGVySWQsXG4gICAgICAgICAgICBibHNWZXJpZnk6IHRoaXMuX2Jsc1ZlcmlmeSxcbiAgICAgICAgICAgIC8vIERvIG5vdCBjaGVjayBtYXggYWdlIGZvciBkZWxlZ2F0aW9uIGNlcnRpZmljYXRlc1xuICAgICAgICAgICAgbWF4QWdlSW5NaW51dGVzOiBJbmZpbml0eSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjZXJ0LmNlcnQuZGVsZWdhdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoJ0RlbGVnYXRpb24gY2VydGlmaWNhdGVzIGNhbm5vdCBiZSBuZXN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBjZXJ0LnZlcmlmeSgpO1xuICAgICAgICBpZiAodGhpcy5fY2FuaXN0ZXJJZC50b1N0cmluZygpICE9PSBNQU5BR0VNRU5UX0NBTklTVEVSX0lEKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5pc3RlckluUmFuZ2UgPSBjaGVja19jYW5pc3Rlcl9yYW5nZXMoe1xuICAgICAgICAgICAgICAgIGNhbmlzdGVySWQ6IHRoaXMuX2NhbmlzdGVySWQsXG4gICAgICAgICAgICAgICAgc3VibmV0SWQ6IFByaW5jaXBhbC5mcm9tVWludDhBcnJheShuZXcgVWludDhBcnJheShkLnN1Ym5ldF9pZCkpLFxuICAgICAgICAgICAgICAgIHRyZWU6IGNlcnQuY2VydC50cmVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWNhbmlzdGVySW5SYW5nZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yKGBDYW5pc3RlciAke3RoaXMuX2NhbmlzdGVySWR9IG5vdCBpbiByYW5nZSBvZiBkZWxlZ2F0aW9ucyBmb3Igc3VibmV0IDB4JHt0b0hleChkLnN1Ym5ldF9pZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVibGljS2V5TG9va3VwID0gbG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydC5sb29rdXAoWydzdWJuZXQnLCBkLnN1Ym5ldF9pZCwgJ3B1YmxpY19rZXknXSkpO1xuICAgICAgICBpZiAoIXB1YmxpY0tleUxvb2t1cCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBzdWJuZXQga2V5IGZvciBzdWJuZXQgMHgke3RvSGV4KGQuc3VibmV0X2lkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVibGljS2V5TG9va3VwO1xuICAgIH1cbn1cbmNvbnN0IERFUl9QUkVGSVggPSBmcm9tSGV4KCczMDgxODIzMDFkMDYwZDJiMDYwMTA0MDE4MmRjN2MwNTAzMDEwMjAxMDYwYzJiMDYwMTA0MDE4MmRjN2MwNTAzMDIwMTAzNjEwMCcpO1xuY29uc3QgS0VZX0xFTkdUSCA9IDk2O1xuZnVuY3Rpb24gZXh0cmFjdERFUihidWYpIHtcbiAgICBjb25zdCBleHBlY3RlZExlbmd0aCA9IERFUl9QUkVGSVguYnl0ZUxlbmd0aCArIEtFWV9MRU5HVEg7XG4gICAgaWYgKGJ1Zi5ieXRlTGVuZ3RoICE9PSBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBCTFMgREVSLWVuY29kZWQgcHVibGljIGtleSBtdXN0IGJlICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzIGxvbmdgKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4ID0gYnVmLnNsaWNlKDAsIERFUl9QUkVGSVguYnl0ZUxlbmd0aCk7XG4gICAgaWYgKCFidWZFcXVhbHMocHJlZml4LCBERVJfUFJFRklYKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBCTFMgREVSLWVuY29kZWQgcHVibGljIGtleSBpcyBpbnZhbGlkLiBFeHBlY3QgdGhlIGZvbGxvd2luZyBwcmVmaXg6ICR7REVSX1BSRUZJWH0sIGJ1dCBnZXQgJHtwcmVmaXh9YCk7XG4gICAgfVxuICAgIHJldHVybiBidWYuc2xpY2UoREVSX1BSRUZJWC5ieXRlTGVuZ3RoKTtcbn1cbi8qKlxuICogdXRpbGl0eSBmdW5jdGlvbiB0byBjb25zdHJhaW4gdGhlIHR5cGUgb2YgYSBwYXRoXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyIHwgSGFzaFRyZWUgfCB1bmRlZmluZWR9IHJlc3VsdCAtIHRoZSByZXN1bHQgb2YgYSBsb29rdXBcbiAqIEByZXR1cm5zIEFycmF5QnVmZmVyIG9yIFVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9va3VwUmVzdWx0VG9CdWZmZXIocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09IExvb2t1cFN0YXR1cy5Gb3VuZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZS5idWZmZXI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEBwYXJhbSB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWNvbnN0cnVjdCh0KSB7XG4gICAgc3dpdGNoICh0WzBdKSB7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRW1wdHk6XG4gICAgICAgICAgICByZXR1cm4gaGFzaChkb21haW5fc2VwKCdpYy1oYXNodHJlZS1lbXB0eScpKTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5QcnVuZWQ6XG4gICAgICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5MZWFmOlxuICAgICAgICAgICAgcmV0dXJuIGhhc2goY29uY2F0KGRvbWFpbl9zZXAoJ2ljLWhhc2h0cmVlLWxlYWYnKSwgdFsxXSkpO1xuICAgICAgICBjYXNlIE5vZGVUeXBlLkxhYmVsZWQ6XG4gICAgICAgICAgICByZXR1cm4gaGFzaChjb25jYXQoZG9tYWluX3NlcCgnaWMtaGFzaHRyZWUtbGFiZWxlZCcpLCB0WzFdLCBhd2FpdCByZWNvbnN0cnVjdCh0WzJdKSkpO1xuICAgICAgICBjYXNlIE5vZGVUeXBlLkZvcms6XG4gICAgICAgICAgICByZXR1cm4gaGFzaChjb25jYXQoZG9tYWluX3NlcCgnaWMtaGFzaHRyZWUtZm9yaycpLCBhd2FpdCByZWNvbnN0cnVjdCh0WzFdKSwgYXdhaXQgcmVjb25zdHJ1Y3QodFsyXSkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkb21haW5fc2VwKHMpIHtcbiAgICBjb25zdCBsZW4gPSBuZXcgVWludDhBcnJheShbcy5sZW5ndGhdKTtcbiAgICBjb25zdCBzdHIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocyk7XG4gICAgcmV0dXJuIGNvbmNhdChsZW4sIHN0cik7XG59XG5leHBvcnQgdmFyIExvb2t1cFN0YXR1cztcbihmdW5jdGlvbiAoTG9va3VwU3RhdHVzKSB7XG4gICAgTG9va3VwU3RhdHVzW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICAgIExvb2t1cFN0YXR1c1tcIkFic2VudFwiXSA9IFwiYWJzZW50XCI7XG4gICAgTG9va3VwU3RhdHVzW1wiRm91bmRcIl0gPSBcImZvdW5kXCI7XG59KShMb29rdXBTdGF0dXMgfHwgKExvb2t1cFN0YXR1cyA9IHt9KSk7XG52YXIgTGFiZWxMb29rdXBTdGF0dXM7XG4oZnVuY3Rpb24gKExhYmVsTG9va3VwU3RhdHVzKSB7XG4gICAgTGFiZWxMb29rdXBTdGF0dXNbXCJMZXNzXCJdID0gXCJsZXNzXCI7XG4gICAgTGFiZWxMb29rdXBTdGF0dXNbXCJHcmVhdGVyXCJdID0gXCJncmVhdGVyXCI7XG59KShMYWJlbExvb2t1cFN0YXR1cyB8fCAoTGFiZWxMb29rdXBTdGF0dXMgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGxvb2t1cF9wYXRoKHBhdGgsIHRyZWUpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3dpdGNoICh0cmVlWzBdKSB7XG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLkxlYWY6IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyZWVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyZWUgc3RydWN0dXJlIGZvciBsZWFmJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmVlWzFdIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3RhdHVzLkZvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRyZWVbMV0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmVlWzFdIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBMb29rdXBTdGF0dXMuRm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJlZVsxXS5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3RhdHVzLkZvdW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJlZVsxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3RhdHVzLkZvdW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJlZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsID0gdHlwZW9mIHBhdGhbMF0gPT09ICdzdHJpbmcnID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHBhdGhbMF0pIDogcGF0aFswXTtcbiAgICBjb25zdCBsb29rdXBSZXN1bHQgPSBmaW5kX2xhYmVsKGxhYmVsLCB0cmVlKTtcbiAgICBzd2l0Y2ggKGxvb2t1cFJlc3VsdC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBMb29rdXBTdGF0dXMuRm91bmQ6IHtcbiAgICAgICAgICAgIHJldHVybiBsb29rdXBfcGF0aChwYXRoLnNsaWNlKDEpLCBsb29rdXBSZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTGFiZWxMb29rdXBTdGF0dXMuR3JlYXRlcjpcbiAgICAgICAgY2FzZSBMYWJlbExvb2t1cFN0YXR1cy5MZXNzOiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3RhdHVzLkFic2VudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cFJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogSWYgdGhlIHRyZWUgaXMgYSBmb3JrLCBmbGF0dGVuIGl0IGludG8gYW4gYXJyYXkgb2YgdHJlZXNcbiAqIEBwYXJhbSB0IC0gdGhlIHRyZWUgdG8gZmxhdHRlblxuICogQHJldHVybnMgSGFzaFRyZWVbXSAtIHRoZSBmbGF0dGVuZWQgdHJlZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbl9mb3Jrcyh0KSB7XG4gICAgc3dpdGNoICh0WzBdKSB7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRW1wdHk6XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRm9yazpcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuX2ZvcmtzKHRbMV0pLmNvbmNhdChmbGF0dGVuX2ZvcmtzKHRbMl0pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbdF07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRfbGFiZWwobGFiZWwsIHRyZWUpIHtcbiAgICBzd2l0Y2ggKHRyZWVbMF0pIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGxhYmVsbGVkIG5vZGUsIGNvbXBhcmUgdGhlIG5vZGUncyBsYWJlbCB0byB0aGUgb25lIHdlIGFyZVxuICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICBjYXNlIE5vZGVUeXBlLkxhYmVsZWQ6XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBncmVhdGVyIHRoYW4gdGhpcyBub2RlJ3MgbGFiZWwsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGtlZXAgc2VhcmNoaW5nXG4gICAgICAgICAgICBpZiAoaXNCdWZmZXJHcmVhdGVyVGhhbihsYWJlbCwgdHJlZVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IExhYmVsTG9va3VwU3RhdHVzLkdyZWF0ZXIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIGVxdWFsIHRoaXMgbm9kZSdzIGxhYmVsLCB3ZSBjYW5cbiAgICAgICAgICAgIC8vIHN0b3Agc2VhcmNoaW5nIGFuZCByZXR1cm4gdGhlIGZvdW5kIG5vZGVcbiAgICAgICAgICAgIGlmIChidWZFcXVhbHMobGFiZWwsIHRyZWVbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBMb29rdXBTdGF0dXMuRm91bmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cmVlWzJdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBub3QgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoaXNcbiAgICAgICAgICAgIC8vIG5vZGUncyBsYWJlbCwgdGhlbiBpdCdzIGxlc3MgdGhhbiB0aGlzIG5vZGUncyBsYWJlbCwgYW5kIHdlIGNhbiBzdG9wXG4gICAgICAgICAgICAvLyBzZWFyY2hpbmcgYmVjYXVzZSB3ZSd2ZSBsb29rZWQgdG9vIGZhclxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IExhYmVsTG9va3VwU3RhdHVzLkxlc3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgZm9yayBub2RlLCB3ZSBuZWVkIHRvIHNlYXJjaCBib3RoIHNpZGVzLCBzdGFydGluZyB3aXRoIHRoZSBsZWZ0XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRm9yazpcbiAgICAgICAgICAgIC8vIHNlYXJjaCBpbiB0aGUgbGVmdCBub2RlXG4gICAgICAgICAgICBjb25zdCBsZWZ0TG9va3VwUmVzdWx0ID0gZmluZF9sYWJlbChsYWJlbCwgdHJlZVsxXSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGxlZnRMb29rdXBSZXN1bHQuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxhYmVsIHdlJ3JlIHNlYXJjaGluZyBmb3IgaXMgZ3JlYXRlciB0aGFuIHRoZSBsZWZ0IG5vZGUgbG9va3VwLFxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc2VhcmNoIHRoZSByaWdodCBub2RlXG4gICAgICAgICAgICAgICAgY2FzZSBMYWJlbExvb2t1cFN0YXR1cy5HcmVhdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0TG9va3VwUmVzdWx0ID0gZmluZF9sYWJlbChsYWJlbCwgdHJlZVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIGxlc3MgdGhhbiB0aGUgcmlnaHQgbm9kZSBsb29rdXAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIHN0b3Agc2VhcmNoaW5nIGFuZCBzYXkgdGhhdCB0aGUgbGFiZWwgaXMgcHJvdmFibHkgQWJzZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodExvb2t1cFJlc3VsdC5zdGF0dXMgPT09IExhYmVsTG9va3VwU3RhdHVzLkxlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBMb29rdXBTdGF0dXMuQWJzZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgbG9va3VwLCB0aGVuIHdlIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRMb29rdXBSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsZWZ0IG5vZGUgcmV0dXJucyBhbiB1bmNlcnRhaW4gcmVzdWx0LCB3ZSBuZWVkIHRvIHNlYXJjaCB0aGVcbiAgICAgICAgICAgICAgICAvLyByaWdodCBub2RlXG4gICAgICAgICAgICAgICAgY2FzZSBMb29rdXBTdGF0dXMuVW5rbm93bjoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRMb29rdXBSZXN1bHQgPSBmaW5kX2xhYmVsKGxhYmVsLCB0cmVlWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxhYmVsIHdlJ3JlIHNlYXJjaGluZyBmb3IgaXMgbGVzcyB0aGFuIHRoZSByaWdodCBub2RlIGxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBhbHNvIG5lZWQgdG8gcmV0dXJuIGFuIHVuY2VydGFpbiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0TG9va3VwUmVzdWx0LnN0YXR1cyA9PT0gTGFiZWxMb29rdXBTdGF0dXMuTGVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cFN0YXR1cy5Vbmtub3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgbG9va3VwLCB0aGVuIHdlIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRMb29rdXBSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIG5vdCBncmVhdGVyIHRoYW4gdGhlIGxlZnQgbm9kZVxuICAgICAgICAgICAgICAgIC8vIGxvb2t1cCwgb3IgdGhlIHJlc3VsdCBpcyBub3QgdW5jZXJ0YWluLCB3ZSBzdG9wIHNlYXJjaGluZyBhbmQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gd2hhdGV2ZXIgdGhlIHJlc3VsdCBvZiB0aGUgbGVmdCBub2RlIGxvb2t1cCB3YXMsIHdoaWNoIGNhbiBiZSBlaXRoZXJcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBvciBBYnNlbnRcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0TG9va3VwUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGEgUHJ1bmVkIG5vZGUsIHdlIGNhbid0IGtub3cgZm9yIGNlcnRhaW4gaWYgdGhlIGxhYmVsXG4gICAgICAgIC8vIHdlJ3JlIHNlYXJjaGluZyBmb3IgaXMgcHJlc2VudCBvciBub3RcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5QcnVuZWQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3RhdHVzLlVua25vd24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBub2RlIGlzIEVtcHR5LCBvciBhIExlYWYsIHdlIGNhbiBzdG9wIHNlYXJjaGluZyBiZWNhdXNlXG4gICAgICAgIC8vIHdlIGtub3cgZm9yIHN1cmUgdGhhdCB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBub3QgcHJlc2VudFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cFN0YXR1cy5BYnNlbnQsXG4gICAgICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjYW5pc3RlciBmYWxscyB3aXRoaW4gYSByYW5nZSBvZiBjYW5pc3RlcnNcbiAqIEBwYXJhbSBjYW5pc3RlcklkIFByaW5jaXBhbFxuICogQHBhcmFtIHJhbmdlcyBbUHJpbmNpcGFsLCBQcmluY2lwYWxdW11cbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja19jYW5pc3Rlcl9yYW5nZXMocGFyYW1zKSB7XG4gICAgY29uc3QgeyBjYW5pc3RlcklkLCBzdWJuZXRJZCwgdHJlZSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJhbmdlTG9va3VwID0gbG9va3VwX3BhdGgoWydzdWJuZXQnLCBzdWJuZXRJZC50b1VpbnQ4QXJyYXkoKSwgJ2NhbmlzdGVyX3JhbmdlcyddLCB0cmVlKTtcbiAgICBpZiAocmFuZ2VMb29rdXAuc3RhdHVzICE9PSBMb29rdXBTdGF0dXMuRm91bmQgfHwgIShyYW5nZUxvb2t1cC52YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGNhbmlzdGVyIHJhbmdlcyBmb3Igc3VibmV0ICR7c3VibmV0SWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlc19hcnIgPSBjYm9yLmRlY29kZShyYW5nZUxvb2t1cC52YWx1ZSk7XG4gICAgY29uc3QgcmFuZ2VzID0gcmFuZ2VzX2Fyci5tYXAodiA9PiBbXG4gICAgICAgIFByaW5jaXBhbC5mcm9tVWludDhBcnJheSh2WzBdKSxcbiAgICAgICAgUHJpbmNpcGFsLmZyb21VaW50OEFycmF5KHZbMV0pLFxuICAgIF0pO1xuICAgIGNvbnN0IGNhbmlzdGVySW5SYW5nZSA9IHJhbmdlcy5zb21lKHIgPT4gclswXS5sdEVxKGNhbmlzdGVySWQpICYmIHJbMV0uZ3RFcShjYW5pc3RlcklkKSk7XG4gICAgcmV0dXJuIGNhbmlzdGVySW5SYW5nZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNlcnRpZmljYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/certificate.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/constants.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/constants.js ***!
  \***************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS: () => (/* binding */ DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)\n/* harmony export */ });\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDTztBQUNQIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2FnZW50QDIuMS4zX0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjNfX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRGVmYXVsdCBkZWx0YSBmb3IgaW5ncmVzcyBleHBpcnkgaXMgNSBtaW51dGVzLlxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSU5HUkVTU19FWFBJUllfREVMVEFfSU5fTVNFQ1MgPSA1ICogNjAgKiAxMDAwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/constants.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/der.js":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/der.js ***!
  \*********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER_COSE_OID: () => (/* binding */ DER_COSE_OID),\n/* harmony export */   ED25519_OID: () => (/* binding */ ED25519_OID),\n/* harmony export */   SECP256K1_OID: () => (/* binding */ SECP256K1_OID),\n/* harmony export */   decodeLen: () => (/* binding */ decodeLen),\n/* harmony export */   decodeLenBytes: () => (/* binding */ decodeLenBytes),\n/* harmony export */   encodeLen: () => (/* binding */ encodeLen),\n/* harmony export */   encodeLenBytes: () => (/* binding */ encodeLenBytes),\n/* harmony export */   unwrapDER: () => (/* binding */ unwrapDER),\n/* harmony export */   wrapDER: () => (/* binding */ wrapDER)\n/* harmony export */ });\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\nconst encodeLenBytes = (len) => {\n    if (len <= 0x7f) {\n        return 1;\n    }\n    else if (len <= 0xff) {\n        return 2;\n    }\n    else if (len <= 0xffff) {\n        return 3;\n    }\n    else if (len <= 0xffffff) {\n        return 4;\n    }\n    else {\n        throw new Error('Length too long (> 4 bytes)');\n    }\n};\nconst encodeLen = (buf, offset, len) => {\n    if (len <= 0x7f) {\n        buf[offset] = len;\n        return 1;\n    }\n    else if (len <= 0xff) {\n        buf[offset] = 0x81;\n        buf[offset + 1] = len;\n        return 2;\n    }\n    else if (len <= 0xffff) {\n        buf[offset] = 0x82;\n        buf[offset + 1] = len >> 8;\n        buf[offset + 2] = len;\n        return 3;\n    }\n    else if (len <= 0xffffff) {\n        buf[offset] = 0x83;\n        buf[offset + 1] = len >> 16;\n        buf[offset + 2] = len >> 8;\n        buf[offset + 3] = len;\n        return 4;\n    }\n    else {\n        throw new Error('Length too long (> 4 bytes)');\n    }\n};\nconst decodeLenBytes = (buf, offset) => {\n    if (buf[offset] < 0x80)\n        return 1;\n    if (buf[offset] === 0x80)\n        throw new Error('Invalid length 0');\n    if (buf[offset] === 0x81)\n        return 2;\n    if (buf[offset] === 0x82)\n        return 3;\n    if (buf[offset] === 0x83)\n        return 4;\n    throw new Error('Length too long (> 4 bytes)');\n};\nconst decodeLen = (buf, offset) => {\n    const lenBytes = decodeLenBytes(buf, offset);\n    if (lenBytes === 1)\n        return buf[offset];\n    else if (lenBytes === 2)\n        return buf[offset + 1];\n    else if (lenBytes === 3)\n        return (buf[offset + 1] << 8) + buf[offset + 2];\n    else if (lenBytes === 4)\n        return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];\n    throw new Error('Length too long (> 4 bytes)');\n};\n/**\n * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE\n */\nconst DER_COSE_OID = Uint8Array.from([\n    ...[0x30, 0x0c],\n    ...[0x06, 0x0a],\n    ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01], // DER encoded COSE\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm\n */\nconst ED25519_OID = Uint8Array.from([\n    ...[0x30, 0x05],\n    ...[0x06, 0x03],\n    ...[0x2b, 0x65, 0x70], // id-Ed25519 OID\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm\n */\nconst SECP256K1_OID = Uint8Array.from([\n    ...[0x30, 0x10],\n    ...[0x06, 0x07],\n    ...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01],\n    ...[0x06, 0x05],\n    ...[0x2b, 0x81, 0x04, 0x00, 0x0a], // OID secp256k1\n]);\n/**\n * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:\n * `SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param payload The payload to encode as the bit string\n * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with\n */\nfunction wrapDER(payload, oid) {\n    // The Bit String header needs to include the unused bit count byte in its length\n    const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);\n    const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;\n    let offset = 0;\n    const buf = new Uint8Array(1 + encodeLenBytes(len) + len);\n    // Sequence\n    buf[offset++] = 0x30;\n    // Sequence Length\n    offset += encodeLen(buf, offset, len);\n    // OID\n    buf.set(oid, offset);\n    offset += oid.byteLength;\n    // Bit String Header\n    buf[offset++] = 0x03;\n    offset += encodeLen(buf, offset, payload.byteLength + 1);\n    // 0 padding\n    buf[offset++] = 0x00;\n    buf.set(new Uint8Array(payload), offset);\n    return buf;\n}\n/**\n * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.\n *\n * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param derEncoded The DER encoded and tagged data\n * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID\n * @returns The unwrapped payload\n */\nconst unwrapDER = (derEncoded, oid) => {\n    let offset = 0;\n    const expect = (n, msg) => {\n        if (buf[offset++] !== n) {\n            throw new Error('Expected: ' + msg);\n        }\n    };\n    const buf = new Uint8Array(derEncoded);\n    expect(0x30, 'sequence');\n    offset += decodeLenBytes(buf, offset);\n    if (!(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.bufEquals)(buf.slice(offset, offset + oid.byteLength), oid)) {\n        throw new Error('Not the expected OID.');\n    }\n    offset += oid.byteLength;\n    expect(0x03, 'bit string');\n    const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding\n    offset += decodeLenBytes(buf, offset);\n    expect(0x00, '0 padding');\n    const result = buf.slice(offset);\n    if (payloadLen !== result.length) {\n        throw new Error(`DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`);\n    }\n    return result;\n};\n//# sourceMappingURL=der.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ3BDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3REFBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxZQUFZLGdCQUFnQixjQUFjO0FBQzNHO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2FnZW50QDIuMS4zX0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjNfX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnVmRXF1YWxzIH0gZnJvbSAnLi91dGlscy9idWZmZXInO1xuZXhwb3J0IGNvbnN0IGVuY29kZUxlbkJ5dGVzID0gKGxlbikgPT4ge1xuICAgIGlmIChsZW4gPD0gMHg3Zikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuIDw9IDB4ZmYpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA8PSAweGZmZmYpIHtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA8PSAweGZmZmZmZikge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIHRvbyBsb25nICg+IDQgYnl0ZXMpJyk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVMZW4gPSAoYnVmLCBvZmZzZXQsIGxlbikgPT4ge1xuICAgIGlmIChsZW4gPD0gMHg3Zikge1xuICAgICAgICBidWZbb2Zmc2V0XSA9IGxlbjtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHg4MTtcbiAgICAgICAgYnVmW29mZnNldCArIDFdID0gbGVuO1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuIDw9IDB4ZmZmZikge1xuICAgICAgICBidWZbb2Zmc2V0XSA9IDB4ODI7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyAxXSA9IGxlbiA+PiA4O1xuICAgICAgICBidWZbb2Zmc2V0ICsgMl0gPSBsZW47XG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPD0gMHhmZmZmZmYpIHtcbiAgICAgICAgYnVmW29mZnNldF0gPSAweDgzO1xuICAgICAgICBidWZbb2Zmc2V0ICsgMV0gPSBsZW4gPj4gMTY7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyAyXSA9IGxlbiA+PiA4O1xuICAgICAgICBidWZbb2Zmc2V0ICsgM10gPSBsZW47XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggdG9vIGxvbmcgKD4gNCBieXRlcyknKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGRlY29kZUxlbkJ5dGVzID0gKGJ1Ziwgb2Zmc2V0KSA9PiB7XG4gICAgaWYgKGJ1ZltvZmZzZXRdIDwgMHg4MClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGJ1ZltvZmZzZXRdID09PSAweDgwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGVuZ3RoIDAnKTtcbiAgICBpZiAoYnVmW29mZnNldF0gPT09IDB4ODEpXG4gICAgICAgIHJldHVybiAyO1xuICAgIGlmIChidWZbb2Zmc2V0XSA9PT0gMHg4MilcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgaWYgKGJ1ZltvZmZzZXRdID09PSAweDgzKVxuICAgICAgICByZXR1cm4gNDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCB0b28gbG9uZyAoPiA0IGJ5dGVzKScpO1xufTtcbmV4cG9ydCBjb25zdCBkZWNvZGVMZW4gPSAoYnVmLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBsZW5CeXRlcyA9IGRlY29kZUxlbkJ5dGVzKGJ1Ziwgb2Zmc2V0KTtcbiAgICBpZiAobGVuQnl0ZXMgPT09IDEpXG4gICAgICAgIHJldHVybiBidWZbb2Zmc2V0XTtcbiAgICBlbHNlIGlmIChsZW5CeXRlcyA9PT0gMilcbiAgICAgICAgcmV0dXJuIGJ1ZltvZmZzZXQgKyAxXTtcbiAgICBlbHNlIGlmIChsZW5CeXRlcyA9PT0gMylcbiAgICAgICAgcmV0dXJuIChidWZbb2Zmc2V0ICsgMV0gPDwgOCkgKyBidWZbb2Zmc2V0ICsgMl07XG4gICAgZWxzZSBpZiAobGVuQnl0ZXMgPT09IDQpXG4gICAgICAgIHJldHVybiAoYnVmW29mZnNldCArIDFdIDw8IDE2KSArIChidWZbb2Zmc2V0ICsgMl0gPDwgOCkgKyBidWZbb2Zmc2V0ICsgM107XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggdG9vIGxvbmcgKD4gNCBieXRlcyknKTtcbn07XG4vKipcbiAqIEEgREVSIGVuY29kZWQgYFNFUVVFTkNFKE9JRClgIGZvciBERVItZW5jb2RlZC1DT1NFXG4gKi9cbmV4cG9ydCBjb25zdCBERVJfQ09TRV9PSUQgPSBVaW50OEFycmF5LmZyb20oW1xuICAgIC4uLlsweDMwLCAweDBjXSxcbiAgICAuLi5bMHgwNiwgMHgwYV0sXG4gICAgLi4uWzB4MmIsIDB4MDYsIDB4MDEsIDB4MDQsIDB4MDEsIDB4ODMsIDB4YjgsIDB4NDMsIDB4MDEsIDB4MDFdLCAvLyBERVIgZW5jb2RlZCBDT1NFXG5dKTtcbi8qKlxuICogQSBERVIgZW5jb2RlZCBgU0VRVUVOQ0UoT0lEKWAgZm9yIHRoZSBFZDI1NTE5IGFsZ29yaXRobVxuICovXG5leHBvcnQgY29uc3QgRUQyNTUxOV9PSUQgPSBVaW50OEFycmF5LmZyb20oW1xuICAgIC4uLlsweDMwLCAweDA1XSxcbiAgICAuLi5bMHgwNiwgMHgwM10sXG4gICAgLi4uWzB4MmIsIDB4NjUsIDB4NzBdLCAvLyBpZC1FZDI1NTE5IE9JRFxuXSk7XG4vKipcbiAqIEEgREVSIGVuY29kZWQgYFNFUVVFTkNFKE9JRClgIGZvciBzZWNwMjU2azEgd2l0aCB0aGUgRUNEU0EgYWxnb3JpdGhtXG4gKi9cbmV4cG9ydCBjb25zdCBTRUNQMjU2SzFfT0lEID0gVWludDhBcnJheS5mcm9tKFtcbiAgICAuLi5bMHgzMCwgMHgxMF0sXG4gICAgLi4uWzB4MDYsIDB4MDddLFxuICAgIC4uLlsweDJhLCAweDg2LCAweDQ4LCAweGNlLCAweDNkLCAweDAyLCAweDAxXSxcbiAgICAuLi5bMHgwNiwgMHgwNV0sXG4gICAgLi4uWzB4MmIsIDB4ODEsIDB4MDQsIDB4MDAsIDB4MGFdLCAvLyBPSUQgc2VjcDI1NmsxXG5dKTtcbi8qKlxuICogV3JhcHMgdGhlIGdpdmVuIGBwYXlsb2FkYCBpbiBhIERFUiBlbmNvZGluZyB0YWdnZWQgd2l0aCB0aGUgZ2l2ZW4gZW5jb2RlZCBgb2lkYCBsaWtlIHNvOlxuICogYFNFUVVFTkNFKG9pZCwgQklUU1RSSU5HKHBheWxvYWQpKWBcbiAqXG4gKiBAcGFyYW0gcGF5bG9hZCBUaGUgcGF5bG9hZCB0byBlbmNvZGUgYXMgdGhlIGJpdCBzdHJpbmdcbiAqIEBwYXJhbSBvaWQgVGhlIERFUiBlbmNvZGVkIChhbmQgU0VRVUVOQ0Ugd3JhcHBlZCEpIE9JRCB0byB0YWcgdGhlIHBheWxvYWQgd2l0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcERFUihwYXlsb2FkLCBvaWQpIHtcbiAgICAvLyBUaGUgQml0IFN0cmluZyBoZWFkZXIgbmVlZHMgdG8gaW5jbHVkZSB0aGUgdW51c2VkIGJpdCBjb3VudCBieXRlIGluIGl0cyBsZW5ndGhcbiAgICBjb25zdCBiaXRTdHJpbmdIZWFkZXJMZW5ndGggPSAyICsgZW5jb2RlTGVuQnl0ZXMocGF5bG9hZC5ieXRlTGVuZ3RoICsgMSk7XG4gICAgY29uc3QgbGVuID0gb2lkLmJ5dGVMZW5ndGggKyBiaXRTdHJpbmdIZWFkZXJMZW5ndGggKyBwYXlsb2FkLmJ5dGVMZW5ndGg7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMSArIGVuY29kZUxlbkJ5dGVzKGxlbikgKyBsZW4pO1xuICAgIC8vIFNlcXVlbmNlXG4gICAgYnVmW29mZnNldCsrXSA9IDB4MzA7XG4gICAgLy8gU2VxdWVuY2UgTGVuZ3RoXG4gICAgb2Zmc2V0ICs9IGVuY29kZUxlbihidWYsIG9mZnNldCwgbGVuKTtcbiAgICAvLyBPSURcbiAgICBidWYuc2V0KG9pZCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gb2lkLmJ5dGVMZW5ndGg7XG4gICAgLy8gQml0IFN0cmluZyBIZWFkZXJcbiAgICBidWZbb2Zmc2V0KytdID0gMHgwMztcbiAgICBvZmZzZXQgKz0gZW5jb2RlTGVuKGJ1Ziwgb2Zmc2V0LCBwYXlsb2FkLmJ5dGVMZW5ndGggKyAxKTtcbiAgICAvLyAwIHBhZGRpbmdcbiAgICBidWZbb2Zmc2V0KytdID0gMHgwMDtcbiAgICBidWYuc2V0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBvZmZzZXQpO1xuICAgIHJldHVybiBidWY7XG59XG4vKipcbiAqIEV4dHJhY3RzIGEgcGF5bG9hZCBmcm9tIHRoZSBnaXZlbiBgZGVyRW5jb2RlZGAgZGF0YSwgYW5kIGNoZWNrcyB0aGF0IGl0IHdhcyB0YWdnZWQgd2l0aCB0aGUgZ2l2ZW4gYG9pZGAuXG4gKlxuICogYGRlckVuY29kZWQgPSBTRVFVRU5DRShvaWQsIEJJVFNUUklORyhwYXlsb2FkKSlgXG4gKlxuICogQHBhcmFtIGRlckVuY29kZWQgVGhlIERFUiBlbmNvZGVkIGFuZCB0YWdnZWQgZGF0YVxuICogQHBhcmFtIG9pZCBUaGUgREVSIGVuY29kZWQgKGFuZCBTRVFVRU5DRSB3cmFwcGVkISkgZXhwZWN0ZWQgT0lEXG4gKiBAcmV0dXJucyBUaGUgdW53cmFwcGVkIHBheWxvYWRcbiAqL1xuZXhwb3J0IGNvbnN0IHVud3JhcERFUiA9IChkZXJFbmNvZGVkLCBvaWQpID0+IHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBleHBlY3QgPSAobiwgbXNnKSA9PiB7XG4gICAgICAgIGlmIChidWZbb2Zmc2V0KytdICE9PSBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoZGVyRW5jb2RlZCk7XG4gICAgZXhwZWN0KDB4MzAsICdzZXF1ZW5jZScpO1xuICAgIG9mZnNldCArPSBkZWNvZGVMZW5CeXRlcyhidWYsIG9mZnNldCk7XG4gICAgaWYgKCFidWZFcXVhbHMoYnVmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgb2lkLmJ5dGVMZW5ndGgpLCBvaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHRoZSBleHBlY3RlZCBPSUQuJyk7XG4gICAgfVxuICAgIG9mZnNldCArPSBvaWQuYnl0ZUxlbmd0aDtcbiAgICBleHBlY3QoMHgwMywgJ2JpdCBzdHJpbmcnKTtcbiAgICBjb25zdCBwYXlsb2FkTGVuID0gZGVjb2RlTGVuKGJ1Ziwgb2Zmc2V0KSAtIDE7IC8vIFN1YnRyYWN0aW5nIDEgdG8gYWNjb3VudCBmb3IgdGhlIDAgcGFkZGluZ1xuICAgIG9mZnNldCArPSBkZWNvZGVMZW5CeXRlcyhidWYsIG9mZnNldCk7XG4gICAgZXhwZWN0KDB4MDAsICcwIHBhZGRpbmcnKTtcbiAgICBjb25zdCByZXN1bHQgPSBidWYuc2xpY2Uob2Zmc2V0KTtcbiAgICBpZiAocGF5bG9hZExlbiAhPT0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERFUiBwYXlsb2FkIG1pc21hdGNoOiBFeHBlY3RlZCBsZW5ndGggJHtwYXlsb2FkTGVufSBhY3R1YWwgbGVuZ3RoICR7cmVzdWx0Lmxlbmd0aH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/der.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/errors.js":
/*!************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/errors.js ***!
  \************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActorCallError: () => (/* binding */ ActorCallError),\n/* harmony export */   AgentError: () => (/* binding */ AgentError),\n/* harmony export */   QueryCallRejectedError: () => (/* binding */ QueryCallRejectedError),\n/* harmony export */   UpdateCallRejectedError: () => (/* binding */ UpdateCallRejectedError)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _agent_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent/api */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/api.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\n\n\n/**\n * An error that happens in the Agent. This is the root of all errors and should be used\n * everywhere in the Agent code (this package).\n * @todo https://github.com/dfinity/agent-js/issues/420\n */\nclass AgentError extends Error {\n    constructor(message) {\n        super(message);\n        this.message = message;\n        this.name = 'AgentError';\n        this.__proto__ = AgentError.prototype;\n        Object.setPrototypeOf(this, AgentError.prototype);\n    }\n}\nclass ActorCallError extends AgentError {\n    constructor(canisterId, methodName, type, props) {\n        const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        super([\n            `Call failed:`,\n            `  Canister: ${cid.toText()}`,\n            `  Method: ${methodName} (${type})`,\n            ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n        ].join('\\n'));\n        this.canisterId = canisterId;\n        this.methodName = methodName;\n        this.type = type;\n        this.props = props;\n        this.name = 'ActorCallError';\n        this.__proto__ = ActorCallError.prototype;\n        Object.setPrototypeOf(this, ActorCallError.prototype);\n    }\n}\nclass QueryCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, result) {\n        var _a;\n        const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        super(cid, methodName, 'query', {\n            Status: result.status,\n            Code: (_a = _agent_api__WEBPACK_IMPORTED_MODULE_1__.ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code \"${result.reject_code}\"`,\n            Message: result.reject_message,\n        });\n        this.result = result;\n        this.name = 'QueryCallRejectedError';\n        this.__proto__ = QueryCallRejectedError.prototype;\n        Object.setPrototypeOf(this, QueryCallRejectedError.prototype);\n    }\n}\nclass UpdateCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, requestId, response) {\n        const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        super(cid, methodName, 'update', Object.assign({ 'Request ID': (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId) }, (response.body\n            ? Object.assign(Object.assign({}, (response.body.error_code\n                ? {\n                    'Error code': response.body.error_code,\n                }\n                : {})), { 'Reject code': String(response.body.reject_code), 'Reject message': response.body.reject_message }) : {\n            'HTTP status code': response.status.toString(),\n            'HTTP status text': response.statusText,\n        })));\n        this.requestId = requestId;\n        this.response = response;\n        this.name = 'UpdateCallRejectedError';\n        this.__proto__ = UpdateCallRejectedError.prototype;\n        Object.setPrototypeOf(this, UpdateCallRejectedError.prototype);\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStDO0FBQ0U7QUFDVjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQix5REFBUztBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEMseUJBQXlCLFlBQVksR0FBRyxLQUFLO0FBQzdDLGdFQUFnRSxFQUFFLEtBQUsseUJBQXlCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFTO0FBQzdCO0FBQ0E7QUFDQSx3QkFBd0IseURBQWlCLHdFQUF3RSxtQkFBbUI7QUFDcEk7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQix5REFBUztBQUM3Qix5REFBeUQsY0FBYyxvREFBSyxhQUFhO0FBQ3pGLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTSxrR0FBa0c7QUFDNUg7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2FnZW50QDIuMS4zX0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjNfX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCB7IFJlcGxpY2FSZWplY3RDb2RlLCB9IGZyb20gJy4vYWdlbnQvYXBpJztcbmltcG9ydCB7IHRvSGV4IH0gZnJvbSAnLi91dGlscy9idWZmZXInO1xuLyoqXG4gKiBBbiBlcnJvciB0aGF0IGhhcHBlbnMgaW4gdGhlIEFnZW50LiBUaGlzIGlzIHRoZSByb290IG9mIGFsbCBlcnJvcnMgYW5kIHNob3VsZCBiZSB1c2VkXG4gKiBldmVyeXdoZXJlIGluIHRoZSBBZ2VudCBjb2RlICh0aGlzIHBhY2thZ2UpLlxuICogQHRvZG8gaHR0cHM6Ly9naXRodWIuY29tL2RmaW5pdHkvYWdlbnQtanMvaXNzdWVzLzQyMFxuICovXG5leHBvcnQgY2xhc3MgQWdlbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQWdlbnRFcnJvcic7XG4gICAgICAgIHRoaXMuX19wcm90b19fID0gQWdlbnRFcnJvci5wcm90b3R5cGU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBBZ2VudEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFjdG9yQ2FsbEVycm9yIGV4dGVuZHMgQWdlbnRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgICAgY29uc3QgY2lkID0gUHJpbmNpcGFsLmZyb20oY2FuaXN0ZXJJZCk7XG4gICAgICAgIHN1cGVyKFtcbiAgICAgICAgICAgIGBDYWxsIGZhaWxlZDpgLFxuICAgICAgICAgICAgYCAgQ2FuaXN0ZXI6ICR7Y2lkLnRvVGV4dCgpfWAsXG4gICAgICAgICAgICBgICBNZXRob2Q6ICR7bWV0aG9kTmFtZX0gKCR7dHlwZX0pYCxcbiAgICAgICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BzKS5tYXAobiA9PiBgICBcIiR7bn1cIjogJHtKU09OLnN0cmluZ2lmeShwcm9wc1tuXSl9YCksXG4gICAgICAgIF0uam9pbignXFxuJykpO1xuICAgICAgICB0aGlzLmNhbmlzdGVySWQgPSBjYW5pc3RlcklkO1xuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBY3RvckNhbGxFcnJvcic7XG4gICAgICAgIHRoaXMuX19wcm90b19fID0gQWN0b3JDYWxsRXJyb3IucHJvdG90eXBlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQWN0b3JDYWxsRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUXVlcnlDYWxsUmVqZWN0ZWRFcnJvciBleHRlbmRzIEFjdG9yQ2FsbEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYW5pc3RlcklkLCBtZXRob2ROYW1lLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjaWQgPSBQcmluY2lwYWwuZnJvbShjYW5pc3RlcklkKTtcbiAgICAgICAgc3VwZXIoY2lkLCBtZXRob2ROYW1lLCAncXVlcnknLCB7XG4gICAgICAgICAgICBTdGF0dXM6IHJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgICBDb2RlOiAoX2EgPSBSZXBsaWNhUmVqZWN0Q29kZVtyZXN1bHQucmVqZWN0X2NvZGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBgVW5rbm93biBDb2RlIFwiJHtyZXN1bHQucmVqZWN0X2NvZGV9XCJgLFxuICAgICAgICAgICAgTWVzc2FnZTogcmVzdWx0LnJlamVjdF9tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMubmFtZSA9ICdRdWVyeUNhbGxSZWplY3RlZEVycm9yJztcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBRdWVyeUNhbGxSZWplY3RlZEVycm9yLnByb3RvdHlwZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFF1ZXJ5Q2FsbFJlamVjdGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVXBkYXRlQ2FsbFJlamVjdGVkRXJyb3IgZXh0ZW5kcyBBY3RvckNhbGxFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgcmVxdWVzdElkLCByZXNwb25zZSkge1xuICAgICAgICBjb25zdCBjaWQgPSBQcmluY2lwYWwuZnJvbShjYW5pc3RlcklkKTtcbiAgICAgICAgc3VwZXIoY2lkLCBtZXRob2ROYW1lLCAndXBkYXRlJywgT2JqZWN0LmFzc2lnbih7ICdSZXF1ZXN0IElEJzogdG9IZXgocmVxdWVzdElkKSB9LCAocmVzcG9uc2UuYm9keVxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChyZXNwb25zZS5ib2R5LmVycm9yX2NvZGVcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGNvZGUnOiByZXNwb25zZS5ib2R5LmVycm9yX2NvZGUsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pKSwgeyAnUmVqZWN0IGNvZGUnOiBTdHJpbmcocmVzcG9uc2UuYm9keS5yZWplY3RfY29kZSksICdSZWplY3QgbWVzc2FnZSc6IHJlc3BvbnNlLmJvZHkucmVqZWN0X21lc3NhZ2UgfSkgOiB7XG4gICAgICAgICAgICAnSFRUUCBzdGF0dXMgY29kZSc6IHJlc3BvbnNlLnN0YXR1cy50b1N0cmluZygpLFxuICAgICAgICAgICAgJ0hUVFAgc3RhdHVzIHRleHQnOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB9KSkpO1xuICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVXBkYXRlQ2FsbFJlamVjdGVkRXJyb3InO1xuICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IFVwZGF0ZUNhbGxSZWplY3RlZEVycm9yLnByb3RvdHlwZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFVwZGF0ZUNhbGxSZWplY3RlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/errors.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/fetch_candid.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/fetch_candid.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchCandid: () => (/* binding */ fetchCandid)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _canisterStatus_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canisterStatus/index */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\");\n/* harmony import */ var _agent_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent/http */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/index.js\");\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actor */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/actor.js\");\n\n\n\n\n/**\n * Retrieves the Candid interface for the specified canister.\n *\n * @param agent The agent to use for the request (usually an `HttpAgent`)\n * @param canisterId A string corresponding to the canister ID\n * @returns Candid source code\n */\nasync function fetchCandid(canisterId, agent) {\n    if (!agent) {\n        // Create an anonymous `HttpAgent` (adapted from Candid UI)\n        agent = await _agent_http__WEBPACK_IMPORTED_MODULE_2__.HttpAgent.create();\n    }\n    // Attempt to use canister metadata\n    const status = await _canisterStatus_index__WEBPACK_IMPORTED_MODULE_1__.request({\n        agent,\n        canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(canisterId),\n        paths: ['candid'],\n    });\n    const candid = status.get('candid');\n    if (candid) {\n        return candid;\n    }\n    // Use `__get_candid_interface_tmp_hack` for canisters without Candid metadata\n    const tmpHackInterface = ({ IDL }) => IDL.Service({\n        __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ['query']),\n    });\n    const actor = _actor__WEBPACK_IMPORTED_MODULE_3__.Actor.createActor(tmpHackInterface, { agent, canisterId });\n    return (await actor.__get_candid_interface_tmp_hack());\n}\n//# sourceMappingURL=fetch_candid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2ZldGNoX2NhbmRpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErQztBQUNVO0FBQ2hCO0FBQ1Q7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0Isa0RBQVM7QUFDL0I7QUFDQTtBQUNBLHlCQUF5QiwwREFBc0I7QUFDL0M7QUFDQSxvQkFBb0IseURBQVM7QUFDN0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDO0FBQ0EsS0FBSztBQUNMLGtCQUFrQix5Q0FBSyxpQ0FBaUMsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vZmV0Y2hfY2FuZGlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgKiBhcyBDYW5pc3RlclN0YXR1cyBmcm9tICcuL2NhbmlzdGVyU3RhdHVzL2luZGV4JztcbmltcG9ydCB7IEh0dHBBZ2VudCB9IGZyb20gJy4vYWdlbnQvaHR0cCc7XG5pbXBvcnQgeyBBY3RvciB9IGZyb20gJy4vYWN0b3InO1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIENhbmRpZCBpbnRlcmZhY2UgZm9yIHRoZSBzcGVjaWZpZWQgY2FuaXN0ZXIuXG4gKlxuICogQHBhcmFtIGFnZW50IFRoZSBhZ2VudCB0byB1c2UgZm9yIHRoZSByZXF1ZXN0ICh1c3VhbGx5IGFuIGBIdHRwQWdlbnRgKVxuICogQHBhcmFtIGNhbmlzdGVySWQgQSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGUgY2FuaXN0ZXIgSURcbiAqIEByZXR1cm5zIENhbmRpZCBzb3VyY2UgY29kZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDYW5kaWQoY2FuaXN0ZXJJZCwgYWdlbnQpIHtcbiAgICBpZiAoIWFnZW50KSB7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBhbm9ueW1vdXMgYEh0dHBBZ2VudGAgKGFkYXB0ZWQgZnJvbSBDYW5kaWQgVUkpXG4gICAgICAgIGFnZW50ID0gYXdhaXQgSHR0cEFnZW50LmNyZWF0ZSgpO1xuICAgIH1cbiAgICAvLyBBdHRlbXB0IHRvIHVzZSBjYW5pc3RlciBtZXRhZGF0YVxuICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IENhbmlzdGVyU3RhdHVzLnJlcXVlc3Qoe1xuICAgICAgICBhZ2VudCxcbiAgICAgICAgY2FuaXN0ZXJJZDogUHJpbmNpcGFsLmZyb21UZXh0KGNhbmlzdGVySWQpLFxuICAgICAgICBwYXRoczogWydjYW5kaWQnXSxcbiAgICB9KTtcbiAgICBjb25zdCBjYW5kaWQgPSBzdGF0dXMuZ2V0KCdjYW5kaWQnKTtcbiAgICBpZiAoY2FuZGlkKSB7XG4gICAgICAgIHJldHVybiBjYW5kaWQ7XG4gICAgfVxuICAgIC8vIFVzZSBgX19nZXRfY2FuZGlkX2ludGVyZmFjZV90bXBfaGFja2AgZm9yIGNhbmlzdGVycyB3aXRob3V0IENhbmRpZCBtZXRhZGF0YVxuICAgIGNvbnN0IHRtcEhhY2tJbnRlcmZhY2UgPSAoeyBJREwgfSkgPT4gSURMLlNlcnZpY2Uoe1xuICAgICAgICBfX2dldF9jYW5kaWRfaW50ZXJmYWNlX3RtcF9oYWNrOiBJREwuRnVuYyhbXSwgW0lETC5UZXh0XSwgWydxdWVyeSddKSxcbiAgICB9KTtcbiAgICBjb25zdCBhY3RvciA9IEFjdG9yLmNyZWF0ZUFjdG9yKHRtcEhhY2tJbnRlcmZhY2UsIHsgYWdlbnQsIGNhbmlzdGVySWQgfSk7XG4gICAgcmV0dXJuIChhd2FpdCBhY3Rvci5fX2dldF9jYW5kaWRfaW50ZXJmYWNlX3RtcF9oYWNrKCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2hfY2FuZGlkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/fetch_candid.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/index.js":
/*!***********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/index.js ***!
  \***********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanisterStatus: () => (/* reexport module object */ _canisterStatus__WEBPACK_IMPORTED_MODULE_15__),\n/* harmony export */   Cbor: () => (/* reexport module object */ _cbor__WEBPACK_IMPORTED_MODULE_16__),\n/* harmony export */   polling: () => (/* reexport module object */ _polling__WEBPACK_IMPORTED_MODULE_14__)\n/* harmony export */ });\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actor */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/actor.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _actor__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _actor__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/index.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _agent__WEBPACK_IMPORTED_MODULE_1__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _agent__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _agent_http_transforms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent/http/transforms */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _agent_http_transforms__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _agent_http_transforms__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _agent_http_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./agent/http/types */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _agent_http_types__WEBPACK_IMPORTED_MODULE_3__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _agent_http_types__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./auth */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/auth.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _auth__WEBPACK_IMPORTED_MODULE_4__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _auth__WEBPACK_IMPORTED_MODULE_4__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _canisters_asset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./canisters/asset */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisters/asset.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _canisters_asset__WEBPACK_IMPORTED_MODULE_5__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _canisters_asset__WEBPACK_IMPORTED_MODULE_5__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./certificate */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _certificate__WEBPACK_IMPORTED_MODULE_6__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _certificate__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _der__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./der */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/der.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _der__WEBPACK_IMPORTED_MODULE_7__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _der__WEBPACK_IMPORTED_MODULE_7__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _fetch_candid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fetch_candid */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/fetch_candid.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _fetch_candid__WEBPACK_IMPORTED_MODULE_8__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _fetch_candid__WEBPACK_IMPORTED_MODULE_8__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _public_key__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./public_key */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/public_key.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _public_key__WEBPACK_IMPORTED_MODULE_9__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _public_key__WEBPACK_IMPORTED_MODULE_9__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./request_id */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _request_id__WEBPACK_IMPORTED_MODULE_10__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _request_id__WEBPACK_IMPORTED_MODULE_10__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _utils_bls__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/bls */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/bls.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _utils_bls__WEBPACK_IMPORTED_MODULE_11__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _utils_bls__WEBPACK_IMPORTED_MODULE_11__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _utils_buffer__WEBPACK_IMPORTED_MODULE_12__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _utils_buffer__WEBPACK_IMPORTED_MODULE_12__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/random */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/random.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _utils_random__WEBPACK_IMPORTED_MODULE_13__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _utils_random__WEBPACK_IMPORTED_MODULE_13__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./polling */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/index.js\");\n/* harmony import */ var _canisterStatus__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./canisterStatus */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\");\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./cbor */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _polling__WEBPACK_IMPORTED_MODULE_14__) if([\"default\",\"polling\",\"CanisterStatus\",\"Cbor\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _polling__WEBPACK_IMPORTED_MODULE_14__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdCO0FBQ0E7QUFDZ0I7QUFDTDtBQUNaO0FBQ1c7QUFDSjtBQUNSO0FBQ1M7QUFDRjtBQUNBO0FBQ0Q7QUFDRztBQUNBO0FBQ007QUFDYztBQUNwQjtBQUNMO0FBQzFCIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2FnZW50QDIuMS4zX0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjNfX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2FjdG9yJztcbmV4cG9ydCAqIGZyb20gJy4vYWdlbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9hZ2VudC9odHRwL3RyYW5zZm9ybXMnO1xuZXhwb3J0ICogZnJvbSAnLi9hZ2VudC9odHRwL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vYXV0aCc7XG5leHBvcnQgKiBmcm9tICcuL2NhbmlzdGVycy9hc3NldCc7XG5leHBvcnQgKiBmcm9tICcuL2NlcnRpZmljYXRlJztcbmV4cG9ydCAqIGZyb20gJy4vZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vZmV0Y2hfY2FuZGlkJztcbmV4cG9ydCAqIGZyb20gJy4vcHVibGljX2tleSc7XG5leHBvcnQgKiBmcm9tICcuL3JlcXVlc3RfaWQnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9ibHMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9idWZmZXInO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9yYW5kb20nO1xuZXhwb3J0ICogYXMgcG9sbGluZyBmcm9tICcuL3BvbGxpbmcnO1xuZXhwb3J0ICogYXMgQ2FuaXN0ZXJTdGF0dXMgZnJvbSAnLi9jYW5pc3RlclN0YXR1cyc7XG5leHBvcnQgKiBhcyBDYm9yIGZyb20gJy4vY2Jvcic7XG5leHBvcnQgKiBmcm9tICcuL3BvbGxpbmcnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/observable.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/observable.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observable: () => (/* binding */ Observable),\n/* harmony export */   ObservableLog: () => (/* binding */ ObservableLog)\n/* harmony export */ });\nclass Observable {\n    constructor() {\n        this.observers = [];\n    }\n    subscribe(func) {\n        this.observers.push(func);\n    }\n    unsubscribe(func) {\n        this.observers = this.observers.filter(observer => observer !== func);\n    }\n    notify(data, ...rest) {\n        this.observers.forEach(observer => observer(data, ...rest));\n    }\n}\nclass ObservableLog extends Observable {\n    constructor() {\n        super();\n    }\n    print(message, ...rest) {\n        this.notify({ message, level: 'info' }, ...rest);\n    }\n    warn(message, ...rest) {\n        this.notify({ message, level: 'warn' }, ...rest);\n    }\n    error(message, error, ...rest) {\n        this.notify({ message, level: 'error', error }, ...rest);\n    }\n}\n//# sourceMappingURL=observable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL29ic2VydmFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2FnZW50QDIuMS4zX0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjNfX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9vYnNlcnZhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBPYnNlcnZhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChmdW5jKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoZnVuYykge1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzLmZpbHRlcihvYnNlcnZlciA9PiBvYnNlcnZlciAhPT0gZnVuYyk7XG4gICAgfVxuICAgIG5vdGlmeShkYXRhLCAuLi5yZXN0KSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIoZGF0YSwgLi4ucmVzdCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPYnNlcnZhYmxlTG9nIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIHByaW50KG1lc3NhZ2UsIC4uLnJlc3QpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoeyBtZXNzYWdlLCBsZXZlbDogJ2luZm8nIH0sIC4uLnJlc3QpO1xuICAgIH1cbiAgICB3YXJuKG1lc3NhZ2UsIC4uLnJlc3QpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoeyBtZXNzYWdlLCBsZXZlbDogJ3dhcm4nIH0sIC4uLnJlc3QpO1xuICAgIH1cbiAgICBlcnJvcihtZXNzYWdlLCBlcnJvciwgLi4ucmVzdCkge1xuICAgICAgICB0aGlzLm5vdGlmeSh7IG1lc3NhZ2UsIGxldmVsOiAnZXJyb3InLCBlcnJvciB9LCAuLi5yZXN0KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/observable.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/backoff.js":
/*!*********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/backoff.js ***!
  \*********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExponentialBackoff: () => (/* binding */ ExponentialBackoff),\n/* harmony export */   exponentialBackoff: () => (/* binding */ exponentialBackoff)\n/* harmony export */ });\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ExponentialBackoff_currentInterval, _ExponentialBackoff_randomizationFactor, _ExponentialBackoff_multiplier, _ExponentialBackoff_maxInterval, _ExponentialBackoff_startTime, _ExponentialBackoff_maxElapsedTime, _ExponentialBackoff_maxIterations, _ExponentialBackoff_date, _ExponentialBackoff_count;\nconst RANDOMIZATION_FACTOR = 0.5;\nconst MULTIPLIER = 1.5;\nconst INITIAL_INTERVAL_MSEC = 500;\nconst MAX_INTERVAL_MSEC = 60000;\nconst MAX_ELAPSED_TIME_MSEC = 900000;\nconst MAX_ITERATIONS = 10;\n/**\n * Exponential backoff strategy.\n */\nclass ExponentialBackoff {\n    constructor(options = ExponentialBackoff.default) {\n        _ExponentialBackoff_currentInterval.set(this, void 0);\n        _ExponentialBackoff_randomizationFactor.set(this, void 0);\n        _ExponentialBackoff_multiplier.set(this, void 0);\n        _ExponentialBackoff_maxInterval.set(this, void 0);\n        _ExponentialBackoff_startTime.set(this, void 0);\n        _ExponentialBackoff_maxElapsedTime.set(this, void 0);\n        _ExponentialBackoff_maxIterations.set(this, void 0);\n        _ExponentialBackoff_date.set(this, void 0);\n        _ExponentialBackoff_count.set(this, 0);\n        const { initialInterval = INITIAL_INTERVAL_MSEC, randomizationFactor = RANDOMIZATION_FACTOR, multiplier = MULTIPLIER, maxInterval = MAX_INTERVAL_MSEC, maxElapsedTime = MAX_ELAPSED_TIME_MSEC, maxIterations = MAX_ITERATIONS, date = Date, } = options;\n        __classPrivateFieldSet(this, _ExponentialBackoff_currentInterval, initialInterval, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_randomizationFactor, randomizationFactor, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_multiplier, multiplier, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_maxInterval, maxInterval, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_date, date, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_startTime, date.now(), \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_maxElapsedTime, maxElapsedTime, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_maxIterations, maxIterations, \"f\");\n    }\n    get ellapsedTimeInMsec() {\n        return __classPrivateFieldGet(this, _ExponentialBackoff_date, \"f\").now() - __classPrivateFieldGet(this, _ExponentialBackoff_startTime, \"f\");\n    }\n    get currentInterval() {\n        return __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\");\n    }\n    get count() {\n        return __classPrivateFieldGet(this, _ExponentialBackoff_count, \"f\");\n    }\n    get randomValueFromInterval() {\n        const delta = __classPrivateFieldGet(this, _ExponentialBackoff_randomizationFactor, \"f\") * __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\");\n        const min = __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\") - delta;\n        const max = __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\") + delta;\n        return Math.random() * (max - min) + min;\n    }\n    incrementCurrentInterval() {\n        var _a;\n        __classPrivateFieldSet(this, _ExponentialBackoff_currentInterval, Math.min(__classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\") * __classPrivateFieldGet(this, _ExponentialBackoff_multiplier, \"f\"), __classPrivateFieldGet(this, _ExponentialBackoff_maxInterval, \"f\")), \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_count, (_a = __classPrivateFieldGet(this, _ExponentialBackoff_count, \"f\"), _a++, _a), \"f\");\n        return __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\");\n    }\n    next() {\n        if (this.ellapsedTimeInMsec >= __classPrivateFieldGet(this, _ExponentialBackoff_maxElapsedTime, \"f\") || __classPrivateFieldGet(this, _ExponentialBackoff_count, \"f\") >= __classPrivateFieldGet(this, _ExponentialBackoff_maxIterations, \"f\")) {\n            return null;\n        }\n        else {\n            this.incrementCurrentInterval();\n            return this.randomValueFromInterval;\n        }\n    }\n}\n_ExponentialBackoff_currentInterval = new WeakMap(), _ExponentialBackoff_randomizationFactor = new WeakMap(), _ExponentialBackoff_multiplier = new WeakMap(), _ExponentialBackoff_maxInterval = new WeakMap(), _ExponentialBackoff_startTime = new WeakMap(), _ExponentialBackoff_maxElapsedTime = new WeakMap(), _ExponentialBackoff_maxIterations = new WeakMap(), _ExponentialBackoff_date = new WeakMap(), _ExponentialBackoff_count = new WeakMap();\nExponentialBackoff.default = {\n    initialInterval: INITIAL_INTERVAL_MSEC,\n    randomizationFactor: RANDOMIZATION_FACTOR,\n    multiplier: MULTIPLIER,\n    maxInterval: MAX_INTERVAL_MSEC,\n    // 1 minute\n    maxElapsedTime: MAX_ELAPSED_TIME_MSEC,\n    maxIterations: MAX_ITERATIONS,\n    date: Date,\n};\n/**\n * Utility function to create an exponential backoff iterator.\n * @param options - for the exponential backoff\n * @returns an iterator that yields the next delay in the exponential backoff\n * @yields the next delay in the exponential backoff\n */\nfunction* exponentialBackoff(options = ExponentialBackoff.default) {\n    const backoff = new ExponentialBackoff(options);\n    let next = backoff.next();\n    while (next) {\n        yield next;\n        next = backoff.next();\n    }\n}\n//# sourceMappingURL=backoff.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvYmFja29mZi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDhCQUE4QixTQUFJLElBQUksU0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNPQUFzTztBQUN0UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvYmFja29mZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0V4cG9uZW50aWFsQmFja29mZl9jdXJyZW50SW50ZXJ2YWwsIF9FeHBvbmVudGlhbEJhY2tvZmZfcmFuZG9taXphdGlvbkZhY3RvciwgX0V4cG9uZW50aWFsQmFja29mZl9tdWx0aXBsaWVyLCBfRXhwb25lbnRpYWxCYWNrb2ZmX21heEludGVydmFsLCBfRXhwb25lbnRpYWxCYWNrb2ZmX3N0YXJ0VGltZSwgX0V4cG9uZW50aWFsQmFja29mZl9tYXhFbGFwc2VkVGltZSwgX0V4cG9uZW50aWFsQmFja29mZl9tYXhJdGVyYXRpb25zLCBfRXhwb25lbnRpYWxCYWNrb2ZmX2RhdGUsIF9FeHBvbmVudGlhbEJhY2tvZmZfY291bnQ7XG5jb25zdCBSQU5ET01JWkFUSU9OX0ZBQ1RPUiA9IDAuNTtcbmNvbnN0IE1VTFRJUExJRVIgPSAxLjU7XG5jb25zdCBJTklUSUFMX0lOVEVSVkFMX01TRUMgPSA1MDA7XG5jb25zdCBNQVhfSU5URVJWQUxfTVNFQyA9IDYwMDAwO1xuY29uc3QgTUFYX0VMQVBTRURfVElNRV9NU0VDID0gOTAwMDAwO1xuY29uc3QgTUFYX0lURVJBVElPTlMgPSAxMDtcbi8qKlxuICogRXhwb25lbnRpYWwgYmFja29mZiBzdHJhdGVneS5cbiAqL1xuZXhwb3J0IGNsYXNzIEV4cG9uZW50aWFsQmFja29mZiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IEV4cG9uZW50aWFsQmFja29mZi5kZWZhdWx0KSB7XG4gICAgICAgIF9FeHBvbmVudGlhbEJhY2tvZmZfY3VycmVudEludGVydmFsLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRXhwb25lbnRpYWxCYWNrb2ZmX3JhbmRvbWl6YXRpb25GYWN0b3Iuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FeHBvbmVudGlhbEJhY2tvZmZfbXVsdGlwbGllci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0V4cG9uZW50aWFsQmFja29mZl9tYXhJbnRlcnZhbC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0V4cG9uZW50aWFsQmFja29mZl9zdGFydFRpbWUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4RWxhcHNlZFRpbWUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4SXRlcmF0aW9ucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0V4cG9uZW50aWFsQmFja29mZl9kYXRlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRXhwb25lbnRpYWxCYWNrb2ZmX2NvdW50LnNldCh0aGlzLCAwKTtcbiAgICAgICAgY29uc3QgeyBpbml0aWFsSW50ZXJ2YWwgPSBJTklUSUFMX0lOVEVSVkFMX01TRUMsIHJhbmRvbWl6YXRpb25GYWN0b3IgPSBSQU5ET01JWkFUSU9OX0ZBQ1RPUiwgbXVsdGlwbGllciA9IE1VTFRJUExJRVIsIG1heEludGVydmFsID0gTUFYX0lOVEVSVkFMX01TRUMsIG1heEVsYXBzZWRUaW1lID0gTUFYX0VMQVBTRURfVElNRV9NU0VDLCBtYXhJdGVyYXRpb25zID0gTUFYX0lURVJBVElPTlMsIGRhdGUgPSBEYXRlLCB9ID0gb3B0aW9ucztcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX2N1cnJlbnRJbnRlcnZhbCwgaW5pdGlhbEludGVydmFsLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9yYW5kb21pemF0aW9uRmFjdG9yLCByYW5kb21pemF0aW9uRmFjdG9yLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9tdWx0aXBsaWVyLCBtdWx0aXBsaWVyLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9tYXhJbnRlcnZhbCwgbWF4SW50ZXJ2YWwsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX2RhdGUsIGRhdGUsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX3N0YXJ0VGltZSwgZGF0ZS5ub3coKSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4RWxhcHNlZFRpbWUsIG1heEVsYXBzZWRUaW1lLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9tYXhJdGVyYXRpb25zLCBtYXhJdGVyYXRpb25zLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBlbGxhcHNlZFRpbWVJbk1zZWMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfZGF0ZSwgXCJmXCIpLm5vdygpIC0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX3N0YXJ0VGltZSwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEludGVydmFsKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX2N1cnJlbnRJbnRlcnZhbCwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgY291bnQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfY291bnQsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IHJhbmRvbVZhbHVlRnJvbUludGVydmFsKCkge1xuICAgICAgICBjb25zdCBkZWx0YSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9yYW5kb21pemF0aW9uRmFjdG9yLCBcImZcIikgKiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfY3VycmVudEludGVydmFsLCBcImZcIik7XG4gICAgICAgIGNvbnN0IG1pbiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9jdXJyZW50SW50ZXJ2YWwsIFwiZlwiKSAtIGRlbHRhO1xuICAgICAgICBjb25zdCBtYXggPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfY3VycmVudEludGVydmFsLCBcImZcIikgKyBkZWx0YTtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICB9XG4gICAgaW5jcmVtZW50Q3VycmVudEludGVydmFsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9jdXJyZW50SW50ZXJ2YWwsIE1hdGgubWluKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9jdXJyZW50SW50ZXJ2YWwsIFwiZlwiKSAqIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9tdWx0aXBsaWVyLCBcImZcIiksIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9tYXhJbnRlcnZhbCwgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfY291bnQsIChfYSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9jb3VudCwgXCJmXCIpLCBfYSsrLCBfYSksIFwiZlwiKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9jdXJyZW50SW50ZXJ2YWwsIFwiZlwiKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxsYXBzZWRUaW1lSW5Nc2VjID49IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9tYXhFbGFwc2VkVGltZSwgXCJmXCIpIHx8IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9jb3VudCwgXCJmXCIpID49IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9tYXhJdGVyYXRpb25zLCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRDdXJyZW50SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmRvbVZhbHVlRnJvbUludGVydmFsO1xuICAgICAgICB9XG4gICAgfVxufVxuX0V4cG9uZW50aWFsQmFja29mZl9jdXJyZW50SW50ZXJ2YWwgPSBuZXcgV2Vha01hcCgpLCBfRXhwb25lbnRpYWxCYWNrb2ZmX3JhbmRvbWl6YXRpb25GYWN0b3IgPSBuZXcgV2Vha01hcCgpLCBfRXhwb25lbnRpYWxCYWNrb2ZmX211bHRpcGxpZXIgPSBuZXcgV2Vha01hcCgpLCBfRXhwb25lbnRpYWxCYWNrb2ZmX21heEludGVydmFsID0gbmV3IFdlYWtNYXAoKSwgX0V4cG9uZW50aWFsQmFja29mZl9zdGFydFRpbWUgPSBuZXcgV2Vha01hcCgpLCBfRXhwb25lbnRpYWxCYWNrb2ZmX21heEVsYXBzZWRUaW1lID0gbmV3IFdlYWtNYXAoKSwgX0V4cG9uZW50aWFsQmFja29mZl9tYXhJdGVyYXRpb25zID0gbmV3IFdlYWtNYXAoKSwgX0V4cG9uZW50aWFsQmFja29mZl9kYXRlID0gbmV3IFdlYWtNYXAoKSwgX0V4cG9uZW50aWFsQmFja29mZl9jb3VudCA9IG5ldyBXZWFrTWFwKCk7XG5FeHBvbmVudGlhbEJhY2tvZmYuZGVmYXVsdCA9IHtcbiAgICBpbml0aWFsSW50ZXJ2YWw6IElOSVRJQUxfSU5URVJWQUxfTVNFQyxcbiAgICByYW5kb21pemF0aW9uRmFjdG9yOiBSQU5ET01JWkFUSU9OX0ZBQ1RPUixcbiAgICBtdWx0aXBsaWVyOiBNVUxUSVBMSUVSLFxuICAgIG1heEludGVydmFsOiBNQVhfSU5URVJWQUxfTVNFQyxcbiAgICAvLyAxIG1pbnV0ZVxuICAgIG1heEVsYXBzZWRUaW1lOiBNQVhfRUxBUFNFRF9USU1FX01TRUMsXG4gICAgbWF4SXRlcmF0aW9uczogTUFYX0lURVJBVElPTlMsXG4gICAgZGF0ZTogRGF0ZSxcbn07XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYgaXRlcmF0b3IuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIGZvciB0aGUgZXhwb25lbnRpYWwgYmFja29mZlxuICogQHJldHVybnMgYW4gaXRlcmF0b3IgdGhhdCB5aWVsZHMgdGhlIG5leHQgZGVsYXkgaW4gdGhlIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqIEB5aWVsZHMgdGhlIG5leHQgZGVsYXkgaW4gdGhlIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBleHBvbmVudGlhbEJhY2tvZmYob3B0aW9ucyA9IEV4cG9uZW50aWFsQmFja29mZi5kZWZhdWx0KSB7XG4gICAgY29uc3QgYmFja29mZiA9IG5ldyBFeHBvbmVudGlhbEJhY2tvZmYob3B0aW9ucyk7XG4gICAgbGV0IG5leHQgPSBiYWNrb2ZmLm5leHQoKTtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICB5aWVsZCBuZXh0O1xuICAgICAgICBuZXh0ID0gYmFja29mZi5uZXh0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja29mZi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/backoff.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/index.js":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/index.js ***!
  \*******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultStrategy: () => (/* reexport safe */ _strategy__WEBPACK_IMPORTED_MODULE_3__.defaultStrategy),\n/* harmony export */   pollForResponse: () => (/* binding */ pollForResponse),\n/* harmony export */   strategy: () => (/* reexport module object */ _strategy__WEBPACK_IMPORTED_MODULE_3__)\n/* harmony export */ });\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../agent */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/agent/index.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../certificate */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _strategy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strategy */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/strategy.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/constants.js\");\n\n\n\n\n\n\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n * @param blsVerify - optional replacement function that verifies the BLS signature of a certificate.\n */\nasync function pollForResponse(agent, canisterId, requestId, strategy = (0,_strategy__WEBPACK_IMPORTED_MODULE_3__.defaultStrategy)(), \n// eslint-disable-next-line\nrequest, blsVerify) {\n    var _a;\n    const path = [new TextEncoder().encode('request_status'), requestId];\n    const currentRequest = request !== null && request !== void 0 ? request : (await ((_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, { paths: [path] })));\n    // Use a fresh expiry for the readState call.\n    currentRequest.body.content.ingress_expiry = new _agent__WEBPACK_IMPORTED_MODULE_0__.Expiry(_constants__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n    const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n    if (agent.rootKey == null)\n        throw new Error('Agent root key not initialized before polling');\n    const cert = await _certificate__WEBPACK_IMPORTED_MODULE_1__.Certificate.create({\n        certificate: state.certificate,\n        rootKey: agent.rootKey,\n        canisterId: canisterId,\n        blsVerify,\n    });\n    const maybeBuf = (0,_certificate__WEBPACK_IMPORTED_MODULE_1__.lookupResultToBuffer)(cert.lookup([...path, new TextEncoder().encode('status')]));\n    let status;\n    if (typeof maybeBuf === 'undefined') {\n        // Missing requestId means we need to wait\n        status = _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Unknown;\n    }\n    else {\n        status = new TextDecoder().decode(maybeBuf);\n    }\n    switch (status) {\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Replied: {\n            return {\n                reply: (0,_certificate__WEBPACK_IMPORTED_MODULE_1__.lookupResultToBuffer)(cert.lookup([...path, 'reply'])),\n                certificate: cert,\n            };\n        }\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Received:\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Unknown:\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Processing:\n            // Execute the polling strategy, then retry.\n            await strategy(canisterId, requestId, status);\n            return pollForResponse(agent, canisterId, requestId, strategy, currentRequest, blsVerify);\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Rejected: {\n            const rejectCode = new Uint8Array((0,_certificate__WEBPACK_IMPORTED_MODULE_1__.lookupResultToBuffer)(cert.lookup([...path, 'reject_code'])))[0];\n            const rejectMessage = new TextDecoder().decode((0,_certificate__WEBPACK_IMPORTED_MODULE_1__.lookupResultToBuffer)(cert.lookup([...path, 'reject_message'])));\n            throw new Error(`Call was rejected:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId)}\\n` +\n                `  Reject code: ${rejectCode}\\n` +\n                `  Reject text: ${rejectMessage}\\n`);\n        }\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Done:\n            // This is _technically_ not an error, but we still didn't see the `Replied` status so\n            // we don't know the result and cannot decode it.\n            throw new Error(`Call was marked as done but we never saw the reply:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId)}\\n`);\n    }\n    throw new Error('unreachable');\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBK0Q7QUFDSTtBQUMzQjtBQUNEO0FBQ007QUFDd0I7QUFDeEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3RUFBd0UsMERBQWU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnTEFBZ0wsZUFBZTtBQUMvTDtBQUNBLHFEQUFxRCwwQ0FBTSxDQUFDLDZFQUFxQztBQUNqRyxzREFBc0QsZUFBZTtBQUNyRTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixrRUFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtEQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrREFBMkI7QUFDeEM7QUFDQSx1QkFBdUIsa0VBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0RBQTJCO0FBQ3hDLGFBQWEsK0RBQTJCO0FBQ3hDLGFBQWEsK0RBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0RBQTJCO0FBQ3hDLDhDQUE4QyxrRUFBb0I7QUFDbEUsMkRBQTJELGtFQUFvQjtBQUMvRTtBQUNBLGlDQUFpQyxvREFBSyxZQUFZO0FBQ2xELGtDQUFrQyxXQUFXO0FBQzdDLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0EsYUFBYSwrREFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9EQUFLLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXhwaXJ5LCBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMgfSBmcm9tICcuLi9hZ2VudCc7XG5pbXBvcnQgeyBDZXJ0aWZpY2F0ZSwgbG9va3VwUmVzdWx0VG9CdWZmZXIgfSBmcm9tICcuLi9jZXJ0aWZpY2F0ZSc7XG5pbXBvcnQgeyB0b0hleCB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlcic7XG5leHBvcnQgKiBhcyBzdHJhdGVneSBmcm9tICcuL3N0cmF0ZWd5JztcbmltcG9ydCB7IGRlZmF1bHRTdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ3knO1xuaW1wb3J0IHsgREVGQVVMVF9JTkdSRVNTX0VYUElSWV9ERUxUQV9JTl9NU0VDUyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5leHBvcnQgeyBkZWZhdWx0U3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWd5Jztcbi8qKlxuICogUG9sbHMgdGhlIElDIHRvIGNoZWNrIHRoZSBzdGF0dXMgb2YgdGhlIGdpdmVuIHJlcXVlc3QgdGhlblxuICogcmV0dXJucyB0aGUgcmVzcG9uc2UgYnl0ZXMgb25jZSB0aGUgcmVxdWVzdCBoYXMgYmVlbiBwcm9jZXNzZWQuXG4gKiBAcGFyYW0gYWdlbnQgVGhlIGFnZW50IHRvIHVzZSB0byBwb2xsIHJlYWRfc3RhdGUuXG4gKiBAcGFyYW0gY2FuaXN0ZXJJZCBUaGUgZWZmZWN0aXZlIGNhbmlzdGVyIElELlxuICogQHBhcmFtIHJlcXVlc3RJZCBUaGUgUmVxdWVzdCBJRCB0byBwb2xsIHN0YXR1cyBmb3IuXG4gKiBAcGFyYW0gc3RyYXRlZ3kgQSBwb2xsaW5nIHN0cmF0ZWd5LlxuICogQHBhcmFtIHJlcXVlc3QgUmVxdWVzdCBmb3IgdGhlIHJlYWRTdGF0ZSBjYWxsLlxuICogQHBhcmFtIGJsc1ZlcmlmeSAtIG9wdGlvbmFsIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHRoYXQgdmVyaWZpZXMgdGhlIEJMUyBzaWduYXR1cmUgb2YgYSBjZXJ0aWZpY2F0ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBvbGxGb3JSZXNwb25zZShhZ2VudCwgY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCBzdHJhdGVneSA9IGRlZmF1bHRTdHJhdGVneSgpLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxucmVxdWVzdCwgYmxzVmVyaWZ5KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBhdGggPSBbbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdyZXF1ZXN0X3N0YXR1cycpLCByZXF1ZXN0SWRdO1xuICAgIGNvbnN0IGN1cnJlbnRSZXF1ZXN0ID0gcmVxdWVzdCAhPT0gbnVsbCAmJiByZXF1ZXN0ICE9PSB2b2lkIDAgPyByZXF1ZXN0IDogKGF3YWl0ICgoX2EgPSBhZ2VudC5jcmVhdGVSZWFkU3RhdGVSZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChhZ2VudCwgeyBwYXRoczogW3BhdGhdIH0pKSk7XG4gICAgLy8gVXNlIGEgZnJlc2ggZXhwaXJ5IGZvciB0aGUgcmVhZFN0YXRlIGNhbGwuXG4gICAgY3VycmVudFJlcXVlc3QuYm9keS5jb250ZW50LmluZ3Jlc3NfZXhwaXJ5ID0gbmV3IEV4cGlyeShERUZBVUxUX0lOR1JFU1NfRVhQSVJZX0RFTFRBX0lOX01TRUNTKTtcbiAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IGFnZW50LnJlYWRTdGF0ZShjYW5pc3RlcklkLCB7IHBhdGhzOiBbcGF0aF0gfSwgdW5kZWZpbmVkLCBjdXJyZW50UmVxdWVzdCk7XG4gICAgaWYgKGFnZW50LnJvb3RLZXkgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZ2VudCByb290IGtleSBub3QgaW5pdGlhbGl6ZWQgYmVmb3JlIHBvbGxpbmcnKTtcbiAgICBjb25zdCBjZXJ0ID0gYXdhaXQgQ2VydGlmaWNhdGUuY3JlYXRlKHtcbiAgICAgICAgY2VydGlmaWNhdGU6IHN0YXRlLmNlcnRpZmljYXRlLFxuICAgICAgICByb290S2V5OiBhZ2VudC5yb290S2V5LFxuICAgICAgICBjYW5pc3RlcklkOiBjYW5pc3RlcklkLFxuICAgICAgICBibHNWZXJpZnksXG4gICAgfSk7XG4gICAgY29uc3QgbWF5YmVCdWYgPSBsb29rdXBSZXN1bHRUb0J1ZmZlcihjZXJ0Lmxvb2t1cChbLi4ucGF0aCwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdzdGF0dXMnKV0pKTtcbiAgICBsZXQgc3RhdHVzO1xuICAgIGlmICh0eXBlb2YgbWF5YmVCdWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE1pc3NpbmcgcmVxdWVzdElkIG1lYW5zIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgICBzdGF0dXMgPSBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMuVW5rbm93bjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXR1cyA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtYXliZUJ1Zik7XG4gICAgfVxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzLlJlcGxpZWQ6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVwbHk6IGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnQubG9va3VwKFsuLi5wYXRoLCAncmVwbHknXSkpLFxuICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiBjZXJ0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cy5SZWNlaXZlZDpcbiAgICAgICAgY2FzZSBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMuVW5rbm93bjpcbiAgICAgICAgY2FzZSBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMuUHJvY2Vzc2luZzpcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIHBvbGxpbmcgc3RyYXRlZ3ksIHRoZW4gcmV0cnkuXG4gICAgICAgICAgICBhd2FpdCBzdHJhdGVneShjYW5pc3RlcklkLCByZXF1ZXN0SWQsIHN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm4gcG9sbEZvclJlc3BvbnNlKGFnZW50LCBjYW5pc3RlcklkLCByZXF1ZXN0SWQsIHN0cmF0ZWd5LCBjdXJyZW50UmVxdWVzdCwgYmxzVmVyaWZ5KTtcbiAgICAgICAgY2FzZSBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMuUmVqZWN0ZWQ6IHtcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdENvZGUgPSBuZXcgVWludDhBcnJheShsb29rdXBSZXN1bHRUb0J1ZmZlcihjZXJ0Lmxvb2t1cChbLi4ucGF0aCwgJ3JlamVjdF9jb2RlJ10pKSlbMF07XG4gICAgICAgICAgICBjb25zdCByZWplY3RNZXNzYWdlID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnQubG9va3VwKFsuLi5wYXRoLCAncmVqZWN0X21lc3NhZ2UnXSkpKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbCB3YXMgcmVqZWN0ZWQ6XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgUmVxdWVzdCBJRDogJHt0b0hleChyZXF1ZXN0SWQpfVxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIFJlamVjdCBjb2RlOiAke3JlamVjdENvZGV9XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgUmVqZWN0IHRleHQ6ICR7cmVqZWN0TWVzc2FnZX1cXG5gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cy5Eb25lOlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBfdGVjaG5pY2FsbHlfIG5vdCBhbiBlcnJvciwgYnV0IHdlIHN0aWxsIGRpZG4ndCBzZWUgdGhlIGBSZXBsaWVkYCBzdGF0dXMgc29cbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGtub3cgdGhlIHJlc3VsdCBhbmQgY2Fubm90IGRlY29kZSBpdC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbCB3YXMgbWFya2VkIGFzIGRvbmUgYnV0IHdlIG5ldmVyIHNhdyB0aGUgcmVwbHk6XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgUmVxdWVzdCBJRDogJHt0b0hleChyZXF1ZXN0SWQpfVxcbmApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/strategy.js":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/strategy.js ***!
  \**********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   backoff: () => (/* binding */ backoff),\n/* harmony export */   chain: () => (/* binding */ chain),\n/* harmony export */   conditionalDelay: () => (/* binding */ conditionalDelay),\n/* harmony export */   defaultStrategy: () => (/* binding */ defaultStrategy),\n/* harmony export */   maxAttempts: () => (/* binding */ maxAttempts),\n/* harmony export */   once: () => (/* binding */ once),\n/* harmony export */   throttle: () => (/* binding */ throttle),\n/* harmony export */   timeout: () => (/* binding */ timeout)\n/* harmony export */ });\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nfunction defaultStrategy() {\n    return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n/**\n * Predicate that returns true once.\n */\nfunction once() {\n    let first = true;\n    return async () => {\n        if (first) {\n            first = false;\n            return true;\n        }\n        return false;\n    };\n}\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nfunction conditionalDelay(condition, timeInMsec) {\n    return async (canisterId, requestId, status) => {\n        if (await condition(canisterId, requestId, status)) {\n            return new Promise(resolve => setTimeout(resolve, timeInMsec));\n        }\n    };\n}\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nfunction maxAttempts(count) {\n    let attempts = count;\n    return async (canisterId, requestId, status) => {\n        if (--attempts <= 0) {\n            throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(requestId)}\\n` +\n                `  Request status: ${status}\\n`);\n        }\n    };\n}\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nfunction throttle(throttleInMsec) {\n    return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nfunction timeout(timeInMsec) {\n    const end = Date.now() + timeInMsec;\n    return async (canisterId, requestId, status) => {\n        if (Date.now() > end) {\n            throw new Error(`Request timed out after ${timeInMsec} msec:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(requestId)}\\n` +\n                `  Request status: ${status}\\n`);\n        }\n    };\n}\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nfunction backoff(startingThrottleInMsec, backoffFactor) {\n    let currentThrottling = startingThrottleInMsec;\n    return () => new Promise(resolve => setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n    }, currentThrottling));\n}\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nfunction chain(...strategies) {\n    return async (canisterId, requestId, status) => {\n        for (const a of strategies) {\n            await a(canisterId, requestId, status);\n        }\n    };\n}\n//# sourceMappingURL=strategy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvc3RyYXRlZ3kuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsT0FBTztBQUNuRixpQ0FBaUMsb0RBQUssWUFBWTtBQUNsRCxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRSxpQ0FBaUMsb0RBQUssWUFBWTtBQUNsRCxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvc3RyYXRlZ3kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9IZXggfSBmcm9tICcuLi91dGlscy9idWZmZXInO1xuY29uc3QgRklWRV9NSU5VVEVTX0lOX01TRUMgPSA1ICogNjAgKiAxMDAwO1xuLyoqXG4gKiBBIGJlc3QgcHJhY3RpY2VzIHBvbGxpbmcgc3RyYXRlZ3k6IHdhaXQgMiBzZWNvbmRzIGJlZm9yZSB0aGUgZmlyc3QgcG9sbCwgdGhlbiAxIHNlY29uZFxuICogd2l0aCBhbiBleHBvbmVudGlhbCBiYWNrb2ZmIGZhY3RvciBvZiAxLjIuIFRpbWVvdXQgYWZ0ZXIgNSBtaW51dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiBjaGFpbihjb25kaXRpb25hbERlbGF5KG9uY2UoKSwgMTAwMCksIGJhY2tvZmYoMTAwMCwgMS4yKSwgdGltZW91dChGSVZFX01JTlVURVNfSU5fTVNFQykpO1xufVxuLyoqXG4gKiBQcmVkaWNhdGUgdGhhdCByZXR1cm5zIHRydWUgb25jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uY2UoKSB7XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbi8qKlxuICogRGVsYXkgdGhlIHBvbGxpbmcgb25jZS5cbiAqIEBwYXJhbSBjb25kaXRpb24gQSBwcmVkaWNhdGUgdGhhdCBpbmRpY2F0ZXMgd2hlbiB0byBkZWxheS5cbiAqIEBwYXJhbSB0aW1lSW5Nc2VjIFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmRpdGlvbmFsRGVsYXkoY29uZGl0aW9uLCB0aW1lSW5Nc2VjKSB7XG4gICAgcmV0dXJuIGFzeW5jIChjYW5pc3RlcklkLCByZXF1ZXN0SWQsIHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAoYXdhaXQgY29uZGl0aW9uKGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lSW5Nc2VjKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBFcnJvciBvdXQgYWZ0ZXIgYSBtYXhpbXVtIG51bWJlciBvZiBwb2xsaW5nIGhhcyBiZWVuIGRvbmUuXG4gKiBAcGFyYW0gY291bnQgVGhlIG1heGltdW0gYXR0ZW1wdHMgdG8gcG9sbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heEF0dGVtcHRzKGNvdW50KSB7XG4gICAgbGV0IGF0dGVtcHRzID0gY291bnQ7XG4gICAgcmV0dXJuIGFzeW5jIChjYW5pc3RlcklkLCByZXF1ZXN0SWQsIHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAoLS1hdHRlbXB0cyA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZXRyaWV2ZSBhIHJlcGx5IGZvciByZXF1ZXN0IGFmdGVyICR7Y291bnR9IGF0dGVtcHRzOlxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIFJlcXVlc3QgSUQ6ICR7dG9IZXgocmVxdWVzdElkKX1cXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZXF1ZXN0IHN0YXR1czogJHtzdGF0dXN9XFxuYCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBUaHJvdHRsZSBwb2xsaW5nLlxuICogQHBhcmFtIHRocm90dGxlSW5Nc2VjIEFtb3VudCBpbiBtaWxsaXNlY29uZCB0byB3YWl0IGJldHdlZW4gZWFjaCBwb2xsaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUodGhyb3R0bGVJbk1zZWMpIHtcbiAgICByZXR1cm4gKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRocm90dGxlSW5Nc2VjKSk7XG59XG4vKipcbiAqIFJlamVjdCBhIGNhbGwgYWZ0ZXIgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lLlxuICogQHBhcmFtIHRpbWVJbk1zZWMgVGltZSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBwb2xsaW5nIHNob3VsZCBiZSByZWplY3RlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXQodGltZUluTXNlYykge1xuICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCkgKyB0aW1lSW5Nc2VjO1xuICAgIHJldHVybiBhc3luYyAoY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCBzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgPiBlbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWVzdCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lSW5Nc2VjfSBtc2VjOlxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIFJlcXVlc3QgSUQ6ICR7dG9IZXgocmVxdWVzdElkKX1cXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZXF1ZXN0IHN0YXR1czogJHtzdGF0dXN9XFxuYCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBBIHN0cmF0ZWd5IHRoYXQgdGhyb3R0bGUsIGJ1dCB1c2luZyBhbiBleHBvbmVudGlhbCBiYWNrb2ZmIHN0cmF0ZWd5LlxuICogQHBhcmFtIHN0YXJ0aW5nVGhyb3R0bGVJbk1zZWMgVGhlIHRocm90dGxlIGluIG1pbGxpc2Vjb25kcyB0byBzdGFydCB3aXRoLlxuICogQHBhcmFtIGJhY2tvZmZGYWN0b3IgVGhlIGZhY3RvciB0byBtdWx0aXBsZSB0aGUgdGhyb3R0bGUgdGltZSBiZXR3ZWVuIGV2ZXJ5IHBvbGwuIEZvclxuICogICBleGFtcGxlIGlmIHVzaW5nIDIsIHRoZSB0aHJvdHRsZSB3aWxsIGRvdWJsZSBiZXR3ZWVuIGV2ZXJ5IHJ1bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tvZmYoc3RhcnRpbmdUaHJvdHRsZUluTXNlYywgYmFja29mZkZhY3Rvcikge1xuICAgIGxldCBjdXJyZW50VGhyb3R0bGluZyA9IHN0YXJ0aW5nVGhyb3R0bGVJbk1zZWM7XG4gICAgcmV0dXJuICgpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGN1cnJlbnRUaHJvdHRsaW5nICo9IGJhY2tvZmZGYWN0b3I7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICB9LCBjdXJyZW50VGhyb3R0bGluZykpO1xufVxuLyoqXG4gKiBDaGFpbiBtdWx0aXBsZSBwb2xsaW5nIHN0cmF0ZWd5LiBUaGlzIF9jaGFpbnNfIHRoZSBzdHJhdGVnaWVzLCBzbyBpZiB5b3UgcGFzcyBpbixcbiAqIHNheSwgdHdvIHRocm90dGxpbmcgc3RyYXRlZ3kgb2YgMSBzZWNvbmQsIGl0IHdpbGwgcmVzdWx0IGluIGEgdGhyb3R0bGUgb2YgMiBzZWNvbmRzLlxuICogQHBhcmFtIHN0cmF0ZWdpZXMgQSBzdHJhdGVneSBsaXN0IHRvIGNoYWluLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhaW4oLi4uc3RyYXRlZ2llcykge1xuICAgIHJldHVybiBhc3luYyAoY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCBzdGF0dXMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBhIG9mIHN0cmF0ZWdpZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IGEoY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCBzdGF0dXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmF0ZWd5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/polling/strategy.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/public_key.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/public_key.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519PublicKey: () => (/* binding */ Ed25519PublicKey)\n/* harmony export */ });\n/* harmony import */ var _der__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./der */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/der.js\");\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Ed25519PublicKey_rawKey, _Ed25519PublicKey_derKey;\n\nclass Ed25519PublicKey {\n    // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n    constructor(key) {\n        _Ed25519PublicKey_rawKey.set(this, void 0);\n        _Ed25519PublicKey_derKey.set(this, void 0);\n        if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n            throw new Error('An Ed25519 public key must be exactly 32bytes long');\n        }\n        __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, \"f\");\n        __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, Ed25519PublicKey.derEncode(key), \"f\");\n    }\n    static from(key) {\n        return this.fromDer(key.toDer());\n    }\n    static fromRaw(rawKey) {\n        return new Ed25519PublicKey(rawKey);\n    }\n    static fromDer(derKey) {\n        return new Ed25519PublicKey(this.derDecode(derKey));\n    }\n    static derEncode(publicKey) {\n        return (0,_der__WEBPACK_IMPORTED_MODULE_0__.wrapDER)(publicKey, _der__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID).buffer;\n    }\n    static derDecode(key) {\n        const unwrapped = (0,_der__WEBPACK_IMPORTED_MODULE_0__.unwrapDER)(key, _der__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID);\n        if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n            throw new Error('An Ed25519 public key must be exactly 32bytes long');\n        }\n        return unwrapped;\n    }\n    get rawKey() {\n        return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, \"f\");\n    }\n    get derKey() {\n        return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, \"f\");\n    }\n    toDer() {\n        return this.derKey;\n    }\n    toRaw() {\n        return this.rawKey;\n    }\n}\n_Ed25519PublicKey_rawKey = new WeakMap(), _Ed25519PublicKey_derKey = new WeakMap();\n// The length of Ed25519 public keys is always 32 bytes.\nEd25519PublicKey.RAW_KEY_LENGTH = 32;\n//# sourceMappingURL=public_key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3B1YmxpY19rZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFJLElBQUksU0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dEO0FBQ2pEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkNBQU8sWUFBWSw2Q0FBVztBQUM3QztBQUNBO0FBQ0EsMEJBQTBCLCtDQUFTLE1BQU0sNkNBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3B1YmxpY19rZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9FZDI1NTE5UHVibGljS2V5X3Jhd0tleSwgX0VkMjU1MTlQdWJsaWNLZXlfZGVyS2V5O1xuaW1wb3J0IHsgRUQyNTUxOV9PSUQsIHVud3JhcERFUiwgd3JhcERFUiB9IGZyb20gJy4vZGVyJztcbmV4cG9ydCBjbGFzcyBFZDI1NTE5UHVibGljS2V5IHtcbiAgICAvLyBgZnJvbVJhd2AgYW5kIGBmcm9tRGVyYCBzaG91bGQgYmUgdXNlZCBmb3IgaW5zdGFudGlhdGlvbiwgbm90IHRoaXMgY29uc3RydWN0b3IuXG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgICAgIF9FZDI1NTE5UHVibGljS2V5X3Jhd0tleS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0VkMjU1MTlQdWJsaWNLZXlfZGVyS2V5LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBpZiAoa2V5LmJ5dGVMZW5ndGggIT09IEVkMjU1MTlQdWJsaWNLZXkuUkFXX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gRWQyNTUxOSBwdWJsaWMga2V5IG11c3QgYmUgZXhhY3RseSAzMmJ5dGVzIGxvbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FZDI1NTE5UHVibGljS2V5X3Jhd0tleSwga2V5LCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0VkMjU1MTlQdWJsaWNLZXlfZGVyS2V5LCBFZDI1NTE5UHVibGljS2V5LmRlckVuY29kZShrZXkpLCBcImZcIik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tRGVyKGtleS50b0RlcigpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SYXcocmF3S2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRWQyNTUxOVB1YmxpY0tleShyYXdLZXkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbURlcihkZXJLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZDI1NTE5UHVibGljS2V5KHRoaXMuZGVyRGVjb2RlKGRlcktleSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZGVyRW5jb2RlKHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gd3JhcERFUihwdWJsaWNLZXksIEVEMjU1MTlfT0lEKS5idWZmZXI7XG4gICAgfVxuICAgIHN0YXRpYyBkZXJEZWNvZGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHVud3JhcHBlZCA9IHVud3JhcERFUihrZXksIEVEMjU1MTlfT0lEKTtcbiAgICAgICAgaWYgKHVud3JhcHBlZC5sZW5ndGggIT09IHRoaXMuUkFXX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gRWQyNTUxOSBwdWJsaWMga2V5IG11c3QgYmUgZXhhY3RseSAzMmJ5dGVzIGxvbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW53cmFwcGVkO1xuICAgIH1cbiAgICBnZXQgcmF3S2V5KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRWQyNTUxOVB1YmxpY0tleV9yYXdLZXksIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGRlcktleSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0VkMjU1MTlQdWJsaWNLZXlfZGVyS2V5LCBcImZcIik7XG4gICAgfVxuICAgIHRvRGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXJLZXk7XG4gICAgfVxuICAgIHRvUmF3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdLZXk7XG4gICAgfVxufVxuX0VkMjU1MTlQdWJsaWNLZXlfcmF3S2V5ID0gbmV3IFdlYWtNYXAoKSwgX0VkMjU1MTlQdWJsaWNLZXlfZGVyS2V5ID0gbmV3IFdlYWtNYXAoKTtcbi8vIFRoZSBsZW5ndGggb2YgRWQyNTUxOSBwdWJsaWMga2V5cyBpcyBhbHdheXMgMzIgYnl0ZXMuXG5FZDI1NTE5UHVibGljS2V5LlJBV19LRVlfTEVOR1RIID0gMzI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaWNfa2V5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/public_key.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/request_id.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/request_id.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   hashOfMap: () => (/* binding */ hashOfMap),\n/* harmony export */   hashValue: () => (/* binding */ hashValue),\n/* harmony export */   requestIdOf: () => (/* binding */ requestIdOf)\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/index.js\");\n/* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! borc */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/index.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\n\n\n\n/**\n * sha256 hash the provided Buffer\n * @param data - input to hash function\n */\nfunction hash(data) {\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.uint8ToBuf)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256.create().update(new Uint8Array(data)).digest());\n}\n/**\n *\n * @param value unknown value\n * @returns ArrayBuffer\n */\nfunction hashValue(value) {\n    if (value instanceof borc__WEBPACK_IMPORTED_MODULE_1__.Tagged) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return hashValue(value.value);\n    }\n    else if (typeof value === 'string') {\n        return hashString(value);\n    }\n    else if (typeof value === 'number') {\n        return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(value));\n    }\n    else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {\n        return hash(value);\n    }\n    else if (Array.isArray(value)) {\n        const vals = value.map(hashValue);\n        return hash((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...vals));\n    }\n    else if (value && typeof value === 'object' && value._isPrincipal) {\n        return hash(value.toUint8Array());\n    }\n    else if (typeof value === 'object' &&\n        value !== null &&\n        typeof value.toHash === 'function') {\n        return hashValue(value.toHash());\n        // TODO This should be move to a specific async method as the webauthn flow required\n        // the flow to be synchronous to ensure Safari touch id works.\n        // } else if (value instanceof Promise) {\n        //   return value.then(x => hashValue(x));\n    }\n    else if (typeof value === 'object') {\n        return hashOfMap(value);\n    }\n    else if (typeof value === 'bigint') {\n        // Do this check much later than the other bigint check because this one is much less\n        // type-safe.\n        // So we want to try all the high-assurance type guards before this 'probable' one.\n        return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(value));\n    }\n    throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {\n        // include so logs/callers can understand the confusing value.\n        // (when stringified in error message, prototype info is lost)\n        value,\n    });\n}\nconst hashString = (value) => {\n    const encoded = new TextEncoder().encode(value);\n    return hash(encoded);\n};\n/**\n * Get the RequestId of the provided ic-ref request.\n * RequestId is the result of the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param request - ic-ref request to hash into RequestId\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction requestIdOf(request) {\n    return hashOfMap(request);\n}\n/**\n * Hash a map into an ArrayBuffer using the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param map - Any non-nested object\n * @returns ArrayBuffer\n */\nfunction hashOfMap(map) {\n    const hashed = Object.entries(map)\n        .filter(([, value]) => value !== undefined)\n        .map(([key, value]) => {\n        const hashedKey = hashString(key);\n        const hashedValue = hashValue(value);\n        return [hashedKey, hashedValue];\n    });\n    const traversed = hashed;\n    const sorted = traversed.sort(([k1], [k2]) => {\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.compare)(k1, k2);\n    });\n    const concatenated = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...sorted.map(x => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...x)));\n    const result = hash(concatenated);\n    return result;\n}\n//# sourceMappingURL=request_id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3JlcXVlc3RfaWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNEM7QUFDcEI7QUFDc0I7QUFDZTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyx5REFBVSxDQUFDLHdEQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AseUJBQXlCLHdDQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVM7QUFDN0I7QUFDQSxrRkFBa0YsTUFBTTtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsc0RBQU87QUFDdEIsS0FBSztBQUNMLHlCQUF5QixxREFBTSxvQkFBb0IscURBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3JlcXVlc3RfaWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGViRW5jb2RlIH0gZnJvbSAnQGRmaW5pdHkvY2FuZGlkJztcbmltcG9ydCBib3JjIGZyb20gJ2JvcmMnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgY29tcGFyZSwgY29uY2F0LCB1aW50OFRvQnVmIH0gZnJvbSAnLi91dGlscy9idWZmZXInO1xuLyoqXG4gKiBzaGEyNTYgaGFzaCB0aGUgcHJvdmlkZWQgQnVmZmVyXG4gKiBAcGFyYW0gZGF0YSAtIGlucHV0IHRvIGhhc2ggZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZGF0YSkge1xuICAgIHJldHVybiB1aW50OFRvQnVmKHNoYTI1Ni5jcmVhdGUoKS51cGRhdGUobmV3IFVpbnQ4QXJyYXkoZGF0YSkpLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB1bmtub3duIHZhbHVlXG4gKiBAcmV0dXJucyBBcnJheUJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgYm9yYy5UYWdnZWQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZSh2YWx1ZS52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBoYXNoKGxlYkVuY29kZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGhhc2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCB2YWxzID0gdmFsdWUubWFwKGhhc2hWYWx1ZSk7XG4gICAgICAgIHJldHVybiBoYXNoKGNvbmNhdCguLi52YWxzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2lzUHJpbmNpcGFsKSB7XG4gICAgICAgIHJldHVybiBoYXNoKHZhbHVlLnRvVWludDhBcnJheSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUudG9IYXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBoYXNoVmFsdWUodmFsdWUudG9IYXNoKCkpO1xuICAgICAgICAvLyBUT0RPIFRoaXMgc2hvdWxkIGJlIG1vdmUgdG8gYSBzcGVjaWZpYyBhc3luYyBtZXRob2QgYXMgdGhlIHdlYmF1dGhuIGZsb3cgcmVxdWlyZWRcbiAgICAgICAgLy8gdGhlIGZsb3cgdG8gYmUgc3luY2hyb25vdXMgdG8gZW5zdXJlIFNhZmFyaSB0b3VjaCBpZCB3b3Jrcy5cbiAgICAgICAgLy8gfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgLy8gICByZXR1cm4gdmFsdWUudGhlbih4ID0+IGhhc2hWYWx1ZSh4KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hPZk1hcCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgLy8gRG8gdGhpcyBjaGVjayBtdWNoIGxhdGVyIHRoYW4gdGhlIG90aGVyIGJpZ2ludCBjaGVjayBiZWNhdXNlIHRoaXMgb25lIGlzIG11Y2ggbGVzc1xuICAgICAgICAvLyB0eXBlLXNhZmUuXG4gICAgICAgIC8vIFNvIHdlIHdhbnQgdG8gdHJ5IGFsbCB0aGUgaGlnaC1hc3N1cmFuY2UgdHlwZSBndWFyZHMgYmVmb3JlIHRoaXMgJ3Byb2JhYmxlJyBvbmUuXG4gICAgICAgIHJldHVybiBoYXNoKGxlYkVuY29kZSh2YWx1ZSkpO1xuICAgIH1cbiAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgQXR0ZW1wdCB0byBoYXNoIGEgdmFsdWUgb2YgdW5zdXBwb3J0ZWQgdHlwZTogJHt2YWx1ZX1gKSwge1xuICAgICAgICAvLyBpbmNsdWRlIHNvIGxvZ3MvY2FsbGVycyBjYW4gdW5kZXJzdGFuZCB0aGUgY29uZnVzaW5nIHZhbHVlLlxuICAgICAgICAvLyAod2hlbiBzdHJpbmdpZmllZCBpbiBlcnJvciBtZXNzYWdlLCBwcm90b3R5cGUgaW5mbyBpcyBsb3N0KVxuICAgICAgICB2YWx1ZSxcbiAgICB9KTtcbn1cbmNvbnN0IGhhc2hTdHJpbmcgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBlbmNvZGVkID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKTtcbiAgICByZXR1cm4gaGFzaChlbmNvZGVkKTtcbn07XG4vKipcbiAqIEdldCB0aGUgUmVxdWVzdElkIG9mIHRoZSBwcm92aWRlZCBpYy1yZWYgcmVxdWVzdC5cbiAqIFJlcXVlc3RJZCBpcyB0aGUgcmVzdWx0IG9mIHRoZSByZXByZXNlbnRhdGlvbi1pbmRlcGVuZGVudC1oYXNoIGZ1bmN0aW9uLlxuICogaHR0cHM6Ly9zZGsuZGZpbml0eS5vcmcvZG9jcy9pbnRlcmZhY2Utc3BlYy9pbmRleC5odG1sI2hhc2gtb2YtbWFwXG4gKiBAcGFyYW0gcmVxdWVzdCAtIGljLXJlZiByZXF1ZXN0IHRvIGhhc2ggaW50byBSZXF1ZXN0SWRcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0SWRPZihyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIGhhc2hPZk1hcChyZXF1ZXN0KTtcbn1cbi8qKlxuICogSGFzaCBhIG1hcCBpbnRvIGFuIEFycmF5QnVmZmVyIHVzaW5nIHRoZSByZXByZXNlbnRhdGlvbi1pbmRlcGVuZGVudC1oYXNoIGZ1bmN0aW9uLlxuICogaHR0cHM6Ly9zZGsuZGZpbml0eS5vcmcvZG9jcy9pbnRlcmZhY2Utc3BlYy9pbmRleC5odG1sI2hhc2gtb2YtbWFwXG4gKiBAcGFyYW0gbWFwIC0gQW55IG5vbi1uZXN0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyBBcnJheUJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaE9mTWFwKG1hcCkge1xuICAgIGNvbnN0IGhhc2hlZCA9IE9iamVjdC5lbnRyaWVzKG1hcClcbiAgICAgICAgLmZpbHRlcigoWywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgaGFzaGVkS2V5ID0gaGFzaFN0cmluZyhrZXkpO1xuICAgICAgICBjb25zdCBoYXNoZWRWYWx1ZSA9IGhhc2hWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBbaGFzaGVkS2V5LCBoYXNoZWRWYWx1ZV07XG4gICAgfSk7XG4gICAgY29uc3QgdHJhdmVyc2VkID0gaGFzaGVkO1xuICAgIGNvbnN0IHNvcnRlZCA9IHRyYXZlcnNlZC5zb3J0KChbazFdLCBbazJdKSA9PiB7XG4gICAgICAgIHJldHVybiBjb21wYXJlKGsxLCBrMik7XG4gICAgfSk7XG4gICAgY29uc3QgY29uY2F0ZW5hdGVkID0gY29uY2F0KC4uLnNvcnRlZC5tYXAoeCA9PiBjb25jYXQoLi4ueCkpKTtcbiAgICBjb25zdCByZXN1bHQgPSBoYXNoKGNvbmNhdGVuYXRlZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3RfaWQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/request_id.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/bls.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/bls.js ***!
  \***************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blsVerify: () => (/* binding */ blsVerify),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/bls12-381 */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/bls12-381.js\");\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\n\nlet verify;\n/**\n *\n * @param pk primary key: Uint8Array\n * @param sig signature: Uint8Array\n * @param msg message: Uint8Array\n * @returns boolean\n */\nfunction blsVerify(pk, sig, msg) {\n    const primaryKey = typeof pk === 'string' ? pk : (0,_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(pk);\n    const signature = typeof sig === 'string' ? sig : (0,_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(sig);\n    const message = typeof msg === 'string' ? msg : (0,_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(msg);\n    return _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.verifyShortSignature(signature, message, primaryKey);\n}\n//# sourceMappingURL=bls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2Jscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9EO0FBQ25CO0FBQzFCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFEQUFxRCw4Q0FBSztBQUMxRCxzREFBc0QsOENBQUs7QUFDM0Qsb0RBQW9ELDhDQUFLO0FBQ3pELFdBQVcsOERBQVM7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvYmxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJsczEyXzM4MSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYmxzMTItMzgxJztcbmltcG9ydCB7IHRvSGV4IH0gZnJvbSAnLi9idWZmZXInO1xuZXhwb3J0IGxldCB2ZXJpZnk7XG4vKipcbiAqXG4gKiBAcGFyYW0gcGsgcHJpbWFyeSBrZXk6IFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBzaWcgc2lnbmF0dXJlOiBVaW50OEFycmF5XG4gKiBAcGFyYW0gbXNnIG1lc3NhZ2U6IFVpbnQ4QXJyYXlcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsc1ZlcmlmeShwaywgc2lnLCBtc2cpIHtcbiAgICBjb25zdCBwcmltYXJ5S2V5ID0gdHlwZW9mIHBrID09PSAnc3RyaW5nJyA/IHBrIDogdG9IZXgocGspO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHR5cGVvZiBzaWcgPT09ICdzdHJpbmcnID8gc2lnIDogdG9IZXgoc2lnKTtcbiAgICBjb25zdCBtZXNzYWdlID0gdHlwZW9mIG1zZyA9PT0gJ3N0cmluZycgPyBtc2cgOiB0b0hleChtc2cpO1xuICAgIHJldHVybiBibHMxMl8zODEudmVyaWZ5U2hvcnRTaWduYXR1cmUoc2lnbmF0dXJlLCBtZXNzYWdlLCBwcmltYXJ5S2V5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/bls.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bufEquals: () => (/* binding */ bufEquals),\n/* harmony export */   bufFromBufLike: () => (/* binding */ bufFromBufLike),\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   uint8ToBuf: () => (/* binding */ uint8ToBuf)\n/* harmony export */ });\n/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nfunction concat(...buffers) {\n    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n    let index = 0;\n    for (const b of buffers) {\n        result.set(new Uint8Array(b), index);\n        index += b.byteLength;\n    }\n    return result.buffer;\n}\n/**\n * Transforms a buffer to an hexadecimal string. This will use the buffer as an Uint8Array.\n * @param buffer The buffer to return the hexadecimal string of.\n */\nfunction toHex(buffer) {\n    return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n}\nconst hexRe = new RegExp(/^[0-9a-fA-F]+$/);\n/**\n * Transforms a hexadecimal string into an array buffer.\n * @param hex The hexadecimal string to use.\n */\nfunction fromHex(hex) {\n    if (!hexRe.test(hex)) {\n        throw new Error('Invalid hexadecimal string.');\n    }\n    const buffer = [...hex]\n        .reduce((acc, curr, i) => {\n        acc[(i / 2) | 0] = (acc[(i / 2) | 0] || '') + curr;\n        return acc;\n    }, [])\n        .map(x => Number.parseInt(x, 16));\n    return new Uint8Array(buffer).buffer;\n}\n/**\n *\n * @param b1 array buffer 1\n * @param b2 array buffer 2\n * @returns number - negative if b1 < b2, positive if b1 > b2, 0 if b1 === b2\n */\nfunction compare(b1, b2) {\n    if (b1.byteLength !== b2.byteLength) {\n        return b1.byteLength - b2.byteLength;\n    }\n    const u1 = new Uint8Array(b1);\n    const u2 = new Uint8Array(b2);\n    for (let i = 0; i < u1.length; i++) {\n        if (u1[i] !== u2[i]) {\n            return u1[i] - u2[i];\n        }\n    }\n    return 0;\n}\n/**\n * Checks two array buffers for equality.\n * @param b1 array buffer 1\n * @param b2 array buffer 2\n * @returns boolean\n */\nfunction bufEquals(b1, b2) {\n    return compare(b1, b2) === 0;\n}\n/**\n * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.\n * @param {Uint8Array} arr Uint8Array to convert\n * @returns ArrayBuffer\n */\nfunction uint8ToBuf(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;\n}\n/**\n * Returns a true ArrayBuffer from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns ArrayBuffer\n */\nfunction bufFromBufLike(bufLike) {\n    if (bufLike instanceof Uint8Array) {\n        return uint8ToBuf(bufLike);\n    }\n    if (bufLike instanceof ArrayBuffer) {\n        return bufLike;\n    }\n    if (Array.isArray(bufLike)) {\n        return uint8ToBuf(new Uint8Array(bufLike));\n    }\n    if ('buffer' in bufLike) {\n        return bufFromBufLike(bufLike.buffer);\n    }\n    return uint8ToBuf(new Uint8Array(bufLike));\n}\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvYnVmZmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYXJyYXkgYnVmZmVycy5cbiAqIEBwYXJhbSBidWZmZXJzIFRoZSBidWZmZXJzIHRvIGNvbmNhdGVuYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLmJ1ZmZlcnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShidWZmZXJzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLmJ5dGVMZW5ndGgsIDApKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgYiBvZiBidWZmZXJzKSB7XG4gICAgICAgIHJlc3VsdC5zZXQobmV3IFVpbnQ4QXJyYXkoYiksIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhIGJ1ZmZlciB0byBhbiBoZXhhZGVjaW1hbCBzdHJpbmcuIFRoaXMgd2lsbCB1c2UgdGhlIGJ1ZmZlciBhcyBhbiBVaW50OEFycmF5LlxuICogQHBhcmFtIGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHJldHVybiB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nIG9mLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoYnVmZmVyKSB7XG4gICAgcmV0dXJuIFsuLi5uZXcgVWludDhBcnJheShidWZmZXIpXS5tYXAoeCA9PiB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbn1cbmNvbnN0IGhleFJlID0gbmV3IFJlZ0V4cCgvXlswLTlhLWZBLUZdKyQvKTtcbi8qKlxuICogVHJhbnNmb3JtcyBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnRvIGFuIGFycmF5IGJ1ZmZlci5cbiAqIEBwYXJhbSBoZXggVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byB1c2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgIGlmICghaGV4UmUudGVzdChoZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFsuLi5oZXhdXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgY3VyciwgaSkgPT4ge1xuICAgICAgICBhY2NbKGkgLyAyKSB8IDBdID0gKGFjY1soaSAvIDIpIHwgMF0gfHwgJycpICsgY3VycjtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSlcbiAgICAgICAgLm1hcCh4ID0+IE51bWJlci5wYXJzZUludCh4LCAxNikpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpLmJ1ZmZlcjtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBiMSBhcnJheSBidWZmZXIgMVxuICogQHBhcmFtIGIyIGFycmF5IGJ1ZmZlciAyXG4gKiBAcmV0dXJucyBudW1iZXIgLSBuZWdhdGl2ZSBpZiBiMSA8IGIyLCBwb3NpdGl2ZSBpZiBiMSA+IGIyLCAwIGlmIGIxID09PSBiMlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShiMSwgYjIpIHtcbiAgICBpZiAoYjEuYnl0ZUxlbmd0aCAhPT0gYjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gYjEuYnl0ZUxlbmd0aCAtIGIyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHUxID0gbmV3IFVpbnQ4QXJyYXkoYjEpO1xuICAgIGNvbnN0IHUyID0gbmV3IFVpbnQ4QXJyYXkoYjIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdTEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHUxW2ldICE9PSB1MltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHUxW2ldIC0gdTJbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG4vKipcbiAqIENoZWNrcyB0d28gYXJyYXkgYnVmZmVycyBmb3IgZXF1YWxpdHkuXG4gKiBAcGFyYW0gYjEgYXJyYXkgYnVmZmVyIDFcbiAqIEBwYXJhbSBiMiBhcnJheSBidWZmZXIgMlxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmRXF1YWxzKGIxLCBiMikge1xuICAgIHJldHVybiBjb21wYXJlKGIxLCBiMikgPT09IDA7XG59XG4vKipcbiAqIFJldHVybnMgYSB0cnVlIEFycmF5QnVmZmVyIGZyb20gYSBVaW50OEFycmF5LCBhcyBVaW50OEFycmF5LmJ1ZmZlciBpcyB1bnNhZmUuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyciBVaW50OEFycmF5IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIEFycmF5QnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1aW50OFRvQnVmKGFycikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKS5idWZmZXI7XG59XG4vKipcbiAqIFJldHVybnMgYSB0cnVlIEFycmF5QnVmZmVyIGZyb20gYW4gQXJyYXlCdWZmZXJMaWtlIG9iamVjdC5cbiAqIEBwYXJhbSBidWZMaWtlIGEgYnVmZmVyLWxpa2Ugb2JqZWN0XG4gKiBAcmV0dXJucyBBcnJheUJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmRnJvbUJ1Zkxpa2UoYnVmTGlrZSkge1xuICAgIGlmIChidWZMaWtlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdWludDhUb0J1ZihidWZMaWtlKTtcbiAgICB9XG4gICAgaWYgKGJ1Zkxpa2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gYnVmTGlrZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmTGlrZSkpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4VG9CdWYobmV3IFVpbnQ4QXJyYXkoYnVmTGlrZSkpO1xuICAgIH1cbiAgICBpZiAoJ2J1ZmZlcicgaW4gYnVmTGlrZSkge1xuICAgICAgICByZXR1cm4gYnVmRnJvbUJ1Zkxpa2UoYnVmTGlrZS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdWludDhUb0J1ZihuZXcgVWludDhBcnJheShidWZMaWtlKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/buffer.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js ***!
  \************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExpirableMap: () => (/* binding */ ExpirableMap)\n/* harmony export */ });\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ExpirableMap_inner, _ExpirableMap_expirationTime, _a, _b;\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nclass ExpirableMap {\n    /**\n     * Create a new ExpirableMap.\n     * @param {ExpirableMapOptions<any, any>} options - options for the map.\n     * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n     * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n     */\n    constructor(options = {}) {\n        // Internals\n        _ExpirableMap_inner.set(this, void 0);\n        _ExpirableMap_expirationTime.set(this, void 0);\n        this[_a] = this.entries.bind(this);\n        this[_b] = 'ExpirableMap';\n        const { source = [], expirationTime = 10 * 60 * 1000 } = options;\n        const currentTime = Date.now();\n        __classPrivateFieldSet(this, _ExpirableMap_inner, new Map([...source].map(([key, value]) => [key, { value, timestamp: currentTime }])), \"f\");\n        __classPrivateFieldSet(this, _ExpirableMap_expirationTime, expirationTime, \"f\");\n    }\n    /**\n     * Prune removes all expired entries.\n     */\n    prune() {\n        const currentTime = Date.now();\n        for (const [key, entry] of __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries()) {\n            if (currentTime - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, \"f\")) {\n                __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n            }\n        }\n        return this;\n    }\n    // Implementing the Map interface\n    /**\n     * Set the value for the given key. Prunes expired entries.\n     * @param key for the entry\n     * @param value of the entry\n     * @returns this\n     */\n    set(key, value) {\n        this.prune();\n        const entry = {\n            value,\n            timestamp: Date.now(),\n        };\n        __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").set(key, entry);\n        return this;\n    }\n    /**\n     * Get the value associated with the key, if it exists and has not expired.\n     * @param key K\n     * @returns the value associated with the key, or undefined if the key is not present or has expired.\n     */\n    get(key) {\n        const entry = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").get(key);\n        if (entry === undefined) {\n            return undefined;\n        }\n        if (Date.now() - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, \"f\")) {\n            __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n            return undefined;\n        }\n        return entry.value;\n    }\n    /**\n     * Clear all entries.\n     */\n    clear() {\n        __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").clear();\n    }\n    /**\n     * Entries returns the entries of the map, without the expiration time.\n     * @returns an iterator over the entries of the map.\n     */\n    entries() {\n        const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries();\n        const generator = function* () {\n            for (const [key, value] of iterator) {\n                yield [key, value.value];\n            }\n        };\n        return generator();\n    }\n    /**\n     * Values returns the values of the map, without the expiration time.\n     * @returns an iterator over the values of the map.\n     */\n    values() {\n        const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").values();\n        const generator = function* () {\n            for (const value of iterator) {\n                yield value.value;\n            }\n        };\n        return generator();\n    }\n    /**\n     * Keys returns the keys of the map\n     * @returns an iterator over the keys of the map.\n     */\n    keys() {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").keys();\n    }\n    /**\n     * forEach calls the callbackfn on each entry of the map.\n     * @param callbackfn to call on each entry\n     * @param thisArg to use as this when calling the callbackfn\n     */\n    forEach(callbackfn, thisArg) {\n        for (const [key, value] of __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries()) {\n            callbackfn.call(thisArg, value.value, key, this);\n        }\n    }\n    /**\n     * has returns true if the key exists and has not expired.\n     * @param key K\n     * @returns true if the key exists and has not expired.\n     */\n    has(key) {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").has(key);\n    }\n    /**\n     * delete the entry for the given key.\n     * @param key K\n     * @returns true if the key existed and has been deleted.\n     */\n    delete(key) {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n    }\n    /**\n     * get size of the map.\n     * @returns the size of the map.\n     */\n    get size() {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").size;\n    }\n}\n_ExpirableMap_inner = new WeakMap(), _ExpirableMap_expirationTime = new WeakMap(), _a = Symbol.iterator, _b = Symbol.toStringTag;\n//# sourceMappingURL=expirableMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2V4cGlyYWJsZU1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0EsNEdBQTRHLCtCQUErQjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvZXhwaXJhYmxlTWFwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRXhwaXJhYmxlTWFwX2lubmVyLCBfRXhwaXJhYmxlTWFwX2V4cGlyYXRpb25UaW1lLCBfYSwgX2I7XG4vKipcbiAqIEEgbWFwIHRoYXQgZXhwaXJlcyBlbnRyaWVzIGFmdGVyIGEgZ2l2ZW4gdGltZS5cbiAqIERlZmF1bHRzIHRvIDEwIG1pbnV0ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHBpcmFibGVNYXAge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBFeHBpcmFibGVNYXAuXG4gICAgICogQHBhcmFtIHtFeHBpcmFibGVNYXBPcHRpb25zPGFueSwgYW55Pn0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIHRoZSBtYXAuXG4gICAgICogQHBhcmFtIHtJdGVyYWJsZTxbYW55LCBhbnldPn0gb3B0aW9ucy5zb3VyY2UgLSBhbiBvcHRpb25hbCBzb3VyY2Ugb2YgZW50cmllcyB0byBpbml0aWFsaXplIHRoZSBtYXAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5leHBpcmF0aW9uVGltZSAtIHRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCBlbnRyaWVzIHdpbGwgZXhwaXJlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBJbnRlcm5hbHNcbiAgICAgICAgX0V4cGlyYWJsZU1hcF9pbm5lci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0V4cGlyYWJsZU1hcF9leHBpcmF0aW9uVGltZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgdGhpc1tfYV0gPSB0aGlzLmVudHJpZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpc1tfYl0gPSAnRXhwaXJhYmxlTWFwJztcbiAgICAgICAgY29uc3QgeyBzb3VyY2UgPSBbXSwgZXhwaXJhdGlvblRpbWUgPSAxMCAqIDYwICogMTAwMCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIG5ldyBNYXAoWy4uLnNvdXJjZV0ubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHsgdmFsdWUsIHRpbWVzdGFtcDogY3VycmVudFRpbWUgfV0pKSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfZXhwaXJhdGlvblRpbWUsIGV4cGlyYXRpb25UaW1lLCBcImZcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBydW5lIHJlbW92ZXMgYWxsIGV4cGlyZWQgZW50cmllcy5cbiAgICAgKi9cbiAgICBwcnVuZSgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSAtIGVudHJ5LnRpbWVzdGFtcCA+IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9leHBpcmF0aW9uVGltZSwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEltcGxlbWVudGluZyB0aGUgTWFwIGludGVyZmFjZVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkuIFBydW5lcyBleHBpcmVkIGVudHJpZXMuXG4gICAgICogQHBhcmFtIGtleSBmb3IgdGhlIGVudHJ5XG4gICAgICogQHBhcmFtIHZhbHVlIG9mIHRoZSBlbnRyeVxuICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnBydW5lKCk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIH07XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLnNldChrZXksIGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXksIGlmIGl0IGV4aXN0cyBhbmQgaGFzIG5vdCBleHBpcmVkLlxuICAgICAqIEBwYXJhbSBrZXkgS1xuICAgICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgaXMgbm90IHByZXNlbnQgb3IgaGFzIGV4cGlyZWQuXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmdldChrZXkpO1xuICAgICAgICBpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGVudHJ5LnRpbWVzdGFtcCA+IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9leHBpcmF0aW9uVGltZSwgXCJmXCIpKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZW50cmllcy5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW50cmllcyByZXR1cm5zIHRoZSBlbnRyaWVzIG9mIHRoZSBtYXAsIHdpdGhvdXQgdGhlIGV4cGlyYXRpb24gdGltZS5cbiAgICAgKiBAcmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBlbnRyaWVzIG9mIHRoZSBtYXAuXG4gICAgICovXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5lbnRyaWVzKCk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWx1ZXMgcmV0dXJucyB0aGUgdmFsdWVzIG9mIHRoZSBtYXAsIHdpdGhvdXQgdGhlIGV4cGlyYXRpb24gdGltZS5cbiAgICAgKiBAcmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSB2YWx1ZXMgb2YgdGhlIG1hcC5cbiAgICAgKi9cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikudmFsdWVzKCk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBnZW5lcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogS2V5cyByZXR1cm5zIHRoZSBrZXlzIG9mIHRoZSBtYXBcbiAgICAgKiBAcmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBrZXlzIG9mIHRoZSBtYXAuXG4gICAgICovXG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmtleXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZm9yRWFjaCBjYWxscyB0aGUgY2FsbGJhY2tmbiBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXAuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrZm4gdG8gY2FsbCBvbiBlYWNoIGVudHJ5XG4gICAgICogQHBhcmFtIHRoaXNBcmcgdG8gdXNlIGFzIHRoaXMgd2hlbiBjYWxsaW5nIHRoZSBjYWxsYmFja2ZuXG4gICAgICovXG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLnZhbHVlLCBrZXksIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGhhcyByZXR1cm5zIHRydWUgaWYgdGhlIGtleSBleGlzdHMgYW5kIGhhcyBub3QgZXhwaXJlZC5cbiAgICAgKiBAcGFyYW0ga2V5IEtcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBrZXkgZXhpc3RzIGFuZCBoYXMgbm90IGV4cGlyZWQuXG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikuaGFzKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRlbGV0ZSB0aGUgZW50cnkgZm9yIHRoZSBnaXZlbiBrZXkuXG4gICAgICogQHBhcmFtIGtleSBLXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCBzaXplIG9mIHRoZSBtYXAuXG4gICAgICogQHJldHVybnMgdGhlIHNpemUgb2YgdGhlIG1hcC5cbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLnNpemU7XG4gICAgfVxufVxuX0V4cGlyYWJsZU1hcF9pbm5lciA9IG5ldyBXZWFrTWFwKCksIF9FeHBpcmFibGVNYXBfZXhwaXJhdGlvblRpbWUgPSBuZXcgV2Vha01hcCgpLCBfYSA9IFN5bWJvbC5pdGVyYXRvciwgX2IgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBpcmFibGVNYXAuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/leb.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/leb.js ***!
  \***************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeLeb128: () => (/* binding */ decodeLeb128),\n/* harmony export */   decodeTime: () => (/* binding */ decodeTime)\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/index.js\");\n\nconst decodeLeb128 = (buf) => {\n    return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(new _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(buf));\n};\n// time is a LEB128-encoded Nat\nconst decodeTime = (buf) => {\n    const decoded = decodeLeb128(buf);\n    // nanoseconds to milliseconds\n    return new Date(Number(decoded) / 1000000);\n};\n//# sourceMappingURL=leb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2xlYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkQ7QUFDdEQ7QUFDUCxXQUFXLDBEQUFTLEtBQUssNERBQWU7QUFDeEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvbGViLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBpcGVBcnJheUJ1ZmZlciwgbGViRGVjb2RlIH0gZnJvbSAnQGRmaW5pdHkvY2FuZGlkJztcbmV4cG9ydCBjb25zdCBkZWNvZGVMZWIxMjggPSAoYnVmKSA9PiB7XG4gICAgcmV0dXJuIGxlYkRlY29kZShuZXcgUGlwZUFycmF5QnVmZmVyKGJ1ZikpO1xufTtcbi8vIHRpbWUgaXMgYSBMRUIxMjgtZW5jb2RlZCBOYXRcbmV4cG9ydCBjb25zdCBkZWNvZGVUaW1lID0gKGJ1ZikgPT4ge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVMZWIxMjgoYnVmKTtcbiAgICAvLyBuYW5vc2Vjb25kcyB0byBtaWxsaXNlY29uZHNcbiAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKGRlY29kZWQpIC8gMTAwMDAwMCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGViLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/leb.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/random.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/random.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   randomNumber: () => (/* binding */ randomNumber)\n/* harmony export */ });\n/**\n * Generates a random unsigned 32-bit integer between 0 and 0xffffffff\n * @returns {number} a random number\n */\nconst randomNumber = () => {\n    // determine whether browser crypto is available\n    if (typeof window !== 'undefined' && !!window.crypto && !!window.crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        window.crypto.getRandomValues(array);\n        return array[0];\n    }\n    // A second check for webcrypto, in case it is loaded under global instead of window\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        crypto.getRandomValues(array);\n        return array[0];\n    }\n    // determine whether node crypto is available\n    if (typeof crypto !== 'undefined' && crypto.randomInt) {\n        return crypto.randomInt(0, 0xffffffff);\n    }\n    // fall back to Math.random\n    return Math.floor(Math.random() * 0xffffffff);\n};\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrYWdlbnRAMi4xLjNfQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuM19fQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL3JhbmRvbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eSthZ2VudEAyLjEuM19AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zX19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvcmFuZG9tLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMHhmZmZmZmZmZlxuICogQHJldHVybnMge251bWJlcn0gYSByYW5kb20gbnVtYmVyXG4gKi9cbmV4cG9ydCBjb25zdCByYW5kb21OdW1iZXIgPSAoKSA9PiB7XG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgYnJvd3NlciBjcnlwdG8gaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93LmNyeXB0byAmJiAhIXdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuICAgICAgICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG4gICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICB9XG4gICAgLy8gQSBzZWNvbmQgY2hlY2sgZm9yIHdlYmNyeXB0bywgaW4gY2FzZSBpdCBpcyBsb2FkZWQgdW5kZXIgZ2xvYmFsIGluc3RlYWQgb2Ygd2luZG93XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoMSk7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXJyYXlbMF07XG4gICAgfVxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIG5vZGUgY3J5cHRvIGlzIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tSW50KSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tSW50KDAsIDB4ZmZmZmZmZmYpO1xuICAgIH1cbiAgICAvLyBmYWxsIGJhY2sgdG8gTWF0aC5yYW5kb21cbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZik7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/utils/random.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/candid-core.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/candid-core.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputBox: () => (/* binding */ InputBox),\n/* harmony export */   InputForm: () => (/* binding */ InputForm),\n/* harmony export */   OptionForm: () => (/* binding */ OptionForm),\n/* harmony export */   RecordForm: () => (/* binding */ RecordForm),\n/* harmony export */   TupleForm: () => (/* binding */ TupleForm),\n/* harmony export */   VariantForm: () => (/* binding */ VariantForm),\n/* harmony export */   VecForm: () => (/* binding */ VecForm)\n/* harmony export */ });\nclass InputBox {\n    constructor(idl, ui) {\n        this.idl = idl;\n        this.ui = ui;\n        this.label = null;\n        this.value = undefined;\n        const status = document.createElement('span');\n        status.className = 'status';\n        this.status = status;\n        if (ui.input) {\n            ui.input.addEventListener('blur', () => {\n                if (ui.input.value === '') {\n                    return;\n                }\n                this.parse();\n            });\n            ui.input.addEventListener('input', () => {\n                status.style.display = 'none';\n                ui.input.classList.remove('reject');\n            });\n        }\n    }\n    isRejected() {\n        return this.value === undefined;\n    }\n    parse(config = {}) {\n        if (this.ui.form) {\n            const value = this.ui.form.parse(config);\n            this.value = value;\n            return value;\n        }\n        if (this.ui.input) {\n            const input = this.ui.input;\n            try {\n                const value = this.ui.parse(this.idl, config, input.value);\n                if (!this.idl.covariant(value)) {\n                    throw new Error(`${input.value} is not of type ${this.idl.display()}`);\n                }\n                this.status.style.display = 'none';\n                this.value = value;\n                return value;\n            }\n            catch (err) {\n                input.classList.add('reject');\n                this.status.style.display = 'block';\n                this.status.innerHTML = 'InputError: ' + err.message;\n                this.value = undefined;\n                return undefined;\n            }\n        }\n        return null;\n    }\n    render(dom) {\n        const container = document.createElement('span');\n        if (this.label) {\n            const label = document.createElement('label');\n            label.innerText = this.label;\n            container.appendChild(label);\n        }\n        if (this.ui.input) {\n            container.appendChild(this.ui.input);\n            container.appendChild(this.status);\n        }\n        if (this.ui.form) {\n            this.ui.form.render(container);\n        }\n        dom.appendChild(container);\n    }\n}\nclass InputForm {\n    constructor(ui) {\n        this.ui = ui;\n        this.form = [];\n    }\n    renderForm(dom) {\n        if (this.ui.container) {\n            this.form.forEach(e => e.render(this.ui.container));\n            dom.appendChild(this.ui.container);\n        }\n        else {\n            this.form.forEach(e => e.render(dom));\n        }\n    }\n    render(dom) {\n        if (this.ui.open && this.ui.event) {\n            dom.appendChild(this.ui.open);\n            const form = this;\n            // eslint-disable-next-line\n            form.ui.open.addEventListener(form.ui.event, () => {\n                // Remove old form\n                if (form.ui.container) {\n                    form.ui.container.innerHTML = '';\n                }\n                else {\n                    const oldContainer = form.ui.open.nextElementSibling;\n                    if (oldContainer) {\n                        oldContainer.parentNode.removeChild(oldContainer);\n                    }\n                }\n                // Render form\n                form.generateForm();\n                form.renderForm(dom);\n            });\n        }\n        else {\n            this.generateForm();\n            this.renderForm(dom);\n        }\n    }\n}\nclass RecordForm extends InputForm {\n    constructor(fields, ui) {\n        super(ui);\n        this.fields = fields;\n        this.ui = ui;\n    }\n    generateForm() {\n        this.form = this.fields.map(([key, type]) => {\n            const input = this.ui.render(type);\n            // eslint-disable-next-line\n            if (this.ui.labelMap && this.ui.labelMap.hasOwnProperty(key)) {\n                input.label = this.ui.labelMap[key] + ' ';\n            }\n            else {\n                input.label = key + ' ';\n            }\n            return input;\n        });\n    }\n    parse(config) {\n        const v = {};\n        this.fields.forEach(([key, _], i) => {\n            const value = this.form[i].parse(config);\n            v[key] = value;\n        });\n        if (this.form.some(input => input.isRejected())) {\n            return undefined;\n        }\n        return v;\n    }\n}\nclass TupleForm extends InputForm {\n    constructor(components, ui) {\n        super(ui);\n        this.components = components;\n        this.ui = ui;\n    }\n    generateForm() {\n        this.form = this.components.map(type => {\n            const input = this.ui.render(type);\n            return input;\n        });\n    }\n    parse(config) {\n        const v = [];\n        this.components.forEach((_, i) => {\n            const value = this.form[i].parse(config);\n            v.push(value);\n        });\n        if (this.form.some(input => input.isRejected())) {\n            return undefined;\n        }\n        return v;\n    }\n}\nclass VariantForm extends InputForm {\n    constructor(fields, ui) {\n        super(ui);\n        this.fields = fields;\n        this.ui = ui;\n    }\n    generateForm() {\n        const index = this.ui.open.selectedIndex;\n        const [_, type] = this.fields[index];\n        const variant = this.ui.render(type);\n        this.form = [variant];\n    }\n    parse(config) {\n        const select = this.ui.open;\n        const selected = select.options[select.selectedIndex].value;\n        const value = this.form[0].parse(config);\n        if (value === undefined) {\n            return undefined;\n        }\n        const v = {};\n        v[selected] = value;\n        return v;\n    }\n}\nclass OptionForm extends InputForm {\n    constructor(ty, ui) {\n        super(ui);\n        this.ty = ty;\n        this.ui = ui;\n    }\n    generateForm() {\n        if (this.ui.open.checked) {\n            const opt = this.ui.render(this.ty);\n            this.form = [opt];\n        }\n        else {\n            this.form = [];\n        }\n    }\n    parse(config) {\n        if (this.form.length === 0) {\n            return [];\n        }\n        else {\n            const value = this.form[0].parse(config);\n            if (value === undefined) {\n                return undefined;\n            }\n            return [value];\n        }\n    }\n}\nclass VecForm extends InputForm {\n    constructor(ty, ui) {\n        super(ui);\n        this.ty = ty;\n        this.ui = ui;\n    }\n    generateForm() {\n        const len = +this.ui.open.value;\n        this.form = [];\n        for (let i = 0; i < len; i++) {\n            const t = this.ui.render(this.ty);\n            this.form.push(t);\n        }\n    }\n    parse(config) {\n        const value = this.form.map(input => {\n            return input.parse(config);\n        });\n        if (this.form.some(input => input.isRejected())) {\n            return undefined;\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=candid-core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vY2FuZGlkLWNvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhLGlCQUFpQixtQkFBbUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL2NhbmRpZC1jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBJbnB1dEJveCB7XG4gICAgY29uc3RydWN0b3IoaWRsLCB1aSkge1xuICAgICAgICB0aGlzLmlkbCA9IGlkbDtcbiAgICAgICAgdGhpcy51aSA9IHVpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzdGF0dXMuY2xhc3NOYW1lID0gJ3N0YXR1cyc7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBpZiAodWkuaW5wdXQpIHtcbiAgICAgICAgICAgIHVpLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHVpLmlucHV0LnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdWkuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdWkuaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgncmVqZWN0Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1JlamVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBwYXJzZShjb25maWcgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy51aS5mb3JtKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudWkuZm9ybS5wYXJzZShjb25maWcpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVpLmlucHV0KSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMudWkuaW5wdXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy51aS5wYXJzZSh0aGlzLmlkbCwgY29uZmlnLCBpbnB1dC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlkbC5jb3ZhcmlhbnQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtpbnB1dC52YWx1ZX0gaXMgbm90IG9mIHR5cGUgJHt0aGlzLmlkbC5kaXNwbGF5KCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdyZWplY3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cy5pbm5lckhUTUwgPSAnSW5wdXRFcnJvcjogJyArIGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVuZGVyKGRvbSkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbC5pbm5lclRleHQgPSB0aGlzLmxhYmVsO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51aS5pbnB1dCkge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudWkuaW5wdXQpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51aS5mb3JtKSB7XG4gICAgICAgICAgICB0aGlzLnVpLmZvcm0ucmVuZGVyKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIElucHV0Rm9ybSB7XG4gICAgY29uc3RydWN0b3IodWkpIHtcbiAgICAgICAgdGhpcy51aSA9IHVpO1xuICAgICAgICB0aGlzLmZvcm0gPSBbXTtcbiAgICB9XG4gICAgcmVuZGVyRm9ybShkb20pIHtcbiAgICAgICAgaWYgKHRoaXMudWkuY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm0uZm9yRWFjaChlID0+IGUucmVuZGVyKHRoaXMudWkuY29udGFpbmVyKSk7XG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQodGhpcy51aS5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JtLmZvckVhY2goZSA9PiBlLnJlbmRlcihkb20pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoZG9tKSB7XG4gICAgICAgIGlmICh0aGlzLnVpLm9wZW4gJiYgdGhpcy51aS5ldmVudCkge1xuICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKHRoaXMudWkub3Blbik7XG4gICAgICAgICAgICBjb25zdCBmb3JtID0gdGhpcztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgZm9ybS51aS5vcGVuLmFkZEV2ZW50TGlzdGVuZXIoZm9ybS51aS5ldmVudCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgZm9ybVxuICAgICAgICAgICAgICAgIGlmIChmb3JtLnVpLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBmb3JtLnVpLmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZENvbnRhaW5lciA9IGZvcm0udWkub3Blbi5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9sZENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIGZvcm1cbiAgICAgICAgICAgICAgICBmb3JtLmdlbmVyYXRlRm9ybSgpO1xuICAgICAgICAgICAgICAgIGZvcm0ucmVuZGVyRm9ybShkb20pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlRm9ybSgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJGb3JtKGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVjb3JkRm9ybSBleHRlbmRzIElucHV0Rm9ybSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCB1aSkge1xuICAgICAgICBzdXBlcih1aSk7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgfVxuICAgIGdlbmVyYXRlRm9ybSgpIHtcbiAgICAgICAgdGhpcy5mb3JtID0gdGhpcy5maWVsZHMubWFwKChba2V5LCB0eXBlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLnVpLnJlbmRlcih0eXBlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKHRoaXMudWkubGFiZWxNYXAgJiYgdGhpcy51aS5sYWJlbE1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQubGFiZWwgPSB0aGlzLnVpLmxhYmVsTWFwW2tleV0gKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5sYWJlbCA9IGtleSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhcnNlKGNvbmZpZykge1xuICAgICAgICBjb25zdCB2ID0ge307XG4gICAgICAgIHRoaXMuZmllbGRzLmZvckVhY2goKFtrZXksIF9dLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZm9ybVtpXS5wYXJzZShjb25maWcpO1xuICAgICAgICAgICAgdltrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5mb3JtLnNvbWUoaW5wdXQgPT4gaW5wdXQuaXNSZWplY3RlZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHVwbGVGb3JtIGV4dGVuZHMgSW5wdXRGb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRzLCB1aSkge1xuICAgICAgICBzdXBlcih1aSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIHRoaXMudWkgPSB1aTtcbiAgICB9XG4gICAgZ2VuZXJhdGVGb3JtKCkge1xuICAgICAgICB0aGlzLmZvcm0gPSB0aGlzLmNvbXBvbmVudHMubWFwKHR5cGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLnVpLnJlbmRlcih0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhcnNlKGNvbmZpZykge1xuICAgICAgICBjb25zdCB2ID0gW107XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZm9ybVtpXS5wYXJzZShjb25maWcpO1xuICAgICAgICAgICAgdi5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmZvcm0uc29tZShpbnB1dCA9PiBpbnB1dC5pc1JlamVjdGVkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBWYXJpYW50Rm9ybSBleHRlbmRzIElucHV0Rm9ybSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCB1aSkge1xuICAgICAgICBzdXBlcih1aSk7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgfVxuICAgIGdlbmVyYXRlRm9ybSgpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnVpLm9wZW4uc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgY29uc3QgW18sIHR5cGVdID0gdGhpcy5maWVsZHNbaW5kZXhdO1xuICAgICAgICBjb25zdCB2YXJpYW50ID0gdGhpcy51aS5yZW5kZXIodHlwZSk7XG4gICAgICAgIHRoaXMuZm9ybSA9IFt2YXJpYW50XTtcbiAgICB9XG4gICAgcGFyc2UoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdCA9IHRoaXMudWkub3BlbjtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3Qub3B0aW9uc1tzZWxlY3Quc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5mb3JtWzBdLnBhcnNlKGNvbmZpZyk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYgPSB7fTtcbiAgICAgICAgdltzZWxlY3RlZF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE9wdGlvbkZvcm0gZXh0ZW5kcyBJbnB1dEZvcm0ge1xuICAgIGNvbnN0cnVjdG9yKHR5LCB1aSkge1xuICAgICAgICBzdXBlcih1aSk7XG4gICAgICAgIHRoaXMudHkgPSB0eTtcbiAgICAgICAgdGhpcy51aSA9IHVpO1xuICAgIH1cbiAgICBnZW5lcmF0ZUZvcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLnVpLm9wZW4uY2hlY2tlZCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0ID0gdGhpcy51aS5yZW5kZXIodGhpcy50eSk7XG4gICAgICAgICAgICB0aGlzLmZvcm0gPSBbb3B0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlKGNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5mb3JtLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmZvcm1bMF0ucGFyc2UoY29uZmlnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFZlY0Zvcm0gZXh0ZW5kcyBJbnB1dEZvcm0ge1xuICAgIGNvbnN0cnVjdG9yKHR5LCB1aSkge1xuICAgICAgICBzdXBlcih1aSk7XG4gICAgICAgIHRoaXMudHkgPSB0eTtcbiAgICAgICAgdGhpcy51aSA9IHVpO1xuICAgIH1cbiAgICBnZW5lcmF0ZUZvcm0oKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9ICt0aGlzLnVpLm9wZW4udmFsdWU7XG4gICAgICAgIHRoaXMuZm9ybSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcy51aS5yZW5kZXIodGhpcy50eSk7XG4gICAgICAgICAgICB0aGlzLmZvcm0ucHVzaCh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZShjb25maWcpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmZvcm0ubWFwKGlucHV0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5wYXJzZShjb25maWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybS5zb21lKGlucHV0ID0+IGlucHV0LmlzUmVqZWN0ZWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbmRpZC1jb3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/candid-core.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/candid-ui.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/candid-ui.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Render: () => (/* binding */ Render),\n/* harmony export */   inputBox: () => (/* binding */ inputBox),\n/* harmony export */   optForm: () => (/* binding */ optForm),\n/* harmony export */   recordForm: () => (/* binding */ recordForm),\n/* harmony export */   renderInput: () => (/* binding */ renderInput),\n/* harmony export */   renderValue: () => (/* binding */ renderValue),\n/* harmony export */   tupleForm: () => (/* binding */ tupleForm),\n/* harmony export */   variantForm: () => (/* binding */ variantForm),\n/* harmony export */   vecForm: () => (/* binding */ vecForm)\n/* harmony export */ });\n/* harmony import */ var _idl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./idl */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/idl.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/principal */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _candid_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./candid-core */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/candid-core.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n\n\nconst InputConfig = { parse: parsePrimitive };\nconst FormConfig = { render: renderInput };\nconst inputBox = (t, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.InputBox(t, Object.assign(Object.assign({}, InputConfig), config));\n};\nconst recordForm = (fields, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.RecordForm(fields, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst tupleForm = (components, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.TupleForm(components, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst variantForm = (fields, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.VariantForm(fields, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst optForm = (ty, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.OptionForm(ty, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst vecForm = (ty, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.VecForm(ty, Object.assign(Object.assign({}, FormConfig), config));\n};\nclass Render extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitType(t, d) {\n        const input = document.createElement('input');\n        input.classList.add('argument');\n        input.placeholder = t.display();\n        return inputBox(t, { input });\n    }\n    visitNull(t, d) {\n        return inputBox(t, {});\n    }\n    visitRecord(t, fields, d) {\n        let config = {};\n        if (fields.length > 1) {\n            const container = document.createElement('div');\n            container.classList.add('popup-form');\n            config = { container };\n        }\n        const form = recordForm(fields, config);\n        return inputBox(t, { form });\n    }\n    visitTuple(t, components, d) {\n        let config = {};\n        if (components.length > 1) {\n            const container = document.createElement('div');\n            container.classList.add('popup-form');\n            config = { container };\n        }\n        const form = tupleForm(components, config);\n        return inputBox(t, { form });\n    }\n    visitVariant(t, fields, d) {\n        const select = document.createElement('select');\n        for (const [key, type] of fields) {\n            const option = new Option(key);\n            select.add(option);\n        }\n        select.selectedIndex = -1;\n        select.classList.add('open');\n        const config = { open: select, event: 'change' };\n        const form = variantForm(fields, config);\n        return inputBox(t, { form });\n    }\n    visitOpt(t, ty, d) {\n        const checkbox = document.createElement('input');\n        checkbox.type = 'checkbox';\n        checkbox.classList.add('open');\n        const form = optForm(ty, { open: checkbox, event: 'change' });\n        return inputBox(t, { form });\n    }\n    visitVec(t, ty, d) {\n        const len = document.createElement('input');\n        len.type = 'number';\n        len.min = '0';\n        len.max = '100';\n        len.style.width = '8rem';\n        len.placeholder = 'len';\n        len.classList.add('open');\n        const container = document.createElement('div');\n        container.classList.add('popup-form');\n        const form = vecForm(ty, { open: len, event: 'change', container });\n        return inputBox(t, { form });\n    }\n    visitRec(t, ty, d) {\n        return renderInput(ty);\n    }\n}\nclass Parse extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitNull(t, v) {\n        return null;\n    }\n    visitBool(t, v) {\n        if (v === 'true') {\n            return true;\n        }\n        if (v === 'false') {\n            return false;\n        }\n        throw new Error(`Cannot parse ${v} as boolean`);\n    }\n    visitText(t, v) {\n        return v;\n    }\n    visitFloat(t, v) {\n        return parseFloat(v);\n    }\n    visitFixedInt(t, v) {\n        if (t._bits <= 32) {\n            return parseInt(v, 10);\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    visitFixedNat(t, v) {\n        if (t._bits <= 32) {\n            return parseInt(v, 10);\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    visitNumber(t, v) {\n        return BigInt(v);\n    }\n    visitPrincipal(t, v) {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(v);\n    }\n    visitService(t, v) {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(v);\n    }\n    visitFunc(t, v) {\n        const x = v.split('.', 2);\n        return [_dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(x[0]), x[1]];\n    }\n}\nclass Random extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitNull(t, v) {\n        return null;\n    }\n    visitBool(t, v) {\n        return Math.random() < 0.5;\n    }\n    visitText(t, v) {\n        return Math.random().toString(36).substring(6);\n    }\n    visitFloat(t, v) {\n        return Math.random();\n    }\n    visitInt(t, v) {\n        return BigInt(this.generateNumber(true));\n    }\n    visitNat(t, v) {\n        return BigInt(this.generateNumber(false));\n    }\n    visitFixedInt(t, v) {\n        const x = this.generateNumber(true);\n        if (t._bits <= 32) {\n            return x;\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    visitFixedNat(t, v) {\n        const x = this.generateNumber(false);\n        if (t._bits <= 32) {\n            return x;\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    generateNumber(signed) {\n        const num = Math.floor(Math.random() * 100);\n        if (signed && Math.random() < 0.5) {\n            return -num;\n        }\n        else {\n            return num;\n        }\n    }\n}\nfunction parsePrimitive(t, config, d) {\n    if (config.random && d === '') {\n        return t.accept(new Random(), d);\n    }\n    else {\n        return t.accept(new Parse(), d);\n    }\n}\n/**\n *\n * @param t an IDL type\n * @returns an input for that type\n */\nfunction renderInput(t) {\n    return t.accept(new Render(), null);\n}\n/**\n *\n * @param t an IDL Type\n * @param input an InputBox\n * @param value any\n * @returns rendering that value to the provided input\n */\nfunction renderValue(t, input, value) {\n    return t.accept(new RenderValue(), { input, value });\n}\nclass RenderValue extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitType(t, d) {\n        d.input.ui.input.value = t.valueToString(d.value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    visitNull(t, d) { }\n    visitText(t, d) {\n        d.input.ui.input.value = d.value;\n    }\n    visitRec(t, ty, d) {\n        renderValue(ty, d.input, d.value);\n    }\n    visitOpt(t, ty, d) {\n        if (d.value.length === 0) {\n            return;\n        }\n        else {\n            const form = d.input.ui.form;\n            const open = form.ui.open;\n            open.checked = true;\n            open.dispatchEvent(new Event(form.ui.event));\n            renderValue(ty, form.form[0], d.value[0]);\n        }\n    }\n    visitRecord(t, fields, d) {\n        const form = d.input.ui.form;\n        fields.forEach(([key, type], i) => {\n            renderValue(type, form.form[i], d.value[key]);\n        });\n    }\n    visitTuple(t, components, d) {\n        const form = d.input.ui.form;\n        components.forEach((type, i) => {\n            renderValue(type, form.form[i], d.value[i]);\n        });\n    }\n    visitVariant(t, fields, d) {\n        const form = d.input.ui.form;\n        const selected = Object.entries(d.value)[0];\n        fields.forEach(([key, type], i) => {\n            if (key === selected[0]) {\n                const open = form.ui.open;\n                open.selectedIndex = i;\n                open.dispatchEvent(new Event(form.ui.event));\n                renderValue(type, form.form[0], selected[1]);\n            }\n        });\n    }\n    visitVec(t, ty, d) {\n        const form = d.input.ui.form;\n        const len = d.value.length;\n        const open = form.ui.open;\n        open.value = len;\n        open.dispatchEvent(new Event(form.ui.event));\n        d.value.forEach((v, i) => {\n            renderValue(ty, form.form[i], v);\n        });\n    }\n}\n//# sourceMappingURL=candid-ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vY2FuZGlkLXVpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDNkI7QUFDa0I7QUFDWDtBQUNwQyxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ2Q7QUFDUCxlQUFlLGtEQUFXLGtDQUFrQztBQUM1RDtBQUNPO0FBQ1AsZUFBZSxvREFBYSx1Q0FBdUM7QUFDbkU7QUFDTztBQUNQLGVBQWUsbURBQVksMkNBQTJDO0FBQ3RFO0FBQ087QUFDUCxlQUFlLHFEQUFjLHVDQUF1QztBQUNwRTtBQUNPO0FBQ1AsZUFBZSxvREFBYSxtQ0FBbUM7QUFDL0Q7QUFDTztBQUNQLGVBQWUsaURBQVUsbUNBQW1DO0FBQzVEO0FBQ08scUJBQXFCLHlDQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEUsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1Q0FBdUM7QUFDMUUsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5Q0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVM7QUFDeEI7QUFDQTtBQUNBLGVBQWUseURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUIseUNBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBLDBCQUEwQix5Q0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vY2FuZGlkLXVpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuaW1wb3J0ICogYXMgSURMIGZyb20gJy4vaWRsJztcbmltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgKiBhcyBVSSBmcm9tICcuL2NhbmRpZC1jb3JlJztcbmNvbnN0IElucHV0Q29uZmlnID0geyBwYXJzZTogcGFyc2VQcmltaXRpdmUgfTtcbmNvbnN0IEZvcm1Db25maWcgPSB7IHJlbmRlcjogcmVuZGVySW5wdXQgfTtcbmV4cG9ydCBjb25zdCBpbnB1dEJveCA9ICh0LCBjb25maWcpID0+IHtcbiAgICByZXR1cm4gbmV3IFVJLklucHV0Qm94KHQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgSW5wdXRDb25maWcpLCBjb25maWcpKTtcbn07XG5leHBvcnQgY29uc3QgcmVjb3JkRm9ybSA9IChmaWVsZHMsIGNvbmZpZykgPT4ge1xuICAgIHJldHVybiBuZXcgVUkuUmVjb3JkRm9ybShmaWVsZHMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRm9ybUNvbmZpZyksIGNvbmZpZykpO1xufTtcbmV4cG9ydCBjb25zdCB0dXBsZUZvcm0gPSAoY29tcG9uZW50cywgY29uZmlnKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBVSS5UdXBsZUZvcm0oY29tcG9uZW50cywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBGb3JtQ29uZmlnKSwgY29uZmlnKSk7XG59O1xuZXhwb3J0IGNvbnN0IHZhcmlhbnRGb3JtID0gKGZpZWxkcywgY29uZmlnKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBVSS5WYXJpYW50Rm9ybShmaWVsZHMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRm9ybUNvbmZpZyksIGNvbmZpZykpO1xufTtcbmV4cG9ydCBjb25zdCBvcHRGb3JtID0gKHR5LCBjb25maWcpID0+IHtcbiAgICByZXR1cm4gbmV3IFVJLk9wdGlvbkZvcm0odHksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRm9ybUNvbmZpZyksIGNvbmZpZykpO1xufTtcbmV4cG9ydCBjb25zdCB2ZWNGb3JtID0gKHR5LCBjb25maWcpID0+IHtcbiAgICByZXR1cm4gbmV3IFVJLlZlY0Zvcm0odHksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRm9ybUNvbmZpZyksIGNvbmZpZykpO1xufTtcbmV4cG9ydCBjbGFzcyBSZW5kZXIgZXh0ZW5kcyBJREwuVmlzaXRvciB7XG4gICAgdmlzaXRUeXBlKHQsIGQpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdhcmd1bWVudCcpO1xuICAgICAgICBpbnB1dC5wbGFjZWhvbGRlciA9IHQuZGlzcGxheSgpO1xuICAgICAgICByZXR1cm4gaW5wdXRCb3godCwgeyBpbnB1dCB9KTtcbiAgICB9XG4gICAgdmlzaXROdWxsKHQsIGQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0Qm94KHQsIHt9KTtcbiAgICB9XG4gICAgdmlzaXRSZWNvcmQodCwgZmllbGRzLCBkKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB7fTtcbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdwb3B1cC1mb3JtJyk7XG4gICAgICAgICAgICBjb25maWcgPSB7IGNvbnRhaW5lciB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm0gPSByZWNvcmRGb3JtKGZpZWxkcywgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGlucHV0Qm94KHQsIHsgZm9ybSB9KTtcbiAgICB9XG4gICAgdmlzaXRUdXBsZSh0LCBjb21wb25lbnRzLCBkKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB7fTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgncG9wdXAtZm9ybScpO1xuICAgICAgICAgICAgY29uZmlnID0geyBjb250YWluZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtID0gdHVwbGVGb3JtKGNvbXBvbmVudHMsIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBpbnB1dEJveCh0LCB7IGZvcm0gfSk7XG4gICAgfVxuICAgIHZpc2l0VmFyaWFudCh0LCBmaWVsZHMsIGQpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdHlwZV0gb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSBuZXcgT3B0aW9uKGtleSk7XG4gICAgICAgICAgICBzZWxlY3QuYWRkKG9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgc2VsZWN0LmNsYXNzTGlzdC5hZGQoJ29wZW4nKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0geyBvcGVuOiBzZWxlY3QsIGV2ZW50OiAnY2hhbmdlJyB9O1xuICAgICAgICBjb25zdCBmb3JtID0gdmFyaWFudEZvcm0oZmllbGRzLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gaW5wdXRCb3godCwgeyBmb3JtIH0pO1xuICAgIH1cbiAgICB2aXNpdE9wdCh0LCB0eSwgZCkge1xuICAgICAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICBjaGVja2JveC5jbGFzc0xpc3QuYWRkKCdvcGVuJyk7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBvcHRGb3JtKHR5LCB7IG9wZW46IGNoZWNrYm94LCBldmVudDogJ2NoYW5nZScgfSk7XG4gICAgICAgIHJldHVybiBpbnB1dEJveCh0LCB7IGZvcm0gfSk7XG4gICAgfVxuICAgIHZpc2l0VmVjKHQsIHR5LCBkKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGxlbi50eXBlID0gJ251bWJlcic7XG4gICAgICAgIGxlbi5taW4gPSAnMCc7XG4gICAgICAgIGxlbi5tYXggPSAnMTAwJztcbiAgICAgICAgbGVuLnN0eWxlLndpZHRoID0gJzhyZW0nO1xuICAgICAgICBsZW4ucGxhY2Vob2xkZXIgPSAnbGVuJztcbiAgICAgICAgbGVuLmNsYXNzTGlzdC5hZGQoJ29wZW4nKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdwb3B1cC1mb3JtJyk7XG4gICAgICAgIGNvbnN0IGZvcm0gPSB2ZWNGb3JtKHR5LCB7IG9wZW46IGxlbiwgZXZlbnQ6ICdjaGFuZ2UnLCBjb250YWluZXIgfSk7XG4gICAgICAgIHJldHVybiBpbnB1dEJveCh0LCB7IGZvcm0gfSk7XG4gICAgfVxuICAgIHZpc2l0UmVjKHQsIHR5LCBkKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJJbnB1dCh0eSk7XG4gICAgfVxufVxuY2xhc3MgUGFyc2UgZXh0ZW5kcyBJREwuVmlzaXRvciB7XG4gICAgdmlzaXROdWxsKHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0Qm9vbCh0LCB2KSB7XG4gICAgICAgIGlmICh2ID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgJHt2fSBhcyBib29sZWFuYCk7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0LCB2KSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICB2aXNpdEZsb2F0KHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodik7XG4gICAgfVxuICAgIHZpc2l0Rml4ZWRJbnQodCwgdikge1xuICAgICAgICBpZiAodC5fYml0cyA8PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHYsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRGaXhlZE5hdCh0LCB2KSB7XG4gICAgICAgIGlmICh0Ll9iaXRzIDw9IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdE51bWJlcih0LCB2KSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodik7XG4gICAgfVxuICAgIHZpc2l0UHJpbmNpcGFsKHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIFByaW5jaXBhbC5mcm9tVGV4dCh2KTtcbiAgICB9XG4gICAgdmlzaXRTZXJ2aWNlKHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIFByaW5jaXBhbC5mcm9tVGV4dCh2KTtcbiAgICB9XG4gICAgdmlzaXRGdW5jKHQsIHYpIHtcbiAgICAgICAgY29uc3QgeCA9IHYuc3BsaXQoJy4nLCAyKTtcbiAgICAgICAgcmV0dXJuIFtQcmluY2lwYWwuZnJvbVRleHQoeFswXSksIHhbMV1dO1xuICAgIH1cbn1cbmNsYXNzIFJhbmRvbSBleHRlbmRzIElETC5WaXNpdG9yIHtcbiAgICB2aXNpdE51bGwodCwgdikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRCb29sKHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCAwLjU7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0LCB2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNik7XG4gICAgfVxuICAgIHZpc2l0RmxvYXQodCwgdikge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgICB9XG4gICAgdmlzaXRJbnQodCwgdikge1xuICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMuZ2VuZXJhdGVOdW1iZXIodHJ1ZSkpO1xuICAgIH1cbiAgICB2aXNpdE5hdCh0LCB2KSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy5nZW5lcmF0ZU51bWJlcihmYWxzZSkpO1xuICAgIH1cbiAgICB2aXNpdEZpeGVkSW50KHQsIHYpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2VuZXJhdGVOdW1iZXIodHJ1ZSk7XG4gICAgICAgIGlmICh0Ll9iaXRzIDw9IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRGaXhlZE5hdCh0LCB2KSB7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmdlbmVyYXRlTnVtYmVyKGZhbHNlKTtcbiAgICAgICAgaWYgKHQuX2JpdHMgPD0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW5lcmF0ZU51bWJlcihzaWduZWQpIHtcbiAgICAgICAgY29uc3QgbnVtID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgICAgICAgaWYgKHNpZ25lZCAmJiBNYXRoLnJhbmRvbSgpIDwgMC41KSB7XG4gICAgICAgICAgICByZXR1cm4gLW51bTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVByaW1pdGl2ZSh0LCBjb25maWcsIGQpIHtcbiAgICBpZiAoY29uZmlnLnJhbmRvbSAmJiBkID09PSAnJykge1xuICAgICAgICByZXR1cm4gdC5hY2NlcHQobmV3IFJhbmRvbSgpLCBkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0LmFjY2VwdChuZXcgUGFyc2UoKSwgZCk7XG4gICAgfVxufVxuLyoqXG4gKlxuICogQHBhcmFtIHQgYW4gSURMIHR5cGVcbiAqIEByZXR1cm5zIGFuIGlucHV0IGZvciB0aGF0IHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcklucHV0KHQpIHtcbiAgICByZXR1cm4gdC5hY2NlcHQobmV3IFJlbmRlcigpLCBudWxsKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB0IGFuIElETCBUeXBlXG4gKiBAcGFyYW0gaW5wdXQgYW4gSW5wdXRCb3hcbiAqIEBwYXJhbSB2YWx1ZSBhbnlcbiAqIEByZXR1cm5zIHJlbmRlcmluZyB0aGF0IHZhbHVlIHRvIHRoZSBwcm92aWRlZCBpbnB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVmFsdWUodCwgaW5wdXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHQuYWNjZXB0KG5ldyBSZW5kZXJWYWx1ZSgpLCB7IGlucHV0LCB2YWx1ZSB9KTtcbn1cbmNsYXNzIFJlbmRlclZhbHVlIGV4dGVuZHMgSURMLlZpc2l0b3Ige1xuICAgIHZpc2l0VHlwZSh0LCBkKSB7XG4gICAgICAgIGQuaW5wdXQudWkuaW5wdXQudmFsdWUgPSB0LnZhbHVlVG9TdHJpbmcoZC52YWx1ZSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgICB2aXNpdE51bGwodCwgZCkgeyB9XG4gICAgdmlzaXRUZXh0KHQsIGQpIHtcbiAgICAgICAgZC5pbnB1dC51aS5pbnB1dC52YWx1ZSA9IGQudmFsdWU7XG4gICAgfVxuICAgIHZpc2l0UmVjKHQsIHR5LCBkKSB7XG4gICAgICAgIHJlbmRlclZhbHVlKHR5LCBkLmlucHV0LCBkLnZhbHVlKTtcbiAgICB9XG4gICAgdmlzaXRPcHQodCwgdHksIGQpIHtcbiAgICAgICAgaWYgKGQudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtID0gZC5pbnB1dC51aS5mb3JtO1xuICAgICAgICAgICAgY29uc3Qgb3BlbiA9IGZvcm0udWkub3BlbjtcbiAgICAgICAgICAgIG9wZW4uY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICBvcGVuLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KGZvcm0udWkuZXZlbnQpKTtcbiAgICAgICAgICAgIHJlbmRlclZhbHVlKHR5LCBmb3JtLmZvcm1bMF0sIGQudmFsdWVbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0UmVjb3JkKHQsIGZpZWxkcywgZCkge1xuICAgICAgICBjb25zdCBmb3JtID0gZC5pbnB1dC51aS5mb3JtO1xuICAgICAgICBmaWVsZHMuZm9yRWFjaCgoW2tleSwgdHlwZV0sIGkpID0+IHtcbiAgICAgICAgICAgIHJlbmRlclZhbHVlKHR5cGUsIGZvcm0uZm9ybVtpXSwgZC52YWx1ZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0VHVwbGUodCwgY29tcG9uZW50cywgZCkge1xuICAgICAgICBjb25zdCBmb3JtID0gZC5pbnB1dC51aS5mb3JtO1xuICAgICAgICBjb21wb25lbnRzLmZvckVhY2goKHR5cGUsIGkpID0+IHtcbiAgICAgICAgICAgIHJlbmRlclZhbHVlKHR5cGUsIGZvcm0uZm9ybVtpXSwgZC52YWx1ZVtpXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdFZhcmlhbnQodCwgZmllbGRzLCBkKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBkLmlucHV0LnVpLmZvcm07XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gT2JqZWN0LmVudHJpZXMoZC52YWx1ZSlbMF07XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKChba2V5LCB0eXBlXSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gc2VsZWN0ZWRbMF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGVuID0gZm9ybS51aS5vcGVuO1xuICAgICAgICAgICAgICAgIG9wZW4uc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgb3Blbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChmb3JtLnVpLmV2ZW50KSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyVmFsdWUodHlwZSwgZm9ybS5mb3JtWzBdLCBzZWxlY3RlZFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdFZlYyh0LCB0eSwgZCkge1xuICAgICAgICBjb25zdCBmb3JtID0gZC5pbnB1dC51aS5mb3JtO1xuICAgICAgICBjb25zdCBsZW4gPSBkLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb3BlbiA9IGZvcm0udWkub3BlbjtcbiAgICAgICAgb3Blbi52YWx1ZSA9IGxlbjtcbiAgICAgICAgb3Blbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChmb3JtLnVpLmV2ZW50KSk7XG4gICAgICAgIGQudmFsdWUuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgcmVuZGVyVmFsdWUodHksIGZvcm0uZm9ybVtpXSwgdik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbmRpZC11aS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/candid-ui.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/idl.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/idl.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bool: () => (/* binding */ Bool),\n/* harmony export */   BoolClass: () => (/* binding */ BoolClass),\n/* harmony export */   ConstructType: () => (/* binding */ ConstructType),\n/* harmony export */   Empty: () => (/* binding */ Empty),\n/* harmony export */   EmptyClass: () => (/* binding */ EmptyClass),\n/* harmony export */   FixedIntClass: () => (/* binding */ FixedIntClass),\n/* harmony export */   FixedNatClass: () => (/* binding */ FixedNatClass),\n/* harmony export */   Float32: () => (/* binding */ Float32),\n/* harmony export */   Float64: () => (/* binding */ Float64),\n/* harmony export */   FloatClass: () => (/* binding */ FloatClass),\n/* harmony export */   Func: () => (/* binding */ Func),\n/* harmony export */   FuncClass: () => (/* binding */ FuncClass),\n/* harmony export */   Int: () => (/* binding */ Int),\n/* harmony export */   Int16: () => (/* binding */ Int16),\n/* harmony export */   Int32: () => (/* binding */ Int32),\n/* harmony export */   Int64: () => (/* binding */ Int64),\n/* harmony export */   Int8: () => (/* binding */ Int8),\n/* harmony export */   IntClass: () => (/* binding */ IntClass),\n/* harmony export */   Nat: () => (/* binding */ Nat),\n/* harmony export */   Nat16: () => (/* binding */ Nat16),\n/* harmony export */   Nat32: () => (/* binding */ Nat32),\n/* harmony export */   Nat64: () => (/* binding */ Nat64),\n/* harmony export */   Nat8: () => (/* binding */ Nat8),\n/* harmony export */   NatClass: () => (/* binding */ NatClass),\n/* harmony export */   Null: () => (/* binding */ Null),\n/* harmony export */   NullClass: () => (/* binding */ NullClass),\n/* harmony export */   Opt: () => (/* binding */ Opt),\n/* harmony export */   OptClass: () => (/* binding */ OptClass),\n/* harmony export */   PrimitiveType: () => (/* binding */ PrimitiveType),\n/* harmony export */   Principal: () => (/* binding */ Principal),\n/* harmony export */   PrincipalClass: () => (/* binding */ PrincipalClass),\n/* harmony export */   Rec: () => (/* binding */ Rec),\n/* harmony export */   RecClass: () => (/* binding */ RecClass),\n/* harmony export */   Record: () => (/* binding */ Record),\n/* harmony export */   RecordClass: () => (/* binding */ RecordClass),\n/* harmony export */   Reserved: () => (/* binding */ Reserved),\n/* harmony export */   ReservedClass: () => (/* binding */ ReservedClass),\n/* harmony export */   Service: () => (/* binding */ Service),\n/* harmony export */   ServiceClass: () => (/* binding */ ServiceClass),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   TextClass: () => (/* binding */ TextClass),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   TupleClass: () => (/* binding */ TupleClass),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   Unknown: () => (/* binding */ Unknown),\n/* harmony export */   UnknownClass: () => (/* binding */ UnknownClass),\n/* harmony export */   Variant: () => (/* binding */ Variant),\n/* harmony export */   VariantClass: () => (/* binding */ VariantClass),\n/* harmony export */   Vec: () => (/* binding */ Vec),\n/* harmony export */   VecClass: () => (/* binding */ VecClass),\n/* harmony export */   Visitor: () => (/* binding */ Visitor),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/buffer */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* harmony import */ var _utils_hash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hash */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/hash.js\");\n/* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/leb128 */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/leb128.js\");\n/* harmony import */ var _utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/bigint-math */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js\");\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\n\n\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\nfunction zipWith(xs, ys, f) {\n    return xs.map((x, i) => f(x, ys[i]));\n}\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n    constructor() {\n        // List of types. Needs to be an array as the index needs to be stable.\n        this._typs = [];\n        this._idx = new Map();\n    }\n    has(obj) {\n        return this._idx.has(obj.name);\n    }\n    add(type, buf) {\n        const idx = this._typs.length;\n        this._idx.set(type.name, idx);\n        this._typs.push(buf);\n    }\n    merge(obj, knot) {\n        const idx = this._idx.get(obj.name);\n        const knotIdx = this._idx.get(knot);\n        if (idx === undefined) {\n            throw new Error('Missing type index for ' + obj);\n        }\n        if (knotIdx === undefined) {\n            throw new Error('Missing type index for ' + knot);\n        }\n        this._typs[idx] = this._typs[knotIdx];\n        // Delete the type.\n        this._typs.splice(knotIdx, 1);\n        this._idx.delete(knot);\n    }\n    encode() {\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._typs.length);\n        const buf = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this._typs);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, buf);\n    }\n    indexOf(typeName) {\n        if (!this._idx.has(typeName)) {\n            throw new Error('Missing type index for ' + typeName);\n        }\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(this._idx.get(typeName) || 0);\n    }\n}\nclass Visitor {\n    visitType(t, data) {\n        throw new Error('Not implemented');\n    }\n    visitPrimitive(t, data) {\n        return this.visitType(t, data);\n    }\n    visitEmpty(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitBool(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNull(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitReserved(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitText(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNumber(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFloat(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitFixedInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFixedNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitPrincipal(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitConstruct(t, data) {\n        return this.visitType(t, data);\n    }\n    visitVec(t, ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitOpt(t, ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRecord(t, fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitTuple(t, components, data) {\n        const fields = components.map((ty, i) => [`_${i}_`, ty]);\n        return this.visitRecord(t, fields, data);\n    }\n    visitVariant(t, fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRec(t, ty, data) {\n        return this.visitConstruct(ty, data);\n    }\n    visitFunc(t, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitService(t, data) {\n        return this.visitConstruct(t, data);\n    }\n}\n/**\n * Represents an IDL type.\n */\nclass Type {\n    /* Display type name */\n    display() {\n        return this.name;\n    }\n    valueToString(x) {\n        return toReadableString(x);\n    }\n    /* Implement `T` in the IDL spec, only needed for non-primitive types */\n    buildTypeTable(typeTable) {\n        if (!typeTable.has(this)) {\n            this._buildTypeTableImpl(typeTable);\n        }\n    }\n}\nclass PrimitiveType extends Type {\n    checkType(t) {\n        if (this.name !== t.name) {\n            throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n        }\n        return t;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _buildTypeTableImpl(typeTable) {\n        // No type table encoding for Primitive types.\n        return;\n    }\n}\nclass ConstructType extends Type {\n    checkType(t) {\n        if (t instanceof RecClass) {\n            const ty = t.getType();\n            if (typeof ty === 'undefined') {\n                throw new Error('type mismatch with uninitialized type');\n            }\n            return ty;\n        }\n        throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    encodeType(typeTable) {\n        return typeTable.indexOf(this.name);\n    }\n}\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nclass EmptyClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitEmpty(this, d);\n    }\n    covariant(x) {\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        throw new Error('Empty cannot appear as a function argument');\n    }\n    valueToString() {\n        throw new Error('Empty cannot appear as a value');\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-17 /* IDLTypeIds.Empty */);\n    }\n    decodeValue() {\n        throw new Error('Empty cannot appear as an output');\n    }\n    get name() {\n        return 'empty';\n    }\n}\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nclass UnknownClass extends Type {\n    checkType(t) {\n        throw new Error('Method not implemented for unknown.');\n    }\n    accept(v, d) {\n        throw v.visitType(this, d);\n    }\n    covariant(x) {\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        throw new Error('Unknown cannot appear as a function argument');\n    }\n    valueToString() {\n        throw new Error('Unknown cannot appear as a value');\n    }\n    encodeType() {\n        throw new Error('Unknown cannot be serialized');\n    }\n    decodeValue(b, t) {\n        let decodedValue = t.decodeValue(b, t);\n        if (Object(decodedValue) !== decodedValue) {\n            // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n            // The type() function is important for primitives because otherwise we cannot tell apart the\n            // different number types.\n            decodedValue = Object(decodedValue);\n        }\n        let typeFunc;\n        if (t instanceof RecClass) {\n            typeFunc = () => t.getType();\n        }\n        else {\n            typeFunc = () => t;\n        }\n        // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n        // 'type' which means it would be serialized if the value would be candid encoded again.\n        // This in turn leads to problems if the decoded value is a variant because these values are\n        // only allowed to have a single property.\n        Object.defineProperty(decodedValue, 'type', {\n            value: typeFunc,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        });\n        return decodedValue;\n    }\n    _buildTypeTableImpl() {\n        throw new Error('Unknown cannot be serialized');\n    }\n    get name() {\n        return 'Unknown';\n    }\n}\n/**\n * Represents an IDL Bool\n */\nclass BoolClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitBool(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'boolean')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return new Uint8Array([x ? 1 : 0]);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-2 /* IDLTypeIds.Bool */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        switch ((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b)) {\n            case 0:\n                return false;\n            case 1:\n                return true;\n            default:\n                throw new Error('Boolean value out of range');\n        }\n    }\n    get name() {\n        return 'bool';\n    }\n}\n/**\n * Represents an IDL Null\n */\nclass NullClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitNull(this, d);\n    }\n    covariant(x) {\n        if (x === null)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        return new ArrayBuffer(0);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-1 /* IDLTypeIds.Null */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return null;\n    }\n    get name() {\n        return 'null';\n    }\n}\n/**\n * Represents an IDL Reserved\n */\nclass ReservedClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitReserved(this, d);\n    }\n    covariant(x) {\n        return true;\n    }\n    encodeValue() {\n        return new ArrayBuffer(0);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-16 /* IDLTypeIds.Reserved */);\n    }\n    decodeValue(b, t) {\n        if (t.name !== this.name) {\n            t.decodeValue(b, t);\n        }\n        return null;\n    }\n    get name() {\n        return 'reserved';\n    }\n}\n/**\n * Represents an IDL Text\n */\nclass TextClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitText(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'string')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = new TextEncoder().encode(x);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, buf);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-15 /* IDLTypeIds.Text */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b);\n        const buf = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, Number(len));\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        return decoder.decode(buf);\n    }\n    get name() {\n        return 'text';\n    }\n    valueToString(x) {\n        return '\"' + x + '\"';\n    }\n}\n/**\n * Represents an IDL Int\n */\nclass IntClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitInt(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        if (typeof x === 'bigint' || Number.isInteger(x))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(x);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-4 /* IDLTypeIds.Int */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(b);\n    }\n    get name() {\n        return 'int';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Nat\n */\nclass NatClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitNat(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(x);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-3 /* IDLTypeIds.Nat */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b);\n    }\n    get name() {\n        return 'nat';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Float\n */\nclass FloatClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n        if (_bits !== 32 && _bits !== 64) {\n            throw new Error('not a valid float type');\n        }\n    }\n    accept(v, d) {\n        return v.visitFloat(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'number' || x instanceof Number)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = new ArrayBuffer(this._bits / 8);\n        const view = new DataView(buf);\n        if (this._bits === 32) {\n            view.setFloat32(0, x, true);\n        }\n        else {\n            view.setFloat64(0, x, true);\n        }\n        return buf;\n    }\n    encodeType() {\n        const opcode = this._bits === 32 ? -13 /* IDLTypeIds.Float32 */ : -14 /* IDLTypeIds.Float64 */;\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(opcode);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const bytes = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, this._bits / 8);\n        const view = new DataView(bytes);\n        if (this._bits === 32) {\n            return view.getFloat32(0, true);\n        }\n        else {\n            return view.getFloat64(0, true);\n        }\n    }\n    get name() {\n        return 'float' + this._bits;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Int(n)\n */\nclass FixedIntClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n    }\n    accept(v, d) {\n        return v.visitFixedInt(this, d);\n    }\n    covariant(x) {\n        const min = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits - 1) * BigInt(-1);\n        const max = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits - 1) - BigInt(1);\n        let ok = false;\n        if (typeof x === 'bigint') {\n            ok = x >= min && x <= max;\n        }\n        else if (Number.isInteger(x)) {\n            const v = BigInt(x);\n            ok = v >= min && v <= max;\n        }\n        else {\n            ok = false;\n        }\n        if (ok)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.writeIntLE)(x, this._bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this._bits) - 3;\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-9 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.readIntLE)(b, this._bits / 8);\n        if (this._bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `int${this._bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nclass FixedNatClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n    }\n    accept(v, d) {\n        return v.visitFixedNat(this, d);\n    }\n    covariant(x) {\n        const max = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits);\n        let ok = false;\n        if (typeof x === 'bigint' && x >= BigInt(0)) {\n            ok = x < max;\n        }\n        else if (Number.isInteger(x) && x >= 0) {\n            const v = BigInt(x);\n            ok = v < max;\n        }\n        else {\n            ok = false;\n        }\n        if (ok)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.writeUIntLE)(x, this._bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this._bits) - 3;\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-5 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.readUIntLE)(b, this._bits / 8);\n        if (this._bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `nat${this._bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nclass VecClass extends ConstructType {\n    constructor(_type) {\n        super();\n        this._type = _type;\n        // If true, this vector is really a blob and we can just use memcpy.\n        //\n        // NOTE:\n        // With support of encoding/dencoding of TypedArrays, this optimization is\n        // only used when plain array of bytes are passed as encoding input in order\n        // to be backward compatible.\n        this._blobOptimization = false;\n        if (_type instanceof FixedNatClass && _type._bits === 8) {\n            this._blobOptimization = true;\n        }\n    }\n    accept(v, d) {\n        return v.visitVec(this, this._type, d);\n    }\n    covariant(x) {\n        // Special case for ArrayBuffer\n        const bits = this._type instanceof FixedNatClass\n            ? this._type._bits\n            : this._type instanceof FixedIntClass\n                ? this._type._bits\n                : 0;\n        if ((ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8) ||\n            (Array.isArray(x) &&\n                x.every((v, idx) => {\n                    try {\n                        return this._type.covariant(v);\n                    }\n                    catch (e) {\n                        throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n                    }\n                })))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(x.length);\n        if (this._blobOptimization) {\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(x));\n        }\n        if (ArrayBuffer.isView(x)) {\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(x.buffer));\n        }\n        const buf = new _utils_buffer__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(new ArrayBuffer(len.byteLength + x.length), 0);\n        buf.write(len);\n        for (const d of x) {\n            const encoded = this._type.encodeValue(d);\n            buf.write(new Uint8Array(encoded));\n        }\n        return buf.buffer;\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-19 /* IDLTypeIds.Vector */);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const vec = this.checkType(t);\n        if (!(vec instanceof VecClass)) {\n            throw new Error('Not a vector type');\n        }\n        const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n        if (this._type instanceof FixedNatClass) {\n            if (this._type._bits == 8) {\n                return new Uint8Array(b.read(len));\n            }\n            if (this._type._bits == 16) {\n                return new Uint16Array(b.read(len * 2));\n            }\n            if (this._type._bits == 32) {\n                return new Uint32Array(b.read(len * 4));\n            }\n            if (this._type._bits == 64) {\n                return new BigUint64Array(b.read(len * 8));\n            }\n        }\n        if (this._type instanceof FixedIntClass) {\n            if (this._type._bits == 8) {\n                return new Int8Array(b.read(len));\n            }\n            if (this._type._bits == 16) {\n                return new Int16Array(b.read(len * 2));\n            }\n            if (this._type._bits == 32) {\n                return new Int32Array(b.read(len * 4));\n            }\n            if (this._type._bits == 64) {\n                return new BigInt64Array(b.read(len * 8));\n            }\n        }\n        const rets = [];\n        for (let i = 0; i < len; i++) {\n            rets.push(this._type.decodeValue(b, vec._type));\n        }\n        return rets;\n    }\n    get name() {\n        return `vec ${this._type.name}`;\n    }\n    display() {\n        return `vec ${this._type.display()}`;\n    }\n    valueToString(x) {\n        const elements = x.map(e => this._type.valueToString(e));\n        return 'vec {' + elements.join('; ') + '}';\n    }\n}\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nclass OptClass extends ConstructType {\n    constructor(_type) {\n        super();\n        this._type = _type;\n    }\n    accept(v, d) {\n        return v.visitOpt(this, this._type, d);\n    }\n    covariant(x) {\n        try {\n            if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))\n                return true;\n        }\n        catch (e) {\n            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`);\n        }\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        if (x.length === 0) {\n            return new Uint8Array([0]);\n        }\n        else {\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), this._type.encodeValue(x[0]));\n        }\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-18 /* IDLTypeIds.Opt */);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const opt = this.checkType(t);\n        if (!(opt instanceof OptClass)) {\n            throw new Error('Not an option type');\n        }\n        switch ((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b)) {\n            case 0:\n                return [];\n            case 1:\n                return [this._type.decodeValue(b, opt._type)];\n            default:\n                throw new Error('Not an option value');\n        }\n    }\n    get name() {\n        return `opt ${this._type.name}`;\n    }\n    display() {\n        return `opt ${this._type.display()}`;\n    }\n    valueToString(x) {\n        if (x.length === 0) {\n            return 'null';\n        }\n        else {\n            return `opt ${this._type.valueToString(x[0])}`;\n        }\n    }\n}\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nclass RecordClass extends ConstructType {\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(b[0]));\n    }\n    accept(v, d) {\n        return v.visitRecord(this, this._fields, d);\n    }\n    tryAsTuple() {\n        const res = [];\n        for (let i = 0; i < this._fields.length; i++) {\n            const [key, type] = this._fields[i];\n            if (key !== `_${i}_`) {\n                return null;\n            }\n            res.push(type);\n        }\n        return res;\n    }\n    covariant(x) {\n        if (typeof x === 'object' &&\n            this._fields.every(([k, t]) => {\n                // eslint-disable-next-line\n                if (!x.hasOwnProperty(k)) {\n                    throw new Error(`Record is missing key \"${k}\".`);\n                }\n                try {\n                    return t.covariant(x[k]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...bufs);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-20 /* IDLTypeIds.Record */);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);\n        const fields = this._fields.map(([key, value]) => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)), value.encodeType(T)));\n        T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...fields)));\n    }\n    decodeValue(b, t) {\n        const record = this.checkType(t);\n        if (!(record instanceof RecordClass)) {\n            throw new Error('Not a record type');\n        }\n        const x = {};\n        let expectedRecordIdx = 0;\n        let actualRecordIdx = 0;\n        while (actualRecordIdx < record._fields.length) {\n            const [hash, type] = record._fields[actualRecordIdx];\n            if (expectedRecordIdx >= this._fields.length) {\n                // skip unexpected left over fields present on the wire\n                type.decodeValue(b, type);\n                actualRecordIdx++;\n                continue;\n            }\n            const [expectKey, expectType] = this._fields[expectedRecordIdx];\n            const expectedId = (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(this._fields[expectedRecordIdx][0]);\n            const actualId = (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(hash);\n            if (expectedId === actualId) {\n                // the current field on the wire matches the expected field\n                x[expectKey] = expectType.decodeValue(b, type);\n                expectedRecordIdx++;\n                actualRecordIdx++;\n            }\n            else if (actualId > expectedId) {\n                // The expected field does not exist on the wire\n                if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n                    x[expectKey] = [];\n                    expectedRecordIdx++;\n                }\n                else {\n                    throw new Error('Cannot find required field ' + expectKey);\n                }\n            }\n            else {\n                // The field on the wire does not exist in the output type, so we can skip it\n                type.decodeValue(b, type);\n                actualRecordIdx++;\n            }\n        }\n        // initialize left over expected optional fields\n        for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n            if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n                // TODO this assumes null value in opt is represented as []\n                x[expectKey] = [];\n            }\n            else {\n                throw new Error('Cannot find required field ' + expectKey);\n            }\n        }\n        return x;\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `record {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nclass TupleClass extends RecordClass {\n    constructor(_components) {\n        const x = {};\n        _components.forEach((e, i) => (x['_' + i + '_'] = e));\n        super(x);\n        this._components = _components;\n    }\n    accept(v, d) {\n        return v.visitTuple(this, this._components, d);\n    }\n    covariant(x) {\n        // `>=` because tuples can be covariant when encoded.\n        if (Array.isArray(x) &&\n            x.length >= this._fields.length &&\n            this._components.every((t, i) => {\n                try {\n                    return t.covariant(x[i]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...bufs);\n    }\n    decodeValue(b, t) {\n        const tuple = this.checkType(t);\n        if (!(tuple instanceof TupleClass)) {\n            throw new Error('not a tuple type');\n        }\n        if (tuple._components.length < this._components.length) {\n            throw new Error('tuple mismatch');\n        }\n        const res = [];\n        for (const [i, wireType] of tuple._components.entries()) {\n            if (i >= this._components.length) {\n                // skip value\n                wireType.decodeValue(b, wireType);\n            }\n            else {\n                res.push(this._components[i].decodeValue(b, wireType));\n            }\n        }\n        return res;\n    }\n    display() {\n        const fields = this._components.map(value => value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(values) {\n        const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nclass VariantClass extends ConstructType {\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(b[0]));\n    }\n    accept(v, d) {\n        return v.visitVariant(this, this._fields, d);\n    }\n    covariant(x) {\n        if (typeof x === 'object' &&\n            Object.entries(x).length === 1 &&\n            this._fields.every(([k, v]) => {\n                try {\n                    // eslint-disable-next-line\n                    return !x.hasOwnProperty(k) || v.covariant(x[k]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        for (let i = 0; i < this._fields.length; i++) {\n            const [name, type] = this._fields[i];\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const idx = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(i);\n                const buf = type.encodeValue(x[name]);\n                return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(idx, buf);\n            }\n        }\n        throw Error('Variant has no data: ' + x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._fields.forEach(([, type]) => {\n            type.buildTypeTable(typeTable);\n        });\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-21 /* IDLTypeIds.Variant */);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);\n        const fields = this._fields.map(([key, value]) => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)), value.encodeType(typeTable)));\n        typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, ...fields));\n    }\n    decodeValue(b, t) {\n        const variant = this.checkType(t);\n        if (!(variant instanceof VariantClass)) {\n            throw new Error('Not a variant type');\n        }\n        const idx = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n        if (idx >= variant._fields.length) {\n            throw Error('Invalid variant index: ' + idx);\n        }\n        const [wireHash, wireType] = variant._fields[idx];\n        for (const [key, expectType] of this._fields) {\n            if ((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(wireHash) === (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)) {\n                const value = expectType.decodeValue(b, wireType);\n                return { [key]: value };\n            }\n        }\n        throw new Error('Cannot find field hash ' + wireHash);\n    }\n    get name() {\n        const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n        return `variant {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`));\n        return `variant {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        for (const [name, type] of this._fields) {\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const value = type.valueToString(x[name]);\n                if (value === 'null') {\n                    return `variant {${name}}`;\n                }\n                else {\n                    return `variant {${name}=${value}}`;\n                }\n            }\n        }\n        throw new Error('Variant has no data: ' + x);\n    }\n}\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nclass RecClass extends ConstructType {\n    constructor() {\n        super(...arguments);\n        this._id = RecClass._counter++;\n        this._type = undefined;\n    }\n    accept(v, d) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return v.visitRec(this, this._type, d);\n    }\n    fill(t) {\n        this._type = t;\n    }\n    getType() {\n        return this._type;\n    }\n    covariant(x) {\n        if (this._type ? this._type.covariant(x) : false)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.encodeValue(x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        typeTable.add(this, new Uint8Array([]));\n        this._type.buildTypeTable(typeTable);\n        typeTable.merge(this, this._type.name);\n    }\n    decodeValue(b, t) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.decodeValue(b, t);\n    }\n    get name() {\n        return `rec_${this._id}`;\n    }\n    display() {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return `μ${this.name}.${this._type.name}`;\n    }\n    valueToString(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.valueToString(x);\n    }\n}\nRecClass._counter = 0;\nfunction decodePrincipalId(b) {\n    const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b);\n    if (x !== 1) {\n        throw new Error('Cannot decode principal');\n    }\n    const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n    return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, len)));\n}\n/**\n * Represents an IDL principal reference\n */\nclass PrincipalClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitPrincipal(this, d);\n    }\n    covariant(x) {\n        if (x && x._isPrincipal)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-24 /* IDLTypeIds.Principal */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return decodePrincipalId(b);\n    }\n    get name() {\n        return 'principal';\n    }\n    valueToString(x) {\n        return `${this.name} \"${x.toText()}\"`;\n    }\n}\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nclass FuncClass extends ConstructType {\n    constructor(argTypes, retTypes, annotations = []) {\n        super();\n        this.argTypes = argTypes;\n        this.retTypes = retTypes;\n        this.annotations = annotations;\n    }\n    static argsToString(types, v) {\n        if (types.length !== v.length) {\n            throw new Error('arity mismatch');\n        }\n        return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n    }\n    accept(v, d) {\n        return v.visitFunc(this, d);\n    }\n    covariant(x) {\n        if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue([principal, methodName]) {\n        const buf = principal.toUint8Array();\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);\n        const canister = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n        const method = new TextEncoder().encode(methodName);\n        const methodLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(method.byteLength);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), canister, methodLen, method);\n    }\n    _buildTypeTableImpl(T) {\n        this.argTypes.forEach(arg => arg.buildTypeTable(T));\n        this.retTypes.forEach(arg => arg.buildTypeTable(T));\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-22 /* IDLTypeIds.Func */);\n        const argLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.argTypes.length);\n        const args = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.argTypes.map(arg => arg.encodeType(T)));\n        const retLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.retTypes.length);\n        const rets = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.retTypes.map(arg => arg.encodeType(T)));\n        const annLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.annotations.length);\n        const anns = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.annotations.map(a => this.encodeAnnotation(a)));\n        T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, argLen, args, retLen, rets, annLen, anns));\n    }\n    decodeValue(b) {\n        const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b);\n        if (x !== 1) {\n            throw new Error('Cannot decode function reference');\n        }\n        const canister = decodePrincipalId(b);\n        const mLen = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n        const buf = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, mLen);\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        const method = decoder.decode(buf);\n        return [canister, method];\n    }\n    get name() {\n        const args = this.argTypes.map(arg => arg.name).join(', ');\n        const rets = this.retTypes.map(arg => arg.name).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args}) -> (${rets})${annon}`;\n    }\n    valueToString([principal, str]) {\n        return `func \"${principal.toText()}\".${str}`;\n    }\n    display() {\n        const args = this.argTypes.map(arg => arg.display()).join(', ');\n        const rets = this.retTypes.map(arg => arg.display()).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args}) → (${rets})${annon}`;\n    }\n    encodeAnnotation(ann) {\n        if (ann === 'query') {\n            return new Uint8Array([1]);\n        }\n        else if (ann === 'oneway') {\n            return new Uint8Array([2]);\n        }\n        else if (ann === 'composite_query') {\n            return new Uint8Array([3]);\n        }\n        else {\n            throw new Error('Illegal function annotation');\n        }\n    }\n}\nclass ServiceClass extends ConstructType {\n    constructor(fields) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => {\n            if (a[0] < b[0]) {\n                return -1;\n            }\n            if (a[0] > b[0]) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    accept(v, d) {\n        return v.visitService(this, d);\n    }\n    covariant(x) {\n        if (x && x._isPrincipal)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.length);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-23 /* IDLTypeIds.Service */);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);\n        const meths = this._fields.map(([label, func]) => {\n            const labelBuf = new TextEncoder().encode(label);\n            const labelLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(labelBuf.length);\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(labelLen, labelBuf, func.encodeType(T));\n        });\n        T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, ...meths));\n    }\n    decodeValue(b) {\n        return decodePrincipalId(b);\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `service {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        return `service \"${x.toText()}\"`;\n    }\n}\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x) {\n    const str = JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);\n    return str && str.length > toReadableString_max\n        ? str.substring(0, toReadableString_max - 3) + '...'\n        : str;\n}\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {ArrayBuffer} serialised value\n */\nfunction encode(argTypes, args) {\n    if (args.length < argTypes.length) {\n        throw Error('Wrong number of message arguments');\n    }\n    const typeTable = new TypeTable();\n    argTypes.forEach(t => t.buildTypeTable(typeTable));\n    const magic = new TextEncoder().encode(magicNumber);\n    const table = typeTable.encode();\n    const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(args.length);\n    const typs = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...argTypes.map(t => t.encodeType(typeTable)));\n    const vals = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...zipWith(argTypes, args, (t, x) => {\n        try {\n            t.covariant(x);\n        }\n        catch (e) {\n            const err = new Error(e.message + '\\n\\n');\n            throw err;\n        }\n        return t.encodeValue(x);\n    }));\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(magic, table, len, typs, vals);\n}\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nfunction decode(retTypes, bytes) {\n    const b = new _utils_buffer__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(bytes);\n    if (bytes.byteLength < magicNumber.length) {\n        throw new Error('Message length smaller than magic number');\n    }\n    const magicBuffer = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, magicNumber.length);\n    const magic = new TextDecoder().decode(magicBuffer);\n    if (magic !== magicNumber) {\n        throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n    }\n    function readTypeTable(pipe) {\n        const typeTable = [];\n        const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n        for (let i = 0; i < len; i++) {\n            const ty = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));\n            switch (ty) {\n                case -18 /* IDLTypeIds.Opt */:\n                case -19 /* IDLTypeIds.Vector */: {\n                    const t = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));\n                    typeTable.push([ty, t]);\n                    break;\n                }\n                case -20 /* IDLTypeIds.Record */:\n                case -21 /* IDLTypeIds.Variant */: {\n                    const fields = [];\n                    let objectLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    let prevHash;\n                    while (objectLength--) {\n                        const hash = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                        if (hash >= Math.pow(2, 32)) {\n                            throw new Error('field id out of 32-bit range');\n                        }\n                        if (typeof prevHash === 'number' && prevHash >= hash) {\n                            throw new Error('field id collision or not sorted');\n                        }\n                        prevHash = hash;\n                        const t = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));\n                        fields.push([hash, t]);\n                    }\n                    typeTable.push([ty, fields]);\n                    break;\n                }\n                case -22 /* IDLTypeIds.Func */: {\n                    const args = [];\n                    let argLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    while (argLength--) {\n                        args.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));\n                    }\n                    const returnValues = [];\n                    let returnValuesLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    while (returnValuesLength--) {\n                        returnValues.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));\n                    }\n                    const annotations = [];\n                    let annotationLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    while (annotationLength--) {\n                        const annotation = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                        switch (annotation) {\n                            case 1: {\n                                annotations.push('query');\n                                break;\n                            }\n                            case 2: {\n                                annotations.push('oneway');\n                                break;\n                            }\n                            case 3: {\n                                annotations.push('composite_query');\n                                break;\n                            }\n                            default:\n                                throw new Error('unknown annotation');\n                        }\n                    }\n                    typeTable.push([ty, [args, returnValues, annotations]]);\n                    break;\n                }\n                case -23 /* IDLTypeIds.Service */: {\n                    let servLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    const methods = [];\n                    while (servLength--) {\n                        const nameLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                        const funcName = new TextDecoder().decode((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(pipe, nameLength));\n                        const funcType = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe);\n                        methods.push([funcName, funcType]);\n                    }\n                    typeTable.push([ty, methods]);\n                    break;\n                }\n                default:\n                    throw new Error('Illegal op_code: ' + ty);\n            }\n        }\n        const rawList = [];\n        const length = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n        for (let i = 0; i < length; i++) {\n            rawList.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));\n        }\n        return [typeTable, rawList];\n    }\n    const [rawTable, rawTypes] = readTypeTable(b);\n    if (rawTypes.length < retTypes.length) {\n        throw new Error('Wrong number of return values');\n    }\n    const table = rawTable.map(_ => Rec());\n    function getType(t) {\n        if (t < -24) {\n            throw new Error('future value not supported');\n        }\n        if (t < 0) {\n            switch (t) {\n                case -1:\n                    return Null;\n                case -2:\n                    return Bool;\n                case -3:\n                    return Nat;\n                case -4:\n                    return Int;\n                case -5:\n                    return Nat8;\n                case -6:\n                    return Nat16;\n                case -7:\n                    return Nat32;\n                case -8:\n                    return Nat64;\n                case -9:\n                    return Int8;\n                case -10:\n                    return Int16;\n                case -11:\n                    return Int32;\n                case -12:\n                    return Int64;\n                case -13:\n                    return Float32;\n                case -14:\n                    return Float64;\n                case -15:\n                    return Text;\n                case -16:\n                    return Reserved;\n                case -17:\n                    return Empty;\n                case -24:\n                    return Principal;\n                default:\n                    throw new Error('Illegal op_code: ' + t);\n            }\n        }\n        if (t >= rawTable.length) {\n            throw new Error('type index out of range');\n        }\n        return table[t];\n    }\n    function buildType(entry) {\n        switch (entry[0]) {\n            case -19 /* IDLTypeIds.Vector */: {\n                const ty = getType(entry[1]);\n                return Vec(ty);\n            }\n            case -18 /* IDLTypeIds.Opt */: {\n                const ty = getType(entry[1]);\n                return Opt(ty);\n            }\n            case -20 /* IDLTypeIds.Record */: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                const record = Record(fields);\n                const tuple = record.tryAsTuple();\n                if (Array.isArray(tuple)) {\n                    return Tuple(...tuple);\n                }\n                else {\n                    return record;\n                }\n            }\n            case -21 /* IDLTypeIds.Variant */: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                return Variant(fields);\n            }\n            case -22 /* IDLTypeIds.Func */: {\n                const [args, returnValues, annotations] = entry[1];\n                return Func(args.map((t) => getType(t)), returnValues.map((t) => getType(t)), annotations);\n            }\n            case -23 /* IDLTypeIds.Service */: {\n                const rec = {};\n                const methods = entry[1];\n                for (const [name, typeRef] of methods) {\n                    let type = getType(typeRef);\n                    if (type instanceof RecClass) {\n                        // unpack reference type\n                        type = type.getType();\n                    }\n                    if (!(type instanceof FuncClass)) {\n                        throw new Error('Illegal service definition: services can only contain functions');\n                    }\n                    rec[name] = type;\n                }\n                return Service(rec);\n            }\n            default:\n                throw new Error('Illegal op_code: ' + entry[0]);\n        }\n    }\n    rawTable.forEach((entry, i) => {\n        // Process function type first, so that we can construct the correct service type\n        if (entry[0] === -22 /* IDLTypeIds.Func */) {\n            const t = buildType(entry);\n            table[i].fill(t);\n        }\n    });\n    rawTable.forEach((entry, i) => {\n        if (entry[0] !== -22 /* IDLTypeIds.Func */) {\n            const t = buildType(entry);\n            table[i].fill(t);\n        }\n    });\n    const types = rawTypes.map(t => getType(t));\n    const output = retTypes.map((t, i) => {\n        return t.decodeValue(b, types[i]);\n    });\n    // skip unused values\n    for (let ind = retTypes.length; ind < types.length; ind++) {\n        types[ind].decodeValue(b, types[ind]);\n    }\n    if (b.byteLength > 0) {\n        throw new Error('decode: Left-over bytes');\n    }\n    return output;\n}\n// Export Types instances.\nconst Empty = new EmptyClass();\nconst Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nconst Unknown = new UnknownClass();\nconst Bool = new BoolClass();\nconst Null = new NullClass();\nconst Text = new TextClass();\nconst Int = new IntClass();\nconst Nat = new NatClass();\nconst Float32 = new FloatClass(32);\nconst Float64 = new FloatClass(64);\nconst Int8 = new FixedIntClass(8);\nconst Int16 = new FixedIntClass(16);\nconst Int32 = new FixedIntClass(32);\nconst Int64 = new FixedIntClass(64);\nconst Nat8 = new FixedNatClass(8);\nconst Nat16 = new FixedNatClass(16);\nconst Nat32 = new FixedNatClass(32);\nconst Nat64 = new FixedNatClass(64);\nconst Principal = new PrincipalClass();\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nfunction Tuple(...types) {\n    return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nfunction Vec(t) {\n    return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nfunction Opt(t) {\n    return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nfunction Record(t) {\n    return new RecordClass(t);\n}\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nfunction Variant(fields) {\n    return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nfunction Rec() {\n    return new RecClass();\n}\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nfunction Func(args, ret, annotations = []) {\n    return new FuncClass(args, ret, annotations);\n}\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nfunction Service(t) {\n    return new ServiceClass(t);\n}\n//# sourceMappingURL=idl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vaWRsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQzhEO0FBQ0c7QUFDckI7QUFDNEc7QUFDNUc7QUFDNUM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBUztBQUM3QixvQkFBb0IscURBQU07QUFDMUIsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBVTtBQUN6QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLCtEQUErRCxPQUFPLGdCQUFnQixVQUFVO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxPQUFPLGdCQUFnQixVQUFVO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCLFlBQVksb0JBQW9CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQixZQUFZLG9CQUFvQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQVM7QUFDN0IsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSx5REFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQVM7QUFDN0Isb0JBQW9CLHVEQUFRO0FBQzVCLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBLGVBQWUseURBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUseURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQixZQUFZLG9CQUFvQjtBQUNuRjtBQUNBO0FBQ0EsZUFBZSx3REFBUztBQUN4QjtBQUNBO0FBQ0EsZUFBZSx5REFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQixZQUFZLG9CQUFvQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdURBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFLO0FBQ3pCLG9CQUFvQix5REFBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBLGVBQWUseURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCLFlBQVksb0JBQW9CO0FBQ25GO0FBQ0E7QUFDQSxlQUFlLDBEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCLHNCQUFzQixLQUFLLEtBQUssVUFBVTtBQUM3RztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG1DQUFtQyxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBLG9CQUFvQix3REFBUztBQUM3QjtBQUNBLG1CQUFtQixxREFBTTtBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFNO0FBQ3pCO0FBQ0Esd0JBQXdCLDBEQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBVTtBQUNqQztBQUNBLDRCQUE0QixxREFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUIsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCLFlBQVkscUJBQXFCLFNBQVMsVUFBVTtBQUMzRztBQUNBLG1DQUFtQyxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFVO0FBQ2pDO0FBQ0EsNEJBQTRCLHFEQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQkFBK0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNPO0FBQ1AsMkJBQTJCO0FBQzNCO0FBQ0EsNkRBQTZELHlEQUFZLFNBQVMseURBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBLDRCQUE0QixFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQixzQkFBc0IsR0FBRyxLQUFLLFVBQVU7QUFDdkc7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQ0FBbUMsZ0JBQWdCLFlBQVksb0JBQW9CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQVU7QUFDakMsb0JBQW9CLHdEQUFTO0FBQzdCLDBEQUEwRCxxREFBTSxDQUFDLHdEQUFTLENBQUMseURBQVk7QUFDdkYsb0JBQW9CLHFEQUFNLGNBQWMscURBQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlEQUFZO0FBQzNDLDZCQUE2Qix5REFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxlQUFlLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsZUFBZSxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsZUFBZSxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLHNCQUFzQixHQUFHLEtBQUssVUFBVTtBQUN2RztBQUNBLGFBQWE7QUFDYjtBQUNBLG1DQUFtQyxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsZUFBZSxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFLGVBQWUsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNPO0FBQ1AsMkJBQTJCO0FBQzNCO0FBQ0EsNkRBQTZELHlEQUFZLFNBQVMseURBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCLHdCQUF3QixHQUFHLEtBQUssVUFBVTtBQUN6RztBQUNBLGFBQWE7QUFDYjtBQUNBLG1DQUFtQyxnQkFBZ0IsWUFBWSxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdEQUFTO0FBQ3JDO0FBQ0EsdUJBQXVCLHFEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVCQUF1Qix5REFBVTtBQUNqQyxvQkFBb0Isd0RBQVM7QUFDN0IsMERBQTBELHFEQUFNLENBQUMsd0RBQVMsQ0FBQyx5REFBWTtBQUN2Riw0QkFBNEIscURBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVksZUFBZSx5REFBWTtBQUN2RDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRSxlQUFlLElBQUk7QUFDOUM7QUFDQTtBQUNBLGdHQUFnRyxlQUFlO0FBQy9HLHlCQUF5QixFQUFFLGVBQWUsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxFQUFFLE1BQU07QUFDN0M7QUFDQTtBQUNBLHFDQUFxQyxFQUFFLEtBQUssR0FBRyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQixZQUFZLG9CQUFvQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVSxHQUFHLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNERBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFTO0FBQ2hDLFdBQVcseURBQVcsK0JBQStCLHVEQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCLFlBQVksb0JBQW9CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBUztBQUM3QixlQUFlLHFEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLHlEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXLEdBQUcsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCLFlBQVksb0JBQW9CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBUztBQUM3Qix5QkFBeUIscURBQU07QUFDL0I7QUFDQSwwQkFBMEIsd0RBQVM7QUFDbkMsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBVTtBQUNqQyx1QkFBdUIsd0RBQVM7QUFDaEMscUJBQXFCLHFEQUFNO0FBQzNCLHVCQUF1Qix3REFBUztBQUNoQyxxQkFBcUIscURBQU07QUFDM0IsdUJBQXVCLHdEQUFTO0FBQ2hDLHFCQUFxQixxREFBTTtBQUMzQixvQkFBb0IscURBQU07QUFDMUI7QUFDQTtBQUNBLGtCQUFrQiw0REFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3REFBUztBQUNyQyxvQkFBb0IsdURBQVE7QUFDNUIsa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSyxRQUFRLEtBQUssR0FBRyxNQUFNO0FBQzlDO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CLElBQUksSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUssT0FBTyxLQUFLLEdBQUcsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCLFlBQVksb0JBQW9CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBUztBQUM3QixlQUFlLHFEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBVTtBQUNqQyxvQkFBb0Isd0RBQVM7QUFDN0I7QUFDQTtBQUNBLDZCQUE2Qix3REFBUztBQUN0QyxtQkFBbUIscURBQU07QUFDekIsU0FBUztBQUNULG9CQUFvQixxREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRSxlQUFlLElBQUk7QUFDOUM7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLHlGQUF5RixNQUFNO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFTO0FBQ3pCLGlCQUFpQixxREFBTTtBQUN2QixpQkFBaUIscURBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLHFEQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQkFBa0IsMERBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBUztBQUNwQyx3QkFBd0IsU0FBUztBQUNqQyw4QkFBOEIseURBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlEQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3REFBUztBQUN2RDtBQUNBO0FBQ0EsNENBQTRDLHdEQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlEQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdEQUFTO0FBQ3BEO0FBQ0EseUNBQXlDLHlEQUFVO0FBQ25EO0FBQ0E7QUFDQSxvREFBb0Qsd0RBQVM7QUFDN0Q7QUFDQSxpREFBaUQseURBQVU7QUFDM0Q7QUFDQTtBQUNBLGtEQUFrRCx3REFBUztBQUMzRDtBQUNBLGtEQUFrRCx3REFBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0RBQVM7QUFDckQ7QUFDQTtBQUNBLGtEQUFrRCx3REFBUztBQUMzRCxrRUFBa0UsdURBQVE7QUFDMUUseUNBQXlDLHlEQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdEQUFTO0FBQ3ZDLHdCQUF3QixZQUFZO0FBQ3BDLGdDQUFnQyx5REFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eStjYW5kaWRAMi4xLjNfQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS9pZGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5pbXBvcnQgeyBQcmluY2lwYWwgYXMgUHJpbmNpcGFsSWQgfSBmcm9tICdAZGZpbml0eS9wcmluY2lwYWwnO1xuaW1wb3J0IHsgY29uY2F0LCBQaXBlQXJyYXlCdWZmZXIgYXMgUGlwZSB9IGZyb20gJy4vdXRpbHMvYnVmZmVyJztcbmltcG9ydCB7IGlkbExhYmVsVG9JZCB9IGZyb20gJy4vdXRpbHMvaGFzaCc7XG5pbXBvcnQgeyBsZWJEZWNvZGUsIGxlYkVuY29kZSwgcmVhZEludExFLCByZWFkVUludExFLCBzYWZlUmVhZCwgc2FmZVJlYWRVaW50OCwgc2xlYkRlY29kZSwgc2xlYkVuY29kZSwgd3JpdGVJbnRMRSwgd3JpdGVVSW50TEUsIH0gZnJvbSAnLi91dGlscy9sZWIxMjgnO1xuaW1wb3J0IHsgaWV4cDIgfSBmcm9tICcuL3V0aWxzL2JpZ2ludC1tYXRoJztcbmNvbnN0IG1hZ2ljTnVtYmVyID0gJ0RJREwnO1xuY29uc3QgdG9SZWFkYWJsZVN0cmluZ19tYXggPSA0MDA7IC8vIHdpbGwgbm90IGRpc3BsYXkgYXJndW1lbnRzIGFmdGVyIDQwMGNoYXJzLiBNYWtlcyBzdXJlIDJtYiBibG9icyBkb24ndCBnZXQgaW5zaWRlIHRoZSBlcnJvclxuZnVuY3Rpb24gemlwV2l0aCh4cywgeXMsIGYpIHtcbiAgICByZXR1cm4geHMubWFwKCh4LCBpKSA9PiBmKHgsIHlzW2ldKSk7XG59XG4vKipcbiAqIEFuIElETCBUeXBlIFRhYmxlLCB3aGljaCBwcmVjZWRlcyB0aGUgZGF0YSBpbiB0aGUgc3RyZWFtLlxuICovXG5jbGFzcyBUeXBlVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBMaXN0IG9mIHR5cGVzLiBOZWVkcyB0byBiZSBhbiBhcnJheSBhcyB0aGUgaW5kZXggbmVlZHMgdG8gYmUgc3RhYmxlLlxuICAgICAgICB0aGlzLl90eXBzID0gW107XG4gICAgICAgIHRoaXMuX2lkeCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgaGFzKG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5faWR4LmhhcyhvYmoubmFtZSk7XG4gICAgfVxuICAgIGFkZCh0eXBlLCBidWYpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fdHlwcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2lkeC5zZXQodHlwZS5uYW1lLCBpZHgpO1xuICAgICAgICB0aGlzLl90eXBzLnB1c2goYnVmKTtcbiAgICB9XG4gICAgbWVyZ2Uob2JqLCBrbm90KSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX2lkeC5nZXQob2JqLm5hbWUpO1xuICAgICAgICBjb25zdCBrbm90SWR4ID0gdGhpcy5faWR4LmdldChrbm90KTtcbiAgICAgICAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHlwZSBpbmRleCBmb3IgJyArIG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtub3RJZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHR5cGUgaW5kZXggZm9yICcgKyBrbm90KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90eXBzW2lkeF0gPSB0aGlzLl90eXBzW2tub3RJZHhdO1xuICAgICAgICAvLyBEZWxldGUgdGhlIHR5cGUuXG4gICAgICAgIHRoaXMuX3R5cHMuc3BsaWNlKGtub3RJZHgsIDEpO1xuICAgICAgICB0aGlzLl9pZHguZGVsZXRlKGtub3QpO1xuICAgIH1cbiAgICBlbmNvZGUoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZSh0aGlzLl90eXBzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdCguLi50aGlzLl90eXBzKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChsZW4sIGJ1Zik7XG4gICAgfVxuICAgIGluZGV4T2YodHlwZU5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pZHguaGFzKHR5cGVOYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHR5cGUgaW5kZXggZm9yICcgKyB0eXBlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUodGhpcy5faWR4LmdldCh0eXBlTmFtZSkgfHwgMCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFZpc2l0b3Ige1xuICAgIHZpc2l0VHlwZSh0LCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIHZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRUeXBlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEVtcHR5KHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRQcmltaXRpdmUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0Qm9vbCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdE51bGwodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFByaW1pdGl2ZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRSZXNlcnZlZCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFRleHQodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFByaW1pdGl2ZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXROdW1iZXIodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFByaW1pdGl2ZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRJbnQodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE51bWJlcih0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXROYXQodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE51bWJlcih0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRGbG9hdCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEZpeGVkSW50KHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXROdW1iZXIodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0Rml4ZWROYXQodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE51bWJlcih0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRQcmluY2lwYWwodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFByaW1pdGl2ZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRDb25zdHJ1Y3QodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFR5cGUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0VmVjKHQsIHR5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q29uc3RydWN0KHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdE9wdCh0LCB0eSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENvbnN0cnVjdCh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRSZWNvcmQodCwgZmllbGRzLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q29uc3RydWN0KHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFR1cGxlKHQsIGNvbXBvbmVudHMsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gY29tcG9uZW50cy5tYXAoKHR5LCBpKSA9PiBbYF8ke2l9X2AsIHR5XSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UmVjb3JkKHQsIGZpZWxkcywgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0VmFyaWFudCh0LCBmaWVsZHMsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0UmVjKHQsIHR5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q29uc3RydWN0KHR5LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRGdW5jKHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0U2VydmljZSh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q29uc3RydWN0KHQsIGRhdGEpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGUge1xuICAgIC8qIERpc3BsYXkgdHlwZSBuYW1lICovXG4gICAgZGlzcGxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiB0b1JlYWRhYmxlU3RyaW5nKHgpO1xuICAgIH1cbiAgICAvKiBJbXBsZW1lbnQgYFRgIGluIHRoZSBJREwgc3BlYywgb25seSBuZWVkZWQgZm9yIG5vbi1wcmltaXRpdmUgdHlwZXMgKi9cbiAgICBidWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpIHtcbiAgICAgICAgaWYgKCF0eXBlVGFibGUuaGFzKHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLl9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQcmltaXRpdmVUeXBlIGV4dGVuZHMgVHlwZSB7XG4gICAgY2hlY2tUeXBlKHQpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZSAhPT0gdC5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IHR5cGUgb24gdGhlIHdpcmUgJHt0Lm5hbWV9LCBleHBlY3QgdHlwZSAke3RoaXMubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKSB7XG4gICAgICAgIC8vIE5vIHR5cGUgdGFibGUgZW5jb2RpbmcgZm9yIFByaW1pdGl2ZSB0eXBlcy5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3RUeXBlIGV4dGVuZHMgVHlwZSB7XG4gICAgY2hlY2tUeXBlKHQpIHtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBSZWNDbGFzcykge1xuICAgICAgICAgICAgY29uc3QgdHkgPSB0LmdldFR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIG1pc21hdGNoIHdpdGggdW5pbml0aWFsaXplZCB0eXBlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eXBlIG1pc21hdGNoOiB0eXBlIG9uIHRoZSB3aXJlICR7dC5uYW1lfSwgZXhwZWN0IHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUodHlwZVRhYmxlKSB7XG4gICAgICAgIHJldHVybiB0eXBlVGFibGUuaW5kZXhPZih0aGlzLm5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgRW1wdHksIGEgdHlwZSB3aGljaCBoYXMgbm8gaW5oYWJpdGFudHMuXG4gKiBTaW5jZSBubyB2YWx1ZXMgZXhpc3QgZm9yIHRoaXMgdHlwZSwgaXQgY2Fubm90IGJlIHNlcmlhbGlzZWQgb3IgZGVzZXJpYWxpc2VkLlxuICogUmVzdWx0IHR5cGVzIGxpa2UgYFJlc3VsdDxUZXh0LCBFbXB0eT5gIHNob3VsZCBhbHdheXMgc3VjY2VlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVtcHR5Q2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdEVtcHR5KHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgY2Fubm90IGFwcGVhciBhcyBhIGZ1bmN0aW9uIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgY2Fubm90IGFwcGVhciBhcyBhIHZhbHVlJyk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKC0xNyAvKiBJRExUeXBlSWRzLkVtcHR5ICovKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW1wdHkgY2Fubm90IGFwcGVhciBhcyBhbiBvdXRwdXQnKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnZW1wdHknO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgVW5rbm93biwgYSBwbGFjZWhvbGRlciB0eXBlIGZvciBkZXNlcmlhbGl6YXRpb24gb25seS5cbiAqIFdoZW4gZGVjb2RpbmcgYSB2YWx1ZSBhcyBVbmtub3duLCBhbGwgZmllbGRzIHdpbGwgYmUgcmV0YWluZWQgYnV0IHRoZSBuYW1lcyBhcmUgb25seSBhdmFpbGFibGUgaW5cbiAqIGhhc2hlZCBmb3JtLlxuICogQSBkZXNlcmlhbGl6ZWQgdW5rbm93biB3aWxsIG9mZmVyIGl0J3MgYWN0dWFsIHR5cGUgYnkgY2FsbGluZyB0aGUgYHR5cGUoKWAgZnVuY3Rpb24uXG4gKiBVbmtub3duIGNhbm5vdCBiZSBzZXJpYWxpemVkIGFuZCBhdHRlbXB0aW5nIHRvIGRvIHNvIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBVbmtub3duQ2xhc3MgZXh0ZW5kcyBUeXBlIHtcbiAgICBjaGVja1R5cGUodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQgZm9yIHVua25vd24uJyk7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHRocm93IHYudmlzaXRUeXBlKHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjYW5ub3QgYXBwZWFyIGFzIGEgZnVuY3Rpb24gYXJndW1lbnQnKTtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbm5vdCBhcHBlYXIgYXMgYSB2YWx1ZScpO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2Fubm90IGJlIHNlcmlhbGl6ZWQnKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICBsZXQgZGVjb2RlZFZhbHVlID0gdC5kZWNvZGVWYWx1ZShiLCB0KTtcbiAgICAgICAgaWYgKE9iamVjdChkZWNvZGVkVmFsdWUpICE9PSBkZWNvZGVkVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGRlY29kZWRWYWx1ZSBpcyBwcmltaXRpdmUuIEJveCBpdCwgb3RoZXJ3aXNlIHdlIGNhbm5vdCBhZGQgdGhlIHR5cGUoKSBmdW5jdGlvbi5cbiAgICAgICAgICAgIC8vIFRoZSB0eXBlKCkgZnVuY3Rpb24gaXMgaW1wb3J0YW50IGZvciBwcmltaXRpdmVzIGJlY2F1c2Ugb3RoZXJ3aXNlIHdlIGNhbm5vdCB0ZWxsIGFwYXJ0IHRoZVxuICAgICAgICAgICAgLy8gZGlmZmVyZW50IG51bWJlciB0eXBlcy5cbiAgICAgICAgICAgIGRlY29kZWRWYWx1ZSA9IE9iamVjdChkZWNvZGVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlRnVuYztcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBSZWNDbGFzcykge1xuICAgICAgICAgICAgdHlwZUZ1bmMgPSAoKSA9PiB0LmdldFR5cGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVGdW5jID0gKCkgPT4gdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgdXNlICdkZWNvZGVkVmFsdWUudHlwZSA9IHR5cGVGdW5jJyBiZWNhdXNlIHRoaXMgd291bGQgbGVhZCB0byBhbiBlbnVtZXJhYmxlIHByb3BlcnR5XG4gICAgICAgIC8vICd0eXBlJyB3aGljaCBtZWFucyBpdCB3b3VsZCBiZSBzZXJpYWxpemVkIGlmIHRoZSB2YWx1ZSB3b3VsZCBiZSBjYW5kaWQgZW5jb2RlZCBhZ2Fpbi5cbiAgICAgICAgLy8gVGhpcyBpbiB0dXJuIGxlYWRzIHRvIHByb2JsZW1zIGlmIHRoZSBkZWNvZGVkIHZhbHVlIGlzIGEgdmFyaWFudCBiZWNhdXNlIHRoZXNlIHZhbHVlcyBhcmVcbiAgICAgICAgLy8gb25seSBhbGxvd2VkIHRvIGhhdmUgYSBzaW5nbGUgcHJvcGVydHkuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWNvZGVkVmFsdWUsICd0eXBlJywge1xuICAgICAgICAgICAgdmFsdWU6IHR5cGVGdW5jLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWNvZGVkVmFsdWU7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjYW5ub3QgYmUgc2VyaWFsaXplZCcpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIEJvb2xcbiAqL1xuZXhwb3J0IGNsYXNzIEJvb2xDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0Qm9vbCh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYm9vbGVhbicpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFt4ID8gMSA6IDBdKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTIgLyogSURMVHlwZUlkcy5Cb29sICovKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgc3dpdGNoIChzYWZlUmVhZFVpbnQ4KGIpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb2xlYW4gdmFsdWUgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnYm9vbCc7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBOdWxsXG4gKi9cbmV4cG9ydCBjbGFzcyBOdWxsQ2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdE51bGwodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh4ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTEgLyogSURMVHlwZUlkcy5OdWxsICovKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgUmVzZXJ2ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIFJlc2VydmVkQ2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdFJlc2VydmVkKHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKC0xNiAvKiBJRExUeXBlSWRzLlJlc2VydmVkICovKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICBpZiAodC5uYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIHQuZGVjb2RlVmFsdWUoYiwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3Jlc2VydmVkJztcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIFRleHRcbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0VGV4dCh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCBidWYgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoeCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb25jYXQobGVuLCBidWYpO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSgtMTUgLyogSURMVHlwZUlkcy5UZXh0ICovKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRGVjb2RlKGIpO1xuICAgICAgICBjb25zdCBidWYgPSBzYWZlUmVhZChiLCBOdW1iZXIobGVuKSk7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGZhdGFsOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAndGV4dCc7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4gJ1wiJyArIHggKyAnXCInO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgSW50XG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0SW50KHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICAvLyBXZSBhbGxvdyBlbmNvZGluZyBvZiBKYXZhU2NyaXB0IHBsYWluIG51bWJlcnMuXG4gICAgICAgIC8vIEJ1dCB3ZSB3aWxsIGFsd2F5cyBkZWNvZGUgdG8gYmlnaW50LlxuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIoeCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoeCk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKC00IC8qIElETFR5cGVJZHMuSW50ICovKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgcmV0dXJuIHNsZWJEZWNvZGUoYik7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgTmF0XG4gKi9cbmV4cG9ydCBjbGFzcyBOYXRDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0TmF0KHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICAvLyBXZSBhbGxvdyBlbmNvZGluZyBvZiBKYXZhU2NyaXB0IHBsYWluIG51bWJlcnMuXG4gICAgICAgIC8vIEJ1dCB3ZSB3aWxsIGFsd2F5cyBkZWNvZGUgdG8gYmlnaW50LlxuICAgICAgICBpZiAoKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB4ID49IEJpZ0ludCgwKSkgfHwgKE51bWJlci5pc0ludGVnZXIoeCkgJiYgeCA+PSAwKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICByZXR1cm4gbGViRW5jb2RlKHgpO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSgtMyAvKiBJRExUeXBlSWRzLk5hdCAqLyk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIHJldHVybiBsZWJEZWNvZGUoYik7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ25hdCc7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgRmxvYXRcbiAqL1xuZXhwb3J0IGNsYXNzIEZsb2F0Q2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihfYml0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9iaXRzID0gX2JpdHM7XG4gICAgICAgIGlmIChfYml0cyAhPT0gMzIgJiYgX2JpdHMgIT09IDY0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIHZhbGlkIGZsb2F0IHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdEZsb2F0KHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInIHx8IHggaW5zdGFuY2VvZiBOdW1iZXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuX2JpdHMgLyA4KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWYpO1xuICAgICAgICBpZiAodGhpcy5fYml0cyA9PT0gMzIpIHtcbiAgICAgICAgICAgIHZpZXcuc2V0RmxvYXQzMigwLCB4LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXcuc2V0RmxvYXQ2NCgwLCB4LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICBjb25zdCBvcGNvZGUgPSB0aGlzLl9iaXRzID09PSAzMiA/IC0xMyAvKiBJRExUeXBlSWRzLkZsb2F0MzIgKi8gOiAtMTQgLyogSURMVHlwZUlkcy5GbG9hdDY0ICovO1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZShvcGNvZGUpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBjb25zdCBieXRlcyA9IHNhZmVSZWFkKGIsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhieXRlcyk7XG4gICAgICAgIGlmICh0aGlzLl9iaXRzID09PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQzMigwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LmdldEZsb2F0NjQoMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnZmxvYXQnICsgdGhpcy5fYml0cztcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBmaXhlZC13aWR0aCBJbnQobilcbiAqL1xuZXhwb3J0IGNsYXNzIEZpeGVkSW50Q2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihfYml0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9iaXRzID0gX2JpdHM7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0Rml4ZWRJbnQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IGlleHAyKHRoaXMuX2JpdHMgLSAxKSAqIEJpZ0ludCgtMSk7XG4gICAgICAgIGNvbnN0IG1heCA9IGlleHAyKHRoaXMuX2JpdHMgLSAxKSAtIEJpZ0ludCgxKTtcbiAgICAgICAgbGV0IG9rID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIG9rID0geCA+PSBtaW4gJiYgeCA8PSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcih4KSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IEJpZ0ludCh4KTtcbiAgICAgICAgICAgIG9rID0gdiA+PSBtaW4gJiYgdiA8PSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICByZXR1cm4gd3JpdGVJbnRMRSh4LCB0aGlzLl9iaXRzIC8gOCk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGgubG9nMih0aGlzLl9iaXRzKSAtIDM7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKC05IC0gb2Zmc2V0KTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgY29uc3QgbnVtID0gcmVhZEludExFKGIsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICAgICAgaWYgKHRoaXMuX2JpdHMgPD0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgaW50JHt0aGlzLl9iaXRzfWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgZml4ZWQtd2lkdGggTmF0KG4pXG4gKi9cbmV4cG9ydCBjbGFzcyBGaXhlZE5hdENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoX2JpdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fYml0cyA9IF9iaXRzO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdEZpeGVkTmF0KHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBjb25zdCBtYXggPSBpZXhwMih0aGlzLl9iaXRzKTtcbiAgICAgICAgbGV0IG9rID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgeCA+PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgIG9rID0geCA8IG1heDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHgpICYmIHggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IEJpZ0ludCh4KTtcbiAgICAgICAgICAgIG9rID0gdiA8IG1heDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIHJldHVybiB3cml0ZVVJbnRMRSh4LCB0aGlzLl9iaXRzIC8gOCk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGgubG9nMih0aGlzLl9iaXRzKSAtIDM7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKC01IC0gb2Zmc2V0KTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgY29uc3QgbnVtID0gcmVhZFVJbnRMRShiLCB0aGlzLl9iaXRzIC8gOCk7XG4gICAgICAgIGlmICh0aGlzLl9iaXRzIDw9IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gYG5hdCR7dGhpcy5fYml0c31gO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIEFycmF5XG4gKlxuICogQXJyYXlzIG9mIGZpeGVkLXNpemVkIG5hdC9pbnQgdHlwZSAoZS5nLiBuYXQ4KSwgYXJlIGVuY29kZWQgZnJvbSBhbmQgZGVjb2RlZCB0byBUeXBlZEFycmF5cyAoZS5nLiBVaW50OEFycmF5KS5cbiAqIEFycmF5cyBvZiBmbG9hdCBvciBvdGhlciBub24tcHJpbWl0aXZlIHR5cGVzIGFyZSBlbmNvZGVkL2RlY29kZWQgYXMgdW50eXBlZCBhcnJheSBpbiBKYXZhc2NyaXB0LlxuICogQHBhcmFtIHtUeXBlfSB0XG4gKi9cbmV4cG9ydCBjbGFzcyBWZWNDbGFzcyBleHRlbmRzIENvbnN0cnVjdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKF90eXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBfdHlwZTtcbiAgICAgICAgLy8gSWYgdHJ1ZSwgdGhpcyB2ZWN0b3IgaXMgcmVhbGx5IGEgYmxvYiBhbmQgd2UgY2FuIGp1c3QgdXNlIG1lbWNweS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTk9URTpcbiAgICAgICAgLy8gV2l0aCBzdXBwb3J0IG9mIGVuY29kaW5nL2RlbmNvZGluZyBvZiBUeXBlZEFycmF5cywgdGhpcyBvcHRpbWl6YXRpb24gaXNcbiAgICAgICAgLy8gb25seSB1c2VkIHdoZW4gcGxhaW4gYXJyYXkgb2YgYnl0ZXMgYXJlIHBhc3NlZCBhcyBlbmNvZGluZyBpbnB1dCBpbiBvcmRlclxuICAgICAgICAvLyB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlLlxuICAgICAgICB0aGlzLl9ibG9iT3B0aW1pemF0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmIChfdHlwZSBpbnN0YW5jZW9mIEZpeGVkTmF0Q2xhc3MgJiYgX3R5cGUuX2JpdHMgPT09IDgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2JPcHRpbWl6YXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0VmVjKHRoaXMsIHRoaXMuX3R5cGUsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIEFycmF5QnVmZmVyXG4gICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLl90eXBlIGluc3RhbmNlb2YgRml4ZWROYXRDbGFzc1xuICAgICAgICAgICAgPyB0aGlzLl90eXBlLl9iaXRzXG4gICAgICAgICAgICA6IHRoaXMuX3R5cGUgaW5zdGFuY2VvZiBGaXhlZEludENsYXNzXG4gICAgICAgICAgICAgICAgPyB0aGlzLl90eXBlLl9iaXRzXG4gICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICBpZiAoKEFycmF5QnVmZmVyLmlzVmlldyh4KSAmJiBiaXRzID09IHguQllURVNfUEVSX0VMRU1FTlQgKiA4KSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoeCkgJiZcbiAgICAgICAgICAgICAgICB4LmV2ZXJ5KCh2LCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlLmNvdmFyaWFudCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiBcXG5cXG5pbmRleCAke2lkeH0gLT4gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKHgubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMuX2Jsb2JPcHRpbWl6YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQobGVuLCBuZXcgVWludDhBcnJheSh4KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdChsZW4sIG5ldyBVaW50OEFycmF5KHguYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmID0gbmV3IFBpcGUobmV3IEFycmF5QnVmZmVyKGxlbi5ieXRlTGVuZ3RoICsgeC5sZW5ndGgpLCAwKTtcbiAgICAgICAgYnVmLndyaXRlKGxlbik7XG4gICAgICAgIGZvciAoY29uc3QgZCBvZiB4KSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkID0gdGhpcy5fdHlwZS5lbmNvZGVWYWx1ZShkKTtcbiAgICAgICAgICAgIGJ1Zi53cml0ZShuZXcgVWludDhBcnJheShlbmNvZGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUuYnVpbGRUeXBlVGFibGUodHlwZVRhYmxlKTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZSgtMTkgLyogSURMVHlwZUlkcy5WZWN0b3IgKi8pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl90eXBlLmVuY29kZVR5cGUodHlwZVRhYmxlKTtcbiAgICAgICAgdHlwZVRhYmxlLmFkZCh0aGlzLCBjb25jYXQob3BDb2RlLCBidWZmZXIpKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICBjb25zdCB2ZWMgPSB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgaWYgKCEodmVjIGluc3RhbmNlb2YgVmVjQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZlY3RvciB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gTnVtYmVyKGxlYkRlY29kZShiKSk7XG4gICAgICAgIGlmICh0aGlzLl90eXBlIGluc3RhbmNlb2YgRml4ZWROYXRDbGFzcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUuX2JpdHMgPT0gOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiLnJlYWQobGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYi5yZWFkKGxlbiAqIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90eXBlLl9iaXRzID09IDMyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShiLnJlYWQobGVuICogNCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUuX2JpdHMgPT0gNjQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ1VpbnQ2NEFycmF5KGIucmVhZChsZW4gKiA4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgaW5zdGFuY2VvZiBGaXhlZEludENsYXNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoYi5yZWFkKGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUuX2JpdHMgPT0gMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYi5yZWFkKGxlbiAqIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90eXBlLl9iaXRzID09IDMyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGIucmVhZChsZW4gKiA0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSA2NCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50NjRBcnJheShiLnJlYWQobGVuICogOCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmV0cy5wdXNoKHRoaXMuX3R5cGUuZGVjb2RlVmFsdWUoYiwgdmVjLl90eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHM7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gYHZlYyAke3RoaXMuX3R5cGUubmFtZX1gO1xuICAgIH1cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICByZXR1cm4gYHZlYyAke3RoaXMuX3R5cGUuZGlzcGxheSgpfWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHgubWFwKGUgPT4gdGhpcy5fdHlwZS52YWx1ZVRvU3RyaW5nKGUpKTtcbiAgICAgICAgcmV0dXJuICd2ZWMgeycgKyBlbGVtZW50cy5qb2luKCc7ICcpICsgJ30nO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgT3B0aW9uXG4gKiBAcGFyYW0ge1R5cGV9IHRcbiAqL1xuZXhwb3J0IGNsYXNzIE9wdENsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoX3R5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IF90eXBlO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdE9wdCh0aGlzLCB0aGlzLl90eXBlLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpICYmICh4Lmxlbmd0aCA9PT0gMCB8fCAoeC5sZW5ndGggPT09IDEgJiYgdGhpcy5fdHlwZS5jb3ZhcmlhbnQoeFswXSkpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9IFxcblxcbi0+ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0KG5ldyBVaW50OEFycmF5KFsxXSksIHRoaXMuX3R5cGUuZW5jb2RlVmFsdWUoeFswXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUuYnVpbGRUeXBlVGFibGUodHlwZVRhYmxlKTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZSgtMTggLyogSURMVHlwZUlkcy5PcHQgKi8pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl90eXBlLmVuY29kZVR5cGUodHlwZVRhYmxlKTtcbiAgICAgICAgdHlwZVRhYmxlLmFkZCh0aGlzLCBjb25jYXQob3BDb2RlLCBidWZmZXIpKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICBjb25zdCBvcHQgPSB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgaWYgKCEob3B0IGluc3RhbmNlb2YgT3B0Q2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhbiBvcHRpb24gdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc2FmZVJlYWRVaW50OChiKSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMuX3R5cGUuZGVjb2RlVmFsdWUoYiwgb3B0Ll90eXBlKV07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGFuIG9wdGlvbiB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gYG9wdCAke3RoaXMuX3R5cGUubmFtZX1gO1xuICAgIH1cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICByZXR1cm4gYG9wdCAke3RoaXMuX3R5cGUuZGlzcGxheSgpfWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYG9wdCAke3RoaXMuX3R5cGUudmFsdWVUb1N0cmluZyh4WzBdKX1gO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBSZWNvcmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbZmllbGRzXSAtIG1hcHBpbmcgb2YgZnVuY3Rpb24gbmFtZSB0byBUeXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNvcmRDbGFzcyBleHRlbmRzIENvbnN0cnVjdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkcykuc29ydCgoYSwgYikgPT4gaWRsTGFiZWxUb0lkKGFbMF0pIC0gaWRsTGFiZWxUb0lkKGJbMF0pKTtcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRSZWNvcmQodGhpcywgdGhpcy5fZmllbGRzLCBkKTtcbiAgICB9XG4gICAgdHJ5QXNUdXBsZSgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB0eXBlXSA9IHRoaXMuX2ZpZWxkc1tpXTtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IGBfJHtpfV9gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0aGlzLl9maWVsZHMuZXZlcnkoKFtrLCB0XSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGlmICgheC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY29yZCBpcyBtaXNzaW5nIGtleSBcIiR7a31cIi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuY292YXJpYW50KHhba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6IFxcblxcbmZpZWxkICR7a30gLT4gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleV0pID0+IHhba2V5XSk7XG4gICAgICAgIGNvbnN0IGJ1ZnMgPSB6aXBXaXRoKHRoaXMuX2ZpZWxkcywgdmFsdWVzLCAoWywgY10sIGQpID0+IGMuZW5jb2RlVmFsdWUoZCkpO1xuICAgICAgICByZXR1cm4gY29uY2F0KC4uLmJ1ZnMpO1xuICAgIH1cbiAgICBfYnVpbGRUeXBlVGFibGVJbXBsKFQpIHtcbiAgICAgICAgdGhpcy5fZmllbGRzLmZvckVhY2goKFtfLCB2YWx1ZV0pID0+IHZhbHVlLmJ1aWxkVHlwZVRhYmxlKFQpKTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZSgtMjAgLyogSURMVHlwZUlkcy5SZWNvcmQgKi8pO1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUodGhpcy5fZmllbGRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4gY29uY2F0KGxlYkVuY29kZShpZGxMYWJlbFRvSWQoa2V5KSksIHZhbHVlLmVuY29kZVR5cGUoVCkpKTtcbiAgICAgICAgVC5hZGQodGhpcywgY29uY2F0KG9wQ29kZSwgbGVuLCBjb25jYXQoLi4uZmllbGRzKSkpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBpZiAoIShyZWNvcmQgaW5zdGFuY2VvZiBSZWNvcmRDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgcmVjb3JkIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0ge307XG4gICAgICAgIGxldCBleHBlY3RlZFJlY29yZElkeCA9IDA7XG4gICAgICAgIGxldCBhY3R1YWxSZWNvcmRJZHggPSAwO1xuICAgICAgICB3aGlsZSAoYWN0dWFsUmVjb3JkSWR4IDwgcmVjb3JkLl9maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBbaGFzaCwgdHlwZV0gPSByZWNvcmQuX2ZpZWxkc1thY3R1YWxSZWNvcmRJZHhdO1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUmVjb3JkSWR4ID49IHRoaXMuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHVuZXhwZWN0ZWQgbGVmdCBvdmVyIGZpZWxkcyBwcmVzZW50IG9uIHRoZSB3aXJlXG4gICAgICAgICAgICAgICAgdHlwZS5kZWNvZGVWYWx1ZShiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBhY3R1YWxSZWNvcmRJZHgrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtleHBlY3RLZXksIGV4cGVjdFR5cGVdID0gdGhpcy5fZmllbGRzW2V4cGVjdGVkUmVjb3JkSWR4XTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkSWQgPSBpZGxMYWJlbFRvSWQodGhpcy5fZmllbGRzW2V4cGVjdGVkUmVjb3JkSWR4XVswXSk7XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxJZCA9IGlkbExhYmVsVG9JZChoYXNoKTtcbiAgICAgICAgICAgIGlmIChleHBlY3RlZElkID09PSBhY3R1YWxJZCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IGZpZWxkIG9uIHRoZSB3aXJlIG1hdGNoZXMgdGhlIGV4cGVjdGVkIGZpZWxkXG4gICAgICAgICAgICAgICAgeFtleHBlY3RLZXldID0gZXhwZWN0VHlwZS5kZWNvZGVWYWx1ZShiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBleHBlY3RlZFJlY29yZElkeCsrO1xuICAgICAgICAgICAgICAgIGFjdHVhbFJlY29yZElkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0dWFsSWQgPiBleHBlY3RlZElkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGV4cGVjdGVkIGZpZWxkIGRvZXMgbm90IGV4aXN0IG9uIHRoZSB3aXJlXG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdFR5cGUgaW5zdGFuY2VvZiBPcHRDbGFzcyB8fCBleHBlY3RUeXBlIGluc3RhbmNlb2YgUmVzZXJ2ZWRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB4W2V4cGVjdEtleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRSZWNvcmRJZHgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgcmVxdWlyZWQgZmllbGQgJyArIGV4cGVjdEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpZWxkIG9uIHRoZSB3aXJlIGRvZXMgbm90IGV4aXN0IGluIHRoZSBvdXRwdXQgdHlwZSwgc28gd2UgY2FuIHNraXAgaXRcbiAgICAgICAgICAgICAgICB0eXBlLmRlY29kZVZhbHVlKGIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGFjdHVhbFJlY29yZElkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGluaXRpYWxpemUgbGVmdCBvdmVyIGV4cGVjdGVkIG9wdGlvbmFsIGZpZWxkc1xuICAgICAgICBmb3IgKGNvbnN0IFtleHBlY3RLZXksIGV4cGVjdFR5cGVdIG9mIHRoaXMuX2ZpZWxkcy5zbGljZShleHBlY3RlZFJlY29yZElkeCkpIHtcbiAgICAgICAgICAgIGlmIChleHBlY3RUeXBlIGluc3RhbmNlb2YgT3B0Q2xhc3MgfHwgZXhwZWN0VHlwZSBpbnN0YW5jZW9mIFJlc2VydmVkQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgYXNzdW1lcyBudWxsIHZhbHVlIGluIG9wdCBpcyByZXByZXNlbnRlZCBhcyBbXVxuICAgICAgICAgICAgICAgIHhbZXhwZWN0S2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCByZXF1aXJlZCBmaWVsZCAnICsgZXhwZWN0S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4ga2V5ICsgJzonICsgdmFsdWUubmFtZSk7XG4gICAgICAgIHJldHVybiBgcmVjb3JkIHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5LCB2YWx1ZV0pID0+IGtleSArICc6JyArIHZhbHVlLmRpc3BsYXkoKSk7XG4gICAgICAgIHJldHVybiBgcmVjb3JkIHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleV0pID0+IHhba2V5XSk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHppcFdpdGgodGhpcy5fZmllbGRzLCB2YWx1ZXMsIChbaywgY10sIGQpID0+IGsgKyAnPScgKyBjLnZhbHVlVG9TdHJpbmcoZCkpO1xuICAgICAgICByZXR1cm4gYHJlY29yZCB7JHtmaWVsZHMuam9pbignOyAnKX19YDtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgVHVwbGUsIGEgc3ludGFjdGljIHN1Z2FyIGZvciBSZWNvcmQuXG4gKiBAcGFyYW0ge1R5cGV9IGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGNsYXNzIFR1cGxlQ2xhc3MgZXh0ZW5kcyBSZWNvcmRDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoX2NvbXBvbmVudHMpIHtcbiAgICAgICAgY29uc3QgeCA9IHt9O1xuICAgICAgICBfY29tcG9uZW50cy5mb3JFYWNoKChlLCBpKSA9PiAoeFsnXycgKyBpICsgJ18nXSA9IGUpKTtcbiAgICAgICAgc3VwZXIoeCk7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBfY29tcG9uZW50cztcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRUdXBsZSh0aGlzLCB0aGlzLl9jb21wb25lbnRzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgLy8gYD49YCBiZWNhdXNlIHR1cGxlcyBjYW4gYmUgY292YXJpYW50IHdoZW4gZW5jb2RlZC5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeCkgJiZcbiAgICAgICAgICAgIHgubGVuZ3RoID49IHRoaXMuX2ZpZWxkcy5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMuZXZlcnkoKHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5jb3ZhcmlhbnQoeFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogXFxuXFxuaW5kZXggJHtpfSAtPiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCBidWZzID0gemlwV2l0aCh0aGlzLl9jb21wb25lbnRzLCB4LCAoYywgZCkgPT4gYy5lbmNvZGVWYWx1ZShkKSk7XG4gICAgICAgIHJldHVybiBjb25jYXQoLi4uYnVmcyk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgaWYgKCEodHVwbGUgaW5zdGFuY2VvZiBUdXBsZUNsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgYSB0dXBsZSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR1cGxlLl9jb21wb25lbnRzLmxlbmd0aCA8IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R1cGxlIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2ksIHdpcmVUeXBlXSBvZiB0dXBsZS5fY29tcG9uZW50cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChpID49IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCB2YWx1ZVxuICAgICAgICAgICAgICAgIHdpcmVUeXBlLmRlY29kZVZhbHVlKGIsIHdpcmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuX2NvbXBvbmVudHNbaV0uZGVjb2RlVmFsdWUoYiwgd2lyZVR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9jb21wb25lbnRzLm1hcCh2YWx1ZSA9PiB2YWx1ZS5kaXNwbGF5KCkpO1xuICAgICAgICByZXR1cm4gYHJlY29yZCB7JHtmaWVsZHMuam9pbignOyAnKX19YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gemlwV2l0aCh0aGlzLl9jb21wb25lbnRzLCB2YWx1ZXMsIChjLCBkKSA9PiBjLnZhbHVlVG9TdHJpbmcoZCkpO1xuICAgICAgICByZXR1cm4gYHJlY29yZCB7JHtmaWVsZHMuam9pbignOyAnKX19YDtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIFZhcmlhbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbZmllbGRzXSAtIG1hcHBpbmcgb2YgZnVuY3Rpb24gbmFtZSB0byBUeXBlXG4gKi9cbmV4cG9ydCBjbGFzcyBWYXJpYW50Q2xhc3MgZXh0ZW5kcyBDb25zdHJ1Y3RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9maWVsZHMgPSBPYmplY3QuZW50cmllcyhmaWVsZHMpLnNvcnQoKGEsIGIpID0+IGlkbExhYmVsVG9JZChhWzBdKSAtIGlkbExhYmVsVG9JZChiWzBdKSk7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0VmFyaWFudCh0aGlzLCB0aGlzLl9maWVsZHMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh4KS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkcy5ldmVyeSgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAheC5oYXNPd25Qcm9wZXJ0eShrKSB8fCB2LmNvdmFyaWFudCh4W2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiBcXG5cXG52YXJpYW50ICR7a30gLT4gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFtuYW1lLCB0eXBlXSA9IHRoaXMuX2ZpZWxkc1tpXTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKHguaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBsZWJFbmNvZGUoaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmID0gdHlwZS5lbmNvZGVWYWx1ZSh4W25hbWVdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0KGlkeCwgYnVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcignVmFyaWFudCBoYXMgbm8gZGF0YTogJyArIHgpO1xuICAgIH1cbiAgICBfYnVpbGRUeXBlVGFibGVJbXBsKHR5cGVUYWJsZSkge1xuICAgICAgICB0aGlzLl9maWVsZHMuZm9yRWFjaCgoWywgdHlwZV0pID0+IHtcbiAgICAgICAgICAgIHR5cGUuYnVpbGRUeXBlVGFibGUodHlwZVRhYmxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9wQ29kZSA9IHNsZWJFbmNvZGUoLTIxIC8qIElETFR5cGVJZHMuVmFyaWFudCAqLyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZSh0aGlzLl9maWVsZHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBjb25jYXQobGViRW5jb2RlKGlkbExhYmVsVG9JZChrZXkpKSwgdmFsdWUuZW5jb2RlVHlwZSh0eXBlVGFibGUpKSk7XG4gICAgICAgIHR5cGVUYWJsZS5hZGQodGhpcywgY29uY2F0KG9wQ29kZSwgbGVuLCAuLi5maWVsZHMpKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICBjb25zdCB2YXJpYW50ID0gdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIGlmICghKHZhcmlhbnQgaW5zdGFuY2VvZiBWYXJpYW50Q2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhcmlhbnQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkeCA9IE51bWJlcihsZWJEZWNvZGUoYikpO1xuICAgICAgICBpZiAoaWR4ID49IHZhcmlhbnQuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHZhcmlhbnQgaW5kZXg6ICcgKyBpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt3aXJlSGFzaCwgd2lyZVR5cGVdID0gdmFyaWFudC5fZmllbGRzW2lkeF07XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZXhwZWN0VHlwZV0gb2YgdGhpcy5fZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoaWRsTGFiZWxUb0lkKHdpcmVIYXNoKSA9PT0gaWRsTGFiZWxUb0lkKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV4cGVjdFR5cGUuZGVjb2RlVmFsdWUoYiwgd2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IFtrZXldOiB2YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgZmllbGQgaGFzaCAnICsgd2lyZUhhc2gpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleSwgdHlwZV0pID0+IGtleSArICc6JyArIHR5cGUubmFtZSk7XG4gICAgICAgIHJldHVybiBgdmFyaWFudCB7JHtmaWVsZHMuam9pbignOyAnKX19YDtcbiAgICB9XG4gICAgZGlzcGxheSgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleSwgdHlwZV0pID0+IGtleSArICh0eXBlLm5hbWUgPT09ICdudWxsJyA/ICcnIDogYDoke3R5cGUuZGlzcGxheSgpfWApKTtcbiAgICAgICAgcmV0dXJuIGB2YXJpYW50IHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdHlwZV0gb2YgdGhpcy5fZmllbGRzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIGlmICh4Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlLnZhbHVlVG9TdHJpbmcoeFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGB2YXJpYW50IHske25hbWV9fWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHZhcmlhbnQgeyR7bmFtZX09JHt2YWx1ZX19YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYXJpYW50IGhhcyBubyBkYXRhOiAnICsgeCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVmZXJlbmNlIHRvIGFuIElETCB0eXBlLCB1c2VkIGZvciBkZWZpbmluZyByZWN1cnNpdmUgZGF0YVxuICogdHlwZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNDbGFzcyBleHRlbmRzIENvbnN0cnVjdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9pZCA9IFJlY0NsYXNzLl9jb3VudGVyKys7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY3Vyc2l2ZSB0eXBlIHVuaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYudmlzaXRSZWModGhpcywgdGhpcy5fdHlwZSwgZCk7XG4gICAgfVxuICAgIGZpbGwodCkge1xuICAgICAgICB0aGlzLl90eXBlID0gdDtcbiAgICB9XG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID8gdGhpcy5fdHlwZS5jb3ZhcmlhbnQoeCkgOiBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBpZiAoIXRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdSZWN1cnNpdmUgdHlwZSB1bmluaXRpYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlLmVuY29kZVZhbHVlKHgpO1xuICAgIH1cbiAgICBfYnVpbGRUeXBlVGFibGVJbXBsKHR5cGVUYWJsZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdSZWN1cnNpdmUgdHlwZSB1bmluaXRpYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVUYWJsZS5hZGQodGhpcywgbmV3IFVpbnQ4QXJyYXkoW10pKTtcbiAgICAgICAgdGhpcy5fdHlwZS5idWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpO1xuICAgICAgICB0eXBlVGFibGUubWVyZ2UodGhpcywgdGhpcy5fdHlwZS5uYW1lKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICBpZiAoIXRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdSZWN1cnNpdmUgdHlwZSB1bmluaXRpYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlLmRlY29kZVZhbHVlKGIsIHQpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGByZWNfJHt0aGlzLl9pZH1gO1xuICAgIH1cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdSZWN1cnNpdmUgdHlwZSB1bmluaXRpYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgzrwke3RoaXMubmFtZX0uJHt0aGlzLl90eXBlLm5hbWV9YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY3Vyc2l2ZSB0eXBlIHVuaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUudmFsdWVUb1N0cmluZyh4KTtcbiAgICB9XG59XG5SZWNDbGFzcy5fY291bnRlciA9IDA7XG5mdW5jdGlvbiBkZWNvZGVQcmluY2lwYWxJZChiKSB7XG4gICAgY29uc3QgeCA9IHNhZmVSZWFkVWludDgoYik7XG4gICAgaWYgKHggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjb2RlIHByaW5jaXBhbCcpO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSBOdW1iZXIobGViRGVjb2RlKGIpKTtcbiAgICByZXR1cm4gUHJpbmNpcGFsSWQuZnJvbVVpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoc2FmZVJlYWQoYiwgbGVuKSkpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBwcmluY2lwYWwgcmVmZXJlbmNlXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmluY2lwYWxDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0UHJpbmNpcGFsKHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAoeCAmJiB4Ll9pc1ByaW5jaXBhbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCBidWYgPSB4LnRvVWludDhBcnJheSgpO1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUoYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gY29uY2F0KG5ldyBVaW50OEFycmF5KFsxXSksIGxlbiwgYnVmKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTI0IC8qIElETFR5cGVJZHMuUHJpbmNpcGFsICovKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgcmV0dXJuIGRlY29kZVByaW5jaXBhbElkKGIpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdwcmluY2lwYWwnO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gXCIke3gudG9UZXh0KCl9XCJgO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgZnVuY3Rpb24gcmVmZXJlbmNlLlxuICogQHBhcmFtIGFyZ1R5cGVzIEFyZ3VtZW50IHR5cGVzLlxuICogQHBhcmFtIHJldFR5cGVzIFJldHVybiB0eXBlcy5cbiAqIEBwYXJhbSBhbm5vdGF0aW9ucyBGdW5jdGlvbiBhbm5vdGF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmNDbGFzcyBleHRlbmRzIENvbnN0cnVjdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGFyZ1R5cGVzLCByZXRUeXBlcywgYW5ub3RhdGlvbnMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyZ1R5cGVzID0gYXJnVHlwZXM7XG4gICAgICAgIHRoaXMucmV0VHlwZXMgPSByZXRUeXBlcztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgIH1cbiAgICBzdGF0aWMgYXJnc1RvU3RyaW5nKHR5cGVzLCB2KSB7XG4gICAgICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHYubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyaXR5IG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcoJyArIHR5cGVzLm1hcCgodCwgaSkgPT4gdC52YWx1ZVRvU3RyaW5nKHZbaV0pKS5qb2luKCcsICcpICsgJyknO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdEZ1bmModGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpICYmIHgubGVuZ3RoID09PSAyICYmIHhbMF0gJiYgeFswXS5faXNQcmluY2lwYWwgJiYgdHlwZW9mIHhbMV0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZShbcHJpbmNpcGFsLCBtZXRob2ROYW1lXSkge1xuICAgICAgICBjb25zdCBidWYgPSBwcmluY2lwYWwudG9VaW50OEFycmF5KCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbmlzdGVyID0gY29uY2F0KG5ldyBVaW50OEFycmF5KFsxXSksIGxlbiwgYnVmKTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG1ldGhvZE5hbWUpO1xuICAgICAgICBjb25zdCBtZXRob2RMZW4gPSBsZWJFbmNvZGUobWV0aG9kLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gY29uY2F0KG5ldyBVaW50OEFycmF5KFsxXSksIGNhbmlzdGVyLCBtZXRob2RMZW4sIG1ldGhvZCk7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwoVCkge1xuICAgICAgICB0aGlzLmFyZ1R5cGVzLmZvckVhY2goYXJnID0+IGFyZy5idWlsZFR5cGVUYWJsZShUKSk7XG4gICAgICAgIHRoaXMucmV0VHlwZXMuZm9yRWFjaChhcmcgPT4gYXJnLmJ1aWxkVHlwZVRhYmxlKFQpKTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZSgtMjIgLyogSURMVHlwZUlkcy5GdW5jICovKTtcbiAgICAgICAgY29uc3QgYXJnTGVuID0gbGViRW5jb2RlKHRoaXMuYXJnVHlwZXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGNvbmNhdCguLi50aGlzLmFyZ1R5cGVzLm1hcChhcmcgPT4gYXJnLmVuY29kZVR5cGUoVCkpKTtcbiAgICAgICAgY29uc3QgcmV0TGVuID0gbGViRW5jb2RlKHRoaXMucmV0VHlwZXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmV0cyA9IGNvbmNhdCguLi50aGlzLnJldFR5cGVzLm1hcChhcmcgPT4gYXJnLmVuY29kZVR5cGUoVCkpKTtcbiAgICAgICAgY29uc3QgYW5uTGVuID0gbGViRW5jb2RlKHRoaXMuYW5ub3RhdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYW5ucyA9IGNvbmNhdCguLi50aGlzLmFubm90YXRpb25zLm1hcChhID0+IHRoaXMuZW5jb2RlQW5ub3RhdGlvbihhKSkpO1xuICAgICAgICBULmFkZCh0aGlzLCBjb25jYXQob3BDb2RlLCBhcmdMZW4sIGFyZ3MsIHJldExlbiwgcmV0cywgYW5uTGVuLCBhbm5zKSk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIpIHtcbiAgICAgICAgY29uc3QgeCA9IHNhZmVSZWFkVWludDgoYik7XG4gICAgICAgIGlmICh4ICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWNvZGUgZnVuY3Rpb24gcmVmZXJlbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuaXN0ZXIgPSBkZWNvZGVQcmluY2lwYWxJZChiKTtcbiAgICAgICAgY29uc3QgbUxlbiA9IE51bWJlcihsZWJEZWNvZGUoYikpO1xuICAgICAgICBjb25zdCBidWYgPSBzYWZlUmVhZChiLCBtTGVuKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcsIHsgZmF0YWw6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGRlY29kZXIuZGVjb2RlKGJ1Zik7XG4gICAgICAgIHJldHVybiBbY2FuaXN0ZXIsIG1ldGhvZF07XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5hcmdUeXBlcy5tYXAoYXJnID0+IGFyZy5uYW1lKS5qb2luKCcsICcpO1xuICAgICAgICBjb25zdCByZXRzID0gdGhpcy5yZXRUeXBlcy5tYXAoYXJnID0+IGFyZy5uYW1lKS5qb2luKCcsICcpO1xuICAgICAgICBjb25zdCBhbm5vbiA9ICcgJyArIHRoaXMuYW5ub3RhdGlvbnMuam9pbignICcpO1xuICAgICAgICByZXR1cm4gYCgke2FyZ3N9KSAtPiAoJHtyZXRzfSkke2Fubm9ufWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoW3ByaW5jaXBhbCwgc3RyXSkge1xuICAgICAgICByZXR1cm4gYGZ1bmMgXCIke3ByaW5jaXBhbC50b1RleHQoKX1cIi4ke3N0cn1gO1xuICAgIH1cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5hcmdUeXBlcy5tYXAoYXJnID0+IGFyZy5kaXNwbGF5KCkpLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IHJldHMgPSB0aGlzLnJldFR5cGVzLm1hcChhcmcgPT4gYXJnLmRpc3BsYXkoKSkuam9pbignLCAnKTtcbiAgICAgICAgY29uc3QgYW5ub24gPSAnICcgKyB0aGlzLmFubm90YXRpb25zLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIGAoJHthcmdzfSkg4oaSICgke3JldHN9KSR7YW5ub259YDtcbiAgICB9XG4gICAgZW5jb2RlQW5ub3RhdGlvbihhbm4pIHtcbiAgICAgICAgaWYgKGFubiA9PT0gJ3F1ZXJ5Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW5uID09PSAnb25ld2F5Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW5uID09PSAnY29tcG9zaXRlX3F1ZXJ5Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFszXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgZnVuY3Rpb24gYW5ub3RhdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNlcnZpY2VDbGFzcyBleHRlbmRzIENvbnN0cnVjdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9maWVsZHMgPSBPYmplY3QuZW50cmllcyhmaWVsZHMpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhWzBdIDwgYlswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhWzBdID4gYlswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdFNlcnZpY2UodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh4ICYmIHguX2lzUHJpbmNpcGFsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHgudG9VaW50OEFycmF5KCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZShidWYubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChuZXcgVWludDhBcnJheShbMV0pLCBsZW4sIGJ1Zik7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwoVCkge1xuICAgICAgICB0aGlzLl9maWVsZHMuZm9yRWFjaCgoW18sIGZ1bmNdKSA9PiBmdW5jLmJ1aWxkVHlwZVRhYmxlKFQpKTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZSgtMjMgLyogSURMVHlwZUlkcy5TZXJ2aWNlICovKTtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKHRoaXMuX2ZpZWxkcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBtZXRocyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtsYWJlbCwgZnVuY10pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsQnVmID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGxhYmVsKTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsTGVuID0gbGViRW5jb2RlKGxhYmVsQnVmLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0KGxhYmVsTGVuLCBsYWJlbEJ1ZiwgZnVuYy5lbmNvZGVUeXBlKFQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFQuYWRkKHRoaXMsIGNvbmNhdChvcENvZGUsIGxlbiwgLi4ubWV0aHMpKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYikge1xuICAgICAgICByZXR1cm4gZGVjb2RlUHJpbmNpcGFsSWQoYik7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5LCB2YWx1ZV0pID0+IGtleSArICc6JyArIHZhbHVlLm5hbWUpO1xuICAgICAgICByZXR1cm4gYHNlcnZpY2UgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4gYHNlcnZpY2UgXCIke3gudG9UZXh0KCl9XCJgO1xuICAgIH1cbn1cbi8qKlxuICogVGFrZXMgYW4gdW5rbm93biB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdC5cbiAqIEBwYXJhbSB4IC0gdW5rbm93biB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b1JlYWRhYmxlU3RyaW5nKHgpIHtcbiAgICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeSh4LCAoX2tleSwgdmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgPyBgQmlnSW50KCR7dmFsdWV9KWAgOiB2YWx1ZSk7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIubGVuZ3RoID4gdG9SZWFkYWJsZVN0cmluZ19tYXhcbiAgICAgICAgPyBzdHIuc3Vic3RyaW5nKDAsIHRvUmVhZGFibGVTdHJpbmdfbWF4IC0gMykgKyAnLi4uJ1xuICAgICAgICA6IHN0cjtcbn1cbi8qKlxuICogRW5jb2RlIGEgYXJyYXkgb2YgdmFsdWVzXG4gKiBAcGFyYW0gYXJnVHlwZXMgLSBhcnJheSBvZiBUeXBlc1xuICogQHBhcmFtIGFyZ3MgLSBhcnJheSBvZiB2YWx1ZXNcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gc2VyaWFsaXNlZCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGFyZ1R5cGVzLCBhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgYXJnVHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdXcm9uZyBudW1iZXIgb2YgbWVzc2FnZSBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZVRhYmxlID0gbmV3IFR5cGVUYWJsZSgpO1xuICAgIGFyZ1R5cGVzLmZvckVhY2godCA9PiB0LmJ1aWxkVHlwZVRhYmxlKHR5cGVUYWJsZSkpO1xuICAgIGNvbnN0IG1hZ2ljID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG1hZ2ljTnVtYmVyKTtcbiAgICBjb25zdCB0YWJsZSA9IHR5cGVUYWJsZS5lbmNvZGUoKTtcbiAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUoYXJncy5sZW5ndGgpO1xuICAgIGNvbnN0IHR5cHMgPSBjb25jYXQoLi4uYXJnVHlwZXMubWFwKHQgPT4gdC5lbmNvZGVUeXBlKHR5cGVUYWJsZSkpKTtcbiAgICBjb25zdCB2YWxzID0gY29uY2F0KC4uLnppcFdpdGgoYXJnVHlwZXMsIGFyZ3MsICh0LCB4KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0LmNvdmFyaWFudCh4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGUubWVzc2FnZSArICdcXG5cXG4nKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC5lbmNvZGVWYWx1ZSh4KTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIGNvbmNhdChtYWdpYywgdGFibGUsIGxlbiwgdHlwcywgdmFscyk7XG59XG4vKipcbiAqIERlY29kZSBhIGJpbmFyeSB2YWx1ZVxuICogQHBhcmFtIHJldFR5cGVzIC0gVHlwZXMgZXhwZWN0ZWQgaW4gdGhlIGJ1ZmZlci5cbiAqIEBwYXJhbSBieXRlcyAtIGhleC1lbmNvZGVkIHN0cmluZywgb3IgYnVmZmVyLlxuICogQHJldHVybnMgVmFsdWUgZGVzZXJpYWxpc2VkIHRvIEpTIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShyZXRUeXBlcywgYnl0ZXMpIHtcbiAgICBjb25zdCBiID0gbmV3IFBpcGUoYnl0ZXMpO1xuICAgIGlmIChieXRlcy5ieXRlTGVuZ3RoIDwgbWFnaWNOdW1iZXIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBsZW5ndGggc21hbGxlciB0aGFuIG1hZ2ljIG51bWJlcicpO1xuICAgIH1cbiAgICBjb25zdCBtYWdpY0J1ZmZlciA9IHNhZmVSZWFkKGIsIG1hZ2ljTnVtYmVyLmxlbmd0aCk7XG4gICAgY29uc3QgbWFnaWMgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobWFnaWNCdWZmZXIpO1xuICAgIGlmIChtYWdpYyAhPT0gbWFnaWNOdW1iZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBtYWdpYyBudW1iZXI6ICcgKyBKU09OLnN0cmluZ2lmeShtYWdpYykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkVHlwZVRhYmxlKHBpcGUpIHtcbiAgICAgICAgY29uc3QgdHlwZVRhYmxlID0gW107XG4gICAgICAgIGNvbnN0IGxlbiA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0eSA9IE51bWJlcihzbGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIC0xOCAvKiBJRExUeXBlSWRzLk9wdCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIC0xOSAvKiBJRExUeXBlSWRzLlZlY3RvciAqLzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gTnVtYmVyKHNsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB0eXBlVGFibGUucHVzaChbdHksIHRdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgLTIwIC8qIElETFR5cGVJZHMuUmVjb3JkICovOlxuICAgICAgICAgICAgICAgIGNhc2UgLTIxIC8qIElETFR5cGVJZHMuVmFyaWFudCAqLzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9iamVjdExlbmd0aCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldkhhc2g7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvYmplY3RMZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2ggPj0gTWF0aC5wb3coMiwgMzIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBpZCBvdXQgb2YgMzItYml0IHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByZXZIYXNoID09PSAnbnVtYmVyJyAmJiBwcmV2SGFzaCA+PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBpZCBjb2xsaXNpb24gb3Igbm90IHNvcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IE51bWJlcihzbGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKFtoYXNoLCB0XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZVRhYmxlLnB1c2goW3R5LCBmaWVsZHNdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgLTIyIC8qIElETFR5cGVJZHMuRnVuYyAqLzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBhcmdMZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFyZ0xlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goTnVtYmVyKHNsZWJEZWNvZGUocGlwZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVyblZhbHVlc0xlbmd0aCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmV0dXJuVmFsdWVzTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlcy5wdXNoKE51bWJlcihzbGViRGVjb2RlKHBpcGUpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFubm90YXRpb25MZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFubm90YXRpb25MZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbiA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2goJ3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaCgnb25ld2F5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaCgnY29tcG9zaXRlX3F1ZXJ5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gYW5ub3RhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVUYWJsZS5wdXNoKFt0eSwgW2FyZ3MsIHJldHVyblZhbHVlcywgYW5ub3RhdGlvbnNdXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIC0yMyAvKiBJRExUeXBlSWRzLlNlcnZpY2UgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcnZMZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0aG9kcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2Vydkxlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lTGVuZ3RoID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmdW5jTmFtZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShzYWZlUmVhZChwaXBlLCBuYW1lTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmdW5jVHlwZSA9IHNsZWJEZWNvZGUocGlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzLnB1c2goW2Z1bmNOYW1lLCBmdW5jVHlwZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVUYWJsZS5wdXNoKFt0eSwgbWV0aG9kc10pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIG9wX2NvZGU6ICcgKyB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3TGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmF3TGlzdC5wdXNoKE51bWJlcihzbGViRGVjb2RlKHBpcGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0eXBlVGFibGUsIHJhd0xpc3RdO1xuICAgIH1cbiAgICBjb25zdCBbcmF3VGFibGUsIHJhd1R5cGVzXSA9IHJlYWRUeXBlVGFibGUoYik7XG4gICAgaWYgKHJhd1R5cGVzLmxlbmd0aCA8IHJldFR5cGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIG51bWJlciBvZiByZXR1cm4gdmFsdWVzJyk7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlID0gcmF3VGFibGUubWFwKF8gPT4gUmVjKCkpO1xuICAgIGZ1bmN0aW9uIGdldFR5cGUodCkge1xuICAgICAgICBpZiAodCA8IC0yNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdXR1cmUgdmFsdWUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0IDwgMCkge1xuICAgICAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGw7XG4gICAgICAgICAgICAgICAgY2FzZSAtMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJvb2w7XG4gICAgICAgICAgICAgICAgY2FzZSAtMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hdDtcbiAgICAgICAgICAgICAgICBjYXNlIC00OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW50O1xuICAgICAgICAgICAgICAgIGNhc2UgLTU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYXQ4O1xuICAgICAgICAgICAgICAgIGNhc2UgLTY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYXQxNjtcbiAgICAgICAgICAgICAgICBjYXNlIC03OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmF0MzI7XG4gICAgICAgICAgICAgICAgY2FzZSAtODpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hdDY0O1xuICAgICAgICAgICAgICAgIGNhc2UgLTk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQ4O1xuICAgICAgICAgICAgICAgIGNhc2UgLTEwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW50MTY7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQzMjtcbiAgICAgICAgICAgICAgICBjYXNlIC0xMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDY0O1xuICAgICAgICAgICAgICAgIGNhc2UgLTEzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmxvYXQzMjtcbiAgICAgICAgICAgICAgICBjYXNlIC0xNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZsb2F0NjQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUZXh0O1xuICAgICAgICAgICAgICAgIGNhc2UgLTE2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVzZXJ2ZWQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFbXB0eTtcbiAgICAgICAgICAgICAgICBjYXNlIC0yNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByaW5jaXBhbDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgb3BfY29kZTogJyArIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ID49IHJhd1RhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIGluZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJsZVt0XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRUeXBlKGVudHJ5KSB7XG4gICAgICAgIHN3aXRjaCAoZW50cnlbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgLTE5IC8qIElETFR5cGVJZHMuVmVjdG9yICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHkgPSBnZXRUeXBlKGVudHJ5WzFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjKHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgLTE4IC8qIElETFR5cGVJZHMuT3B0ICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHkgPSBnZXRUeXBlKGVudHJ5WzFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT3B0KHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgLTIwIC8qIElETFR5cGVJZHMuUmVjb3JkICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaGFzaCwgdHldIG9mIGVudHJ5WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBgXyR7aGFzaH1fYDtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzW25hbWVdID0gZ2V0VHlwZSh0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IFJlY29yZChmaWVsZHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR1cGxlID0gcmVjb3JkLnRyeUFzVHVwbGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0dXBsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR1cGxlKC4uLnR1cGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAtMjEgLyogSURMVHlwZUlkcy5WYXJpYW50ICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaGFzaCwgdHldIG9mIGVudHJ5WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBgXyR7aGFzaH1fYDtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzW25hbWVdID0gZ2V0VHlwZSh0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBWYXJpYW50KGZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIC0yMiAvKiBJRExUeXBlSWRzLkZ1bmMgKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYXJncywgcmV0dXJuVmFsdWVzLCBhbm5vdGF0aW9uc10gPSBlbnRyeVsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuYyhhcmdzLm1hcCgodCkgPT4gZ2V0VHlwZSh0KSksIHJldHVyblZhbHVlcy5tYXAoKHQpID0+IGdldFR5cGUodCkpLCBhbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIC0yMyAvKiBJRExUeXBlSWRzLlNlcnZpY2UgKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWMgPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRob2RzID0gZW50cnlbMV07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdHlwZVJlZl0gb2YgbWV0aG9kcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IGdldFR5cGUodHlwZVJlZik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlIGluc3RhbmNlb2YgUmVjQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVucGFjayByZWZlcmVuY2UgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBGdW5jQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgc2VydmljZSBkZWZpbml0aW9uOiBzZXJ2aWNlcyBjYW4gb25seSBjb250YWluIGZ1bmN0aW9ucycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY1tuYW1lXSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBTZXJ2aWNlKHJlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBvcF9jb2RlOiAnICsgZW50cnlbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJhd1RhYmxlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XG4gICAgICAgIC8vIFByb2Nlc3MgZnVuY3Rpb24gdHlwZSBmaXJzdCwgc28gdGhhdCB3ZSBjYW4gY29uc3RydWN0IHRoZSBjb3JyZWN0IHNlcnZpY2UgdHlwZVxuICAgICAgICBpZiAoZW50cnlbMF0gPT09IC0yMiAvKiBJRExUeXBlSWRzLkZ1bmMgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBidWlsZFR5cGUoZW50cnkpO1xuICAgICAgICAgICAgdGFibGVbaV0uZmlsbCh0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJhd1RhYmxlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XG4gICAgICAgIGlmIChlbnRyeVswXSAhPT0gLTIyIC8qIElETFR5cGVJZHMuRnVuYyAqLykge1xuICAgICAgICAgICAgY29uc3QgdCA9IGJ1aWxkVHlwZShlbnRyeSk7XG4gICAgICAgICAgICB0YWJsZVtpXS5maWxsKHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgdHlwZXMgPSByYXdUeXBlcy5tYXAodCA9PiBnZXRUeXBlKHQpKTtcbiAgICBjb25zdCBvdXRwdXQgPSByZXRUeXBlcy5tYXAoKHQsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIHQuZGVjb2RlVmFsdWUoYiwgdHlwZXNbaV0pO1xuICAgIH0pO1xuICAgIC8vIHNraXAgdW51c2VkIHZhbHVlc1xuICAgIGZvciAobGV0IGluZCA9IHJldFR5cGVzLmxlbmd0aDsgaW5kIDwgdHlwZXMubGVuZ3RoOyBpbmQrKykge1xuICAgICAgICB0eXBlc1tpbmRdLmRlY29kZVZhbHVlKGIsIHR5cGVzW2luZF0pO1xuICAgIH1cbiAgICBpZiAoYi5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY29kZTogTGVmdC1vdmVyIGJ5dGVzJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vLyBFeHBvcnQgVHlwZXMgaW5zdGFuY2VzLlxuZXhwb3J0IGNvbnN0IEVtcHR5ID0gbmV3IEVtcHR5Q2xhc3MoKTtcbmV4cG9ydCBjb25zdCBSZXNlcnZlZCA9IG5ldyBSZXNlcnZlZENsYXNzKCk7XG4vKipcbiAqIENsaWVudC1vbmx5IHR5cGUgZm9yIGRlc2VyaWFsaXppbmcgdW5rbm93biBkYXRhLiBOb3Qgc3VwcG9ydGVkIGJ5IENhbmRpZCwgYW5kIGl0cyB1c2UgaXMgZGlzY291cmFnZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBVbmtub3duID0gbmV3IFVua25vd25DbGFzcygpO1xuZXhwb3J0IGNvbnN0IEJvb2wgPSBuZXcgQm9vbENsYXNzKCk7XG5leHBvcnQgY29uc3QgTnVsbCA9IG5ldyBOdWxsQ2xhc3MoKTtcbmV4cG9ydCBjb25zdCBUZXh0ID0gbmV3IFRleHRDbGFzcygpO1xuZXhwb3J0IGNvbnN0IEludCA9IG5ldyBJbnRDbGFzcygpO1xuZXhwb3J0IGNvbnN0IE5hdCA9IG5ldyBOYXRDbGFzcygpO1xuZXhwb3J0IGNvbnN0IEZsb2F0MzIgPSBuZXcgRmxvYXRDbGFzcygzMik7XG5leHBvcnQgY29uc3QgRmxvYXQ2NCA9IG5ldyBGbG9hdENsYXNzKDY0KTtcbmV4cG9ydCBjb25zdCBJbnQ4ID0gbmV3IEZpeGVkSW50Q2xhc3MoOCk7XG5leHBvcnQgY29uc3QgSW50MTYgPSBuZXcgRml4ZWRJbnRDbGFzcygxNik7XG5leHBvcnQgY29uc3QgSW50MzIgPSBuZXcgRml4ZWRJbnRDbGFzcygzMik7XG5leHBvcnQgY29uc3QgSW50NjQgPSBuZXcgRml4ZWRJbnRDbGFzcyg2NCk7XG5leHBvcnQgY29uc3QgTmF0OCA9IG5ldyBGaXhlZE5hdENsYXNzKDgpO1xuZXhwb3J0IGNvbnN0IE5hdDE2ID0gbmV3IEZpeGVkTmF0Q2xhc3MoMTYpO1xuZXhwb3J0IGNvbnN0IE5hdDMyID0gbmV3IEZpeGVkTmF0Q2xhc3MoMzIpO1xuZXhwb3J0IGNvbnN0IE5hdDY0ID0gbmV3IEZpeGVkTmF0Q2xhc3MoNjQpO1xuZXhwb3J0IGNvbnN0IFByaW5jaXBhbCA9IG5ldyBQcmluY2lwYWxDbGFzcygpO1xuLyoqXG4gKlxuICogQHBhcmFtIHR5cGVzIGFycmF5IG9mIGFueSB0eXBlc1xuICogQHJldHVybnMgVHVwbGVDbGFzcyBmcm9tIHRob3NlIHR5cGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBUdXBsZSguLi50eXBlcykge1xuICAgIHJldHVybiBuZXcgVHVwbGVDbGFzcyh0eXBlcyk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdCBJREwgVHlwZVxuICogQHJldHVybnMgVmVjQ2xhc3MgZnJvbSB0aGF0IHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZlYyh0KSB7XG4gICAgcmV0dXJuIG5ldyBWZWNDbGFzcyh0KTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB0IElETCBUeXBlXG4gKiBAcmV0dXJucyBPcHRDbGFzcyBvZiBUeXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBPcHQodCkge1xuICAgIHJldHVybiBuZXcgT3B0Q2xhc3ModCk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdCBSZWNvcmQgb2Ygc3RyaW5nIGFuZCBJREwgVHlwZVxuICogQHJldHVybnMgUmVjb3JkQ2xhc3Mgb2Ygc3RyaW5nIGFuZCBUeXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZWNvcmQodCkge1xuICAgIHJldHVybiBuZXcgUmVjb3JkQ2xhc3ModCk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gZmllbGRzIFJlY29yZCBvZiBzdHJpbmcgYW5kIElETCBUeXBlXG4gKiBAcmV0dXJucyBWYXJpYW50Q2xhc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZhcmlhbnQoZmllbGRzKSB7XG4gICAgcmV0dXJuIG5ldyBWYXJpYW50Q2xhc3MoZmllbGRzKTtcbn1cbi8qKlxuICpcbiAqIEByZXR1cm5zIG5ldyBSZWNDbGFzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gUmVjKCkge1xuICAgIHJldHVybiBuZXcgUmVjQ2xhc3MoKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBhcmdzIGFycmF5IG9mIElETCBUeXBlc1xuICogQHBhcmFtIHJldCBhcnJheSBvZiBJREwgVHlwZXNcbiAqIEBwYXJhbSBhbm5vdGF0aW9ucyBhcnJheSBvZiBzdHJpbmdzLCBbXSBieSBkZWZhdWx0XG4gKiBAcmV0dXJucyBuZXcgRnVuY0NsYXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGdW5jKGFyZ3MsIHJldCwgYW5ub3RhdGlvbnMgPSBbXSkge1xuICAgIHJldHVybiBuZXcgRnVuY0NsYXNzKGFyZ3MsIHJldCwgYW5ub3RhdGlvbnMpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHQgUmVjb3JkIG9mIHN0cmluZyBhbmQgRnVuY0NsYXNzXG4gKiBAcmV0dXJucyBTZXJ2aWNlQ2xhc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNlcnZpY2UodCkge1xuICAgIHJldHVybiBuZXcgU2VydmljZUNsYXNzKHQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWRsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/idl.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/index.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/index.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IDL: () => (/* reexport module object */ _idl__WEBPACK_IMPORTED_MODULE_2__)\n/* harmony export */ });\n/* harmony import */ var _candid_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./candid-ui */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/candid-ui.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _candid_ui__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"IDL\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _candid_ui__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _candid_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./candid-core */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/candid-core.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _candid_core__WEBPACK_IMPORTED_MODULE_1__) if([\"default\",\"IDL\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _candid_core__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _idl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./idl */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/idl.js\");\n/* harmony import */ var _utils_hash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/hash */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/hash.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _utils_hash__WEBPACK_IMPORTED_MODULE_3__) if([\"default\",\"IDL\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _utils_hash__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/leb128 */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/leb128.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _utils_leb128__WEBPACK_IMPORTED_MODULE_4__) if([\"default\",\"IDL\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _utils_leb128__WEBPACK_IMPORTED_MODULE_4__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/buffer */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _utils_buffer__WEBPACK_IMPORTED_MODULE_5__) if([\"default\",\"IDL\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _utils_buffer__WEBPACK_IMPORTED_MODULE_5__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/types.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_6__) if([\"default\",\"IDL\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _types__WEBPACK_IMPORTED_MODULE_6__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEI7QUFDRTtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ1A7QUFDeEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9jYW5kaWQtdWknO1xuZXhwb3J0ICogZnJvbSAnLi9jYW5kaWQtY29yZSc7XG5leHBvcnQgKiBhcyBJREwgZnJvbSAnLi9pZGwnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9oYXNoJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvbGViMTI4JztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvYnVmZmVyJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/types.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/types.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vdHlwZXMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/types.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   iexp2: () => (/* binding */ iexp2),\n/* harmony export */   ilog2: () => (/* binding */ ilog2)\n/* harmony export */ });\n/**\n * Equivalent to `Math.log2(n)` with support for `BigInt` values\n * @param n bigint or integer\n * @returns integer\n */\nfunction ilog2(n) {\n    const nBig = BigInt(n);\n    if (n <= 0) {\n        throw new RangeError('Input must be positive');\n    }\n    return nBig.toString(2).length - 1;\n}\n/**\n * Equivalent to `2 ** n` with support for `BigInt` values\n * (necessary for browser preprocessors which replace the `**` operator with `Math.pow`)\n * @param n bigint or integer\n * @returns bigint\n */\nfunction iexp2(n) {\n    const nBig = BigInt(n);\n    if (n < 0) {\n        throw new RangeError('Input must be non-negative');\n    }\n    return BigInt(1) << nBig;\n}\n//# sourceMappingURL=bigint-math.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vdXRpbHMvYmlnaW50LW1hdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2JpZ2ludC1tYXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5sb2cyKG4pYCB3aXRoIHN1cHBvcnQgZm9yIGBCaWdJbnRgIHZhbHVlc1xuICogQHBhcmFtIG4gYmlnaW50IG9yIGludGVnZXJcbiAqIEByZXR1cm5zIGludGVnZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlsb2cyKG4pIHtcbiAgICBjb25zdCBuQmlnID0gQmlnSW50KG4pO1xuICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0lucHV0IG11c3QgYmUgcG9zaXRpdmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5CaWcudG9TdHJpbmcoMikubGVuZ3RoIC0gMTtcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBgMiAqKiBuYCB3aXRoIHN1cHBvcnQgZm9yIGBCaWdJbnRgIHZhbHVlc1xuICogKG5lY2Vzc2FyeSBmb3IgYnJvd3NlciBwcmVwcm9jZXNzb3JzIHdoaWNoIHJlcGxhY2UgdGhlIGAqKmAgb3BlcmF0b3Igd2l0aCBgTWF0aC5wb3dgKVxuICogQHBhcmFtIG4gYmlnaW50IG9yIGludGVnZXJcbiAqIEByZXR1cm5zIGJpZ2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWV4cDIobikge1xuICAgIGNvbnN0IG5CaWcgPSBCaWdJbnQobik7XG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnB1dCBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KDEpIDw8IG5CaWc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaWdpbnQtbWF0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/buffer.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/buffer.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PipeArrayBuffer: () => (/* binding */ PipeArrayBuffer),\n/* harmony export */   bufFromBufLike: () => (/* binding */ bufFromBufLike),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   fromHexString: () => (/* binding */ fromHexString),\n/* harmony export */   toHexString: () => (/* binding */ toHexString),\n/* harmony export */   uint8ToBuf: () => (/* binding */ uint8ToBuf)\n/* harmony export */ });\n/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nfunction concat(...buffers) {\n    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n    let index = 0;\n    for (const b of buffers) {\n        result.set(new Uint8Array(b), index);\n        index += b.byteLength;\n    }\n    return result;\n}\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\nfunction toHexString(bytes) {\n    return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\nfunction fromHexString(hexString) {\n    var _a;\n    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16)));\n}\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\nclass PipeArrayBuffer {\n    /**\n     * Creates a new instance of a pipe\n     * @param buffer an optional buffer to start with\n     * @param length an optional amount of bytes to use for the length.\n     */\n    constructor(buffer, length = (buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) || 0) {\n        this._buffer = bufFromBufLike(buffer || new ArrayBuffer(0));\n        this._view = new Uint8Array(this._buffer, 0, length);\n    }\n    get buffer() {\n        // Return a copy of the buffer.\n        return bufFromBufLike(this._view.slice());\n    }\n    get byteLength() {\n        return this._view.byteLength;\n    }\n    /**\n     * Read `num` number of bytes from the front of the pipe.\n     * @param num The number of bytes to read.\n     */\n    read(num) {\n        const result = this._view.subarray(0, num);\n        this._view = this._view.subarray(num);\n        return result.slice().buffer;\n    }\n    readUint8() {\n        const result = this._view[0];\n        this._view = this._view.subarray(1);\n        return result;\n    }\n    /**\n     * Write a buffer to the end of the pipe.\n     * @param buf The bytes to write.\n     */\n    write(buf) {\n        const b = new Uint8Array(buf);\n        const offset = this._view.byteLength;\n        if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n            // Alloc grow the view to include the new bytes.\n            this.alloc(b.byteLength);\n        }\n        else {\n            // Update the view to include the new bytes.\n            this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);\n        }\n        this._view.set(b, offset);\n    }\n    /**\n     * Whether or not there is more data to read from the buffer\n     */\n    get end() {\n        return this._view.byteLength === 0;\n    }\n    /**\n     * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n     * @param amount A number of bytes to add to the buffer.\n     */\n    alloc(amount) {\n        // Add a little bit of exponential growth.\n        const b = new ArrayBuffer(((this._buffer.byteLength + amount) * 1.2) | 0);\n        const v = new Uint8Array(b, 0, this._view.byteLength + amount);\n        v.set(this._view);\n        this._buffer = b;\n        this._view = v;\n    }\n}\n/**\n * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.\n * @param {Uint8Array} arr Uint8Array to convert\n * @returns ArrayBuffer\n */\nfunction uint8ToBuf(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;\n}\n/**\n * Returns a true ArrayBuffer from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns ArrayBuffer\n */\nfunction bufFromBufLike(bufLike) {\n    if (bufLike instanceof Uint8Array) {\n        return uint8ToBuf(bufLike);\n    }\n    if (bufLike instanceof ArrayBuffer) {\n        return bufLike;\n    }\n    if (Array.isArray(bufLike)) {\n        return uint8ToBuf(new Uint8Array(bufLike));\n    }\n    if ('buffer' in bufLike) {\n        return bufFromBufLike(bufLike.buffer);\n    }\n    return uint8ToBuf(new Uint8Array(bufLike));\n}\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vdXRpbHMvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2J1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbmNhdGVuYXRlIG11bHRpcGxlIGFycmF5IGJ1ZmZlcnMuXG4gKiBAcGFyYW0gYnVmZmVycyBUaGUgYnVmZmVycyB0byBjb25jYXRlbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdCguLi5idWZmZXJzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVycy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5ieXRlTGVuZ3RoLCAwKSk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGIgb2YgYnVmZmVycykge1xuICAgICAgICByZXN1bHQuc2V0KG5ldyBVaW50OEFycmF5KGIpLCBpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IGIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBhbiBhcnJheSBidWZmZXIuXG4gKiBAcGFyYW0gYnl0ZXMgVGhlIGFycmF5IGJ1ZmZlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4U3RyaW5nKGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5yZWR1Y2UoKHN0ciwgYnl0ZSkgPT4gc3RyICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSwgJycpO1xufVxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgYnVmZmVyIGZyb20gaXRzIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIGhleFN0cmluZyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleFN0cmluZyhoZXhTdHJpbmcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCgoX2EgPSBoZXhTdHJpbmcubWF0Y2goLy57MSwyfS9nKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLm1hcChieXRlID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpO1xufVxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgYWJzdHJhY3RzIGEgcGlwZS1saWtlIEFycmF5QnVmZmVyLlxuICovXG5leHBvcnQgY2xhc3MgUGlwZUFycmF5QnVmZmVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgcGlwZVxuICAgICAqIEBwYXJhbSBidWZmZXIgYW4gb3B0aW9uYWwgYnVmZmVyIHRvIHN0YXJ0IHdpdGhcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIGFuIG9wdGlvbmFsIGFtb3VudCBvZiBieXRlcyB0byB1c2UgZm9yIHRoZSBsZW5ndGguXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBsZW5ndGggPSAoYnVmZmVyID09PSBudWxsIHx8IGJ1ZmZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnVmZmVyLmJ5dGVMZW5ndGgpIHx8IDApIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gYnVmRnJvbUJ1Zkxpa2UoYnVmZmVyIHx8IG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gICAgICAgIHRoaXMuX3ZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIsIDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIGdldCBidWZmZXIoKSB7XG4gICAgICAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIGJ1ZmZlci5cbiAgICAgICAgcmV0dXJuIGJ1ZkZyb21CdWZMaWtlKHRoaXMuX3ZpZXcuc2xpY2UoKSk7XG4gICAgfVxuICAgIGdldCBieXRlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGBudW1gIG51bWJlciBvZiBieXRlcyBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcGlwZS5cbiAgICAgKiBAcGFyYW0gbnVtIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKi9cbiAgICByZWFkKG51bSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl92aWV3LnN1YmFycmF5KDAsIG51bSk7XG4gICAgICAgIHRoaXMuX3ZpZXcgPSB0aGlzLl92aWV3LnN1YmFycmF5KG51bSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc2xpY2UoKS5idWZmZXI7XG4gICAgfVxuICAgIHJlYWRVaW50OCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fdmlld1swXTtcbiAgICAgICAgdGhpcy5fdmlldyA9IHRoaXMuX3ZpZXcuc3ViYXJyYXkoMSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYnVmZmVyIHRvIHRoZSBlbmQgb2YgdGhlIHBpcGUuXG4gICAgICogQHBhcmFtIGJ1ZiBUaGUgYnl0ZXMgdG8gd3JpdGUuXG4gICAgICovXG4gICAgd3JpdGUoYnVmKSB7XG4gICAgICAgIGNvbnN0IGIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl92aWV3LmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl92aWV3LmJ5dGVPZmZzZXQgKyB0aGlzLl92aWV3LmJ5dGVMZW5ndGggKyBiLmJ5dGVMZW5ndGggPj0gdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEFsbG9jIGdyb3cgdGhlIHZpZXcgdG8gaW5jbHVkZSB0aGUgbmV3IGJ5dGVzLlxuICAgICAgICAgICAgdGhpcy5hbGxvYyhiLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB2aWV3IHRvIGluY2x1ZGUgdGhlIG5ldyBieXRlcy5cbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuX3ZpZXcuYnl0ZU9mZnNldCwgdGhpcy5fdmlldy5ieXRlTGVuZ3RoICsgYi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aWV3LnNldChiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBtb3JlIGRhdGEgdG8gcmVhZCBmcm9tIHRoZSBidWZmZXJcbiAgICAgKi9cbiAgICBnZXQgZW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5ieXRlTGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZSBhIGZpeGVkIGFtb3VudCBvZiBtZW1vcnkgaW4gdGhlIGJ1ZmZlci4gVGhpcyBkb2VzIG5vdCBhZmZlY3QgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIGFtb3VudCBBIG51bWJlciBvZiBieXRlcyB0byBhZGQgdG8gdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBhbGxvYyhhbW91bnQpIHtcbiAgICAgICAgLy8gQWRkIGEgbGl0dGxlIGJpdCBvZiBleHBvbmVudGlhbCBncm93dGguXG4gICAgICAgIGNvbnN0IGIgPSBuZXcgQXJyYXlCdWZmZXIoKCh0aGlzLl9idWZmZXIuYnl0ZUxlbmd0aCArIGFtb3VudCkgKiAxLjIpIHwgMCk7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheShiLCAwLCB0aGlzLl92aWV3LmJ5dGVMZW5ndGggKyBhbW91bnQpO1xuICAgICAgICB2LnNldCh0aGlzLl92aWV3KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gYjtcbiAgICAgICAgdGhpcy5fdmlldyA9IHY7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgdHJ1ZSBBcnJheUJ1ZmZlciBmcm9tIGEgVWludDhBcnJheSwgYXMgVWludDhBcnJheS5idWZmZXIgaXMgdW5zYWZlLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnIgVWludDhBcnJheSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyBBcnJheUJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gdWludDhUb0J1ZihhcnIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCkuYnVmZmVyO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdHJ1ZSBBcnJheUJ1ZmZlciBmcm9tIGFuIEFycmF5QnVmZmVyTGlrZSBvYmplY3QuXG4gKiBAcGFyYW0gYnVmTGlrZSBhIGJ1ZmZlci1saWtlIG9iamVjdFxuICogQHJldHVybnMgQXJyYXlCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZkZyb21CdWZMaWtlKGJ1Zkxpa2UpIHtcbiAgICBpZiAoYnVmTGlrZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4VG9CdWYoYnVmTGlrZSk7XG4gICAgfVxuICAgIGlmIChidWZMaWtlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zkxpa2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGJ1Zkxpa2UpKSB7XG4gICAgICAgIHJldHVybiB1aW50OFRvQnVmKG5ldyBVaW50OEFycmF5KGJ1Zkxpa2UpKTtcbiAgICB9XG4gICAgaWYgKCdidWZmZXInIGluIGJ1Zkxpa2UpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZkZyb21CdWZMaWtlKGJ1Zkxpa2UuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnQ4VG9CdWYobmV3IFVpbnQ4QXJyYXkoYnVmTGlrZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/buffer.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/hash.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/hash.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   idlLabelToId: () => (/* binding */ idlLabelToId)\n/* harmony export */ });\n/**\n * Hashes a string to a number. Algorithm can be found here:\n * https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf\n * @param s - string to hash\n * @returns number representing hashed string\n */\nfunction idlHash(s) {\n    const utf8encoder = new TextEncoder();\n    const array = utf8encoder.encode(s);\n    let h = 0;\n    for (const c of array) {\n        h = (h * 223 + c) % 2 ** 32;\n    }\n    return h;\n}\n/**\n *\n * @param label string\n * @returns number representing hashed label\n */\nfunction idlLabelToId(label) {\n    if (/^_\\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {\n        const num = +label.slice(1, -1);\n        if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {\n            return num;\n        }\n    }\n    return idlHash(label);\n}\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vdXRpbHMvaGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2hhc2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIYXNoZXMgYSBzdHJpbmcgdG8gYSBudW1iZXIuIEFsZ29yaXRobSBjYW4gYmUgZm91bmQgaGVyZTpcbiAqIGh0dHBzOi8vY2FtbC5pbnJpYS5mci9wdWIvcGFwZXJzL2dhcnJpZ3VlLXBvbHltb3JwaGljX3ZhcmlhbnRzLW1sOTgucGRmXG4gKiBAcGFyYW0gcyAtIHN0cmluZyB0byBoYXNoXG4gKiBAcmV0dXJucyBudW1iZXIgcmVwcmVzZW50aW5nIGhhc2hlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaWRsSGFzaChzKSB7XG4gICAgY29uc3QgdXRmOGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBhcnJheSA9IHV0ZjhlbmNvZGVyLmVuY29kZShzKTtcbiAgICBsZXQgaCA9IDA7XG4gICAgZm9yIChjb25zdCBjIG9mIGFycmF5KSB7XG4gICAgICAgIGggPSAoaCAqIDIyMyArIGMpICUgMiAqKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuIGg7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gbGFiZWwgc3RyaW5nXG4gKiBAcmV0dXJucyBudW1iZXIgcmVwcmVzZW50aW5nIGhhc2hlZCBsYWJlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRsTGFiZWxUb0lkKGxhYmVsKSB7XG4gICAgaWYgKC9eX1xcZCtfJC8udGVzdChsYWJlbCkgfHwgL15fMHhbMC05YS1mQS1GXStfJC8udGVzdChsYWJlbCkpIHtcbiAgICAgICAgY29uc3QgbnVtID0gK2xhYmVsLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgJiYgbnVtID49IDAgJiYgbnVtIDwgMiAqKiAzMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWRsSGFzaChsYWJlbCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/hash.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/leb128.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/leb128.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lebDecode: () => (/* binding */ lebDecode),\n/* harmony export */   lebEncode: () => (/* binding */ lebEncode),\n/* harmony export */   readIntLE: () => (/* binding */ readIntLE),\n/* harmony export */   readUIntLE: () => (/* binding */ readUIntLE),\n/* harmony export */   safeRead: () => (/* binding */ safeRead),\n/* harmony export */   safeReadUint8: () => (/* binding */ safeReadUint8),\n/* harmony export */   slebDecode: () => (/* binding */ slebDecode),\n/* harmony export */   slebEncode: () => (/* binding */ slebEncode),\n/* harmony export */   writeIntLE: () => (/* binding */ writeIntLE),\n/* harmony export */   writeUIntLE: () => (/* binding */ writeUIntLE)\n/* harmony export */ });\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ \"./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* eslint-disable no-constant-condition */\n// Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer\n//       implementation, which isn't compatible with the NPM buffer package\n//       which we use everywhere else. This means that we have to transform\n//       one into the other, hence why every function that returns a Buffer\n//       actually return `new Buffer(pipe.buffer)`.\n// TODO: The best solution would be to have our own buffer type around\n//       Uint8Array which is standard.\n\nfunction eob() {\n    throw new Error('unexpected end of buffer');\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param num number\n * @returns Buffer\n */\nfunction safeRead(pipe, num) {\n    if (pipe.byteLength < num) {\n        eob();\n    }\n    return pipe.read(num);\n}\n/**\n * @param pipe - PipeArrayBuffer simulating buffer-pipe api\n */\nfunction safeReadUint8(pipe) {\n    const byte = pipe.readUint8();\n    if (byte === undefined) {\n        eob();\n    }\n    return byte;\n}\n/**\n * Encode a positive number (or bigint) into a Buffer. The number will be floored to the\n * nearest integer.\n * @param value The number to encode.\n */\nfunction lebEncode(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    if (value < BigInt(0)) {\n        throw new Error('Cannot leb encode negative values.');\n    }\n    const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n    const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);\n    while (true) {\n        const i = Number(value & BigInt(0x7f));\n        value /= BigInt(0x80);\n        if (value === BigInt(0)) {\n            pipe.write(new Uint8Array([i]));\n            break;\n        }\n        else {\n            pipe.write(new Uint8Array([i | 0x80]));\n        }\n    }\n    return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number will always be positive (does not\n * support signed leb encoding).\n * @param pipe A Buffer containing the leb encoded bits.\n */\nfunction lebDecode(pipe) {\n    let weight = BigInt(1);\n    let value = BigInt(0);\n    let byte;\n    do {\n        byte = safeReadUint8(pipe);\n        value += BigInt(byte & 0x7f).valueOf() * weight;\n        weight *= BigInt(128);\n    } while (byte >= 0x80);\n    return value;\n}\n/**\n * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number\n * will be floored to the nearest integer.\n * @param value The number to encode.\n */\nfunction slebEncode(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    const isNeg = value < BigInt(0);\n    if (isNeg) {\n        value = -value - BigInt(1);\n    }\n    const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n    const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);\n    while (true) {\n        const i = getLowerBytes(value);\n        value /= BigInt(0x80);\n        // prettier-ignore\n        if ((isNeg && value === BigInt(0) && (i & 0x40) !== 0)\n            || (!isNeg && value === BigInt(0) && (i & 0x40) === 0)) {\n            pipe.write(new Uint8Array([i]));\n            break;\n        }\n        else {\n            pipe.write(new Uint8Array([i | 0x80]));\n        }\n    }\n    function getLowerBytes(num) {\n        const bytes = num % BigInt(0x80);\n        if (isNeg) {\n            // We swap the bits here again, and remove 1 to do two's complement.\n            return Number(BigInt(0x80) - bytes - BigInt(1));\n        }\n        else {\n            return Number(bytes);\n        }\n    }\n    return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative\n * signed-leb encoding.\n * @param pipe A Buffer containing the signed leb encoded bits.\n */\nfunction slebDecode(pipe) {\n    // Get the size of the buffer, then cut a buffer of that size.\n    const pipeView = new Uint8Array(pipe.buffer);\n    let len = 0;\n    for (; len < pipeView.byteLength; len++) {\n        if (pipeView[len] < 0x80) {\n            // If it's a positive number, we reuse lebDecode.\n            if ((pipeView[len] & 0x40) === 0) {\n                return lebDecode(pipe);\n            }\n            break;\n        }\n    }\n    const bytes = new Uint8Array(safeRead(pipe, len + 1));\n    let value = BigInt(0);\n    for (let i = bytes.byteLength - 1; i >= 0; i--) {\n        value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);\n    }\n    return -value - BigInt(1);\n}\n/**\n *\n * @param value bigint or number\n * @param byteLength number\n * @returns Buffer\n */\nfunction writeUIntLE(value, byteLength) {\n    if (BigInt(value) < BigInt(0)) {\n        throw new Error('Cannot write negative values.');\n    }\n    return writeIntLE(value, byteLength);\n}\n/**\n *\n * @param value - bigint or number\n * @param byteLength - number\n * @returns ArrayBuffer\n */\nfunction writeIntLE(value, byteLength) {\n    value = BigInt(value);\n    const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(Math.min(1, byteLength)), 0);\n    let i = 0;\n    let mul = BigInt(256);\n    let sub = BigInt(0);\n    let byte = Number(value % mul);\n    pipe.write(new Uint8Array([byte]));\n    while (++i < byteLength) {\n        if (value < 0 && sub === BigInt(0) && byte !== 0) {\n            sub = BigInt(1);\n        }\n        byte = Number((value / mul - sub) % BigInt(256));\n        pipe.write(new Uint8Array([byte]));\n        mul *= BigInt(256);\n    }\n    return pipe.buffer;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nfunction readUIntLE(pipe, byteLength) {\n    let val = BigInt(safeReadUint8(pipe));\n    let mul = BigInt(1);\n    let i = 0;\n    while (++i < byteLength) {\n        mul *= BigInt(256);\n        const byte = BigInt(safeReadUint8(pipe));\n        val = val + mul * byte;\n    }\n    return val;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nfunction readIntLE(pipe, byteLength) {\n    let val = readUIntLE(pipe, byteLength);\n    const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));\n    if (val >= mul) {\n        val -= mul * BigInt(2);\n    }\n    return val;\n}\n//# sourceMappingURL=leb128.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrY2FuZGlkQDIuMS4zX0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vdXRpbHMvbGViMTI4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFCQUFxQixvREFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K2NhbmRpZEAyLjEuM19AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2xlYjEyOC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zdGFudC1jb25kaXRpb24gKi9cbi8vIE5vdGU6IHRoaXMgZmlsZSB1c2VzIGJ1ZmZlci1waXBlLCB3aGljaCBvbiBOb2RlIG9ubHksIHVzZXMgdGhlIE5vZGUgQnVmZmVyXG4vLyAgICAgICBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXNuJ3QgY29tcGF0aWJsZSB3aXRoIHRoZSBOUE0gYnVmZmVyIHBhY2thZ2Vcbi8vICAgICAgIHdoaWNoIHdlIHVzZSBldmVyeXdoZXJlIGVsc2UuIFRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvIHRyYW5zZm9ybVxuLy8gICAgICAgb25lIGludG8gdGhlIG90aGVyLCBoZW5jZSB3aHkgZXZlcnkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgQnVmZmVyXG4vLyAgICAgICBhY3R1YWxseSByZXR1cm4gYG5ldyBCdWZmZXIocGlwZS5idWZmZXIpYC5cbi8vIFRPRE86IFRoZSBiZXN0IHNvbHV0aW9uIHdvdWxkIGJlIHRvIGhhdmUgb3VyIG93biBidWZmZXIgdHlwZSBhcm91bmRcbi8vICAgICAgIFVpbnQ4QXJyYXkgd2hpY2ggaXMgc3RhbmRhcmQuXG5pbXBvcnQgeyBQaXBlQXJyYXlCdWZmZXIgYXMgUGlwZSB9IGZyb20gJy4vYnVmZmVyJztcbmZ1bmN0aW9uIGVvYigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGJ1ZmZlcicpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHBpcGUgUGlwZSBmcm9tIGJ1ZmZlci1waXBlXG4gKiBAcGFyYW0gbnVtIG51bWJlclxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlUmVhZChwaXBlLCBudW0pIHtcbiAgICBpZiAocGlwZS5ieXRlTGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIGVvYigpO1xuICAgIH1cbiAgICByZXR1cm4gcGlwZS5yZWFkKG51bSk7XG59XG4vKipcbiAqIEBwYXJhbSBwaXBlIC0gUGlwZUFycmF5QnVmZmVyIHNpbXVsYXRpbmcgYnVmZmVyLXBpcGUgYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlUmVhZFVpbnQ4KHBpcGUpIHtcbiAgICBjb25zdCBieXRlID0gcGlwZS5yZWFkVWludDgoKTtcbiAgICBpZiAoYnl0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVvYigpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZTtcbn1cbi8qKlxuICogRW5jb2RlIGEgcG9zaXRpdmUgbnVtYmVyIChvciBiaWdpbnQpIGludG8gYSBCdWZmZXIuIFRoZSBudW1iZXIgd2lsbCBiZSBmbG9vcmVkIHRvIHRoZVxuICogbmVhcmVzdCBpbnRlZ2VyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdG8gZW5jb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGViRW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBCaWdJbnQoMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbGViIGVuY29kZSBuZWdhdGl2ZSB2YWx1ZXMuJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSAodmFsdWUgPT09IEJpZ0ludCgwKSA/IDAgOiBNYXRoLmNlaWwoTWF0aC5sb2cyKE51bWJlcih2YWx1ZSkpKSkgKyAxO1xuICAgIGNvbnN0IHBpcGUgPSBuZXcgUGlwZShuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCksIDApO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHg3ZikpO1xuICAgICAgICB2YWx1ZSAvPSBCaWdJbnQoMHg4MCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICBwaXBlLndyaXRlKG5ldyBVaW50OEFycmF5KFtpXSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwaXBlLndyaXRlKG5ldyBVaW50OEFycmF5KFtpIHwgMHg4MF0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGlwZS5idWZmZXI7XG59XG4vKipcbiAqIERlY29kZSBhIGxlYiBlbmNvZGVkIGJ1ZmZlciBpbnRvIGEgYmlnaW50LiBUaGUgbnVtYmVyIHdpbGwgYWx3YXlzIGJlIHBvc2l0aXZlIChkb2VzIG5vdFxuICogc3VwcG9ydCBzaWduZWQgbGViIGVuY29kaW5nKS5cbiAqIEBwYXJhbSBwaXBlIEEgQnVmZmVyIGNvbnRhaW5pbmcgdGhlIGxlYiBlbmNvZGVkIGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWJEZWNvZGUocGlwZSkge1xuICAgIGxldCB3ZWlnaHQgPSBCaWdJbnQoMSk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGxldCBieXRlO1xuICAgIGRvIHtcbiAgICAgICAgYnl0ZSA9IHNhZmVSZWFkVWludDgocGlwZSk7XG4gICAgICAgIHZhbHVlICs9IEJpZ0ludChieXRlICYgMHg3ZikudmFsdWVPZigpICogd2VpZ2h0O1xuICAgICAgICB3ZWlnaHQgKj0gQmlnSW50KDEyOCk7XG4gICAgfSB3aGlsZSAoYnl0ZSA+PSAweDgwKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZSBhIG51bWJlciAob3IgYmlnaW50KSBpbnRvIGEgQnVmZmVyLCB3aXRoIHN1cHBvcnQgZm9yIG5lZ2F0aXZlIG51bWJlcnMuIFRoZSBudW1iZXJcbiAqIHdpbGwgYmUgZmxvb3JlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdG8gZW5jb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xlYkVuY29kZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgaXNOZWcgPSB2YWx1ZSA8IEJpZ0ludCgwKTtcbiAgICBpZiAoaXNOZWcpIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWUgLSBCaWdJbnQoMSk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSAodmFsdWUgPT09IEJpZ0ludCgwKSA/IDAgOiBNYXRoLmNlaWwoTWF0aC5sb2cyKE51bWJlcih2YWx1ZSkpKSkgKyAxO1xuICAgIGNvbnN0IHBpcGUgPSBuZXcgUGlwZShuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCksIDApO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBnZXRMb3dlckJ5dGVzKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgLz0gQmlnSW50KDB4ODApO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKChpc05lZyAmJiB2YWx1ZSA9PT0gQmlnSW50KDApICYmIChpICYgMHg0MCkgIT09IDApXG4gICAgICAgICAgICB8fCAoIWlzTmVnICYmIHZhbHVlID09PSBCaWdJbnQoMCkgJiYgKGkgJiAweDQwKSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHBpcGUud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2ldKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBpcGUud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2kgfCAweDgwXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExvd2VyQnl0ZXMobnVtKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbnVtICUgQmlnSW50KDB4ODApO1xuICAgICAgICBpZiAoaXNOZWcpIHtcbiAgICAgICAgICAgIC8vIFdlIHN3YXAgdGhlIGJpdHMgaGVyZSBhZ2FpbiwgYW5kIHJlbW92ZSAxIHRvIGRvIHR3bydzIGNvbXBsZW1lbnQuXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKEJpZ0ludCgweDgwKSAtIGJ5dGVzIC0gQmlnSW50KDEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwaXBlLmJ1ZmZlcjtcbn1cbi8qKlxuICogRGVjb2RlIGEgbGViIGVuY29kZWQgYnVmZmVyIGludG8gYSBiaWdpbnQuIFRoZSBudW1iZXIgaXMgZGVjb2RlZCB3aXRoIHN1cHBvcnQgZm9yIG5lZ2F0aXZlXG4gKiBzaWduZWQtbGViIGVuY29kaW5nLlxuICogQHBhcmFtIHBpcGUgQSBCdWZmZXIgY29udGFpbmluZyB0aGUgc2lnbmVkIGxlYiBlbmNvZGVkIGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGViRGVjb2RlKHBpcGUpIHtcbiAgICAvLyBHZXQgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlciwgdGhlbiBjdXQgYSBidWZmZXIgb2YgdGhhdCBzaXplLlxuICAgIGNvbnN0IHBpcGVWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocGlwZS5idWZmZXIpO1xuICAgIGxldCBsZW4gPSAwO1xuICAgIGZvciAoOyBsZW4gPCBwaXBlVmlldy5ieXRlTGVuZ3RoOyBsZW4rKykge1xuICAgICAgICBpZiAocGlwZVZpZXdbbGVuXSA8IDB4ODApIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgYSBwb3NpdGl2ZSBudW1iZXIsIHdlIHJldXNlIGxlYkRlY29kZS5cbiAgICAgICAgICAgIGlmICgocGlwZVZpZXdbbGVuXSAmIDB4NDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlYkRlY29kZShwaXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2FmZVJlYWQocGlwZSwgbGVuICsgMSkpO1xuICAgIGxldCB2YWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gYnl0ZXMuYnl0ZUxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgKiBCaWdJbnQoMHg4MCkgKyBCaWdJbnQoMHg4MCAtIChieXRlc1tpXSAmIDB4N2YpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiAtdmFsdWUgLSBCaWdJbnQoMSk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdmFsdWUgYmlnaW50IG9yIG51bWJlclxuICogQHBhcmFtIGJ5dGVMZW5ndGggbnVtYmVyXG4gKiBAcmV0dXJucyBCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlVUludExFKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgaWYgKEJpZ0ludCh2YWx1ZSkgPCBCaWdJbnQoMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgd3JpdGUgbmVnYXRpdmUgdmFsdWVzLicpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVJbnRMRSh2YWx1ZSwgYnl0ZUxlbmd0aCk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBiaWdpbnQgb3IgbnVtYmVyXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCAtIG51bWJlclxuICogQHJldHVybnMgQXJyYXlCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlSW50TEUodmFsdWUsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgY29uc3QgcGlwZSA9IG5ldyBQaXBlKG5ldyBBcnJheUJ1ZmZlcihNYXRoLm1pbigxLCBieXRlTGVuZ3RoKSksIDApO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbXVsID0gQmlnSW50KDI1Nik7XG4gICAgbGV0IHN1YiA9IEJpZ0ludCgwKTtcbiAgICBsZXQgYnl0ZSA9IE51bWJlcih2YWx1ZSAlIG11bCk7XG4gICAgcGlwZS53cml0ZShuZXcgVWludDhBcnJheShbYnl0ZV0pKTtcbiAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCkge1xuICAgICAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gQmlnSW50KDApICYmIGJ5dGUgIT09IDApIHtcbiAgICAgICAgICAgIHN1YiA9IEJpZ0ludCgxKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlID0gTnVtYmVyKCh2YWx1ZSAvIG11bCAtIHN1YikgJSBCaWdJbnQoMjU2KSk7XG4gICAgICAgIHBpcGUud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2J5dGVdKSk7XG4gICAgICAgIG11bCAqPSBCaWdJbnQoMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIHBpcGUuYnVmZmVyO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHBpcGUgUGlwZSBmcm9tIGJ1ZmZlci1waXBlXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCBudW1iZXJcbiAqIEByZXR1cm5zIGJpZ2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZFVJbnRMRShwaXBlLCBieXRlTGVuZ3RoKSB7XG4gICAgbGV0IHZhbCA9IEJpZ0ludChzYWZlUmVhZFVpbnQ4KHBpcGUpKTtcbiAgICBsZXQgbXVsID0gQmlnSW50KDEpO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCkge1xuICAgICAgICBtdWwgKj0gQmlnSW50KDI1Nik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBCaWdJbnQoc2FmZVJlYWRVaW50OChwaXBlKSk7XG4gICAgICAgIHZhbCA9IHZhbCArIG11bCAqIGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gcGlwZSBQaXBlIGZyb20gYnVmZmVyLXBpcGVcbiAqIEBwYXJhbSBieXRlTGVuZ3RoIG51bWJlclxuICogQHJldHVybnMgYmlnaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkSW50TEUocGlwZSwgYnl0ZUxlbmd0aCkge1xuICAgIGxldCB2YWwgPSByZWFkVUludExFKHBpcGUsIGJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IG11bCA9IEJpZ0ludCgyKSAqKiAoQmlnSW50KDgpICogQmlnSW50KGJ5dGVMZW5ndGggLSAxKSArIEJpZ0ludCg3KSk7XG4gICAgaWYgKHZhbCA+PSBtdWwpIHtcbiAgICAgICAgdmFsIC09IG11bCAqIEJpZ0ludCgyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYjEyOC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+candid@2.1.3_@dfinity+principal@2.1.3/node_modules/@dfinity/candid/lib/esm/utils/leb128.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSON_KEY_PRINCIPAL: () => (/* binding */ JSON_KEY_PRINCIPAL),\n/* harmony export */   Principal: () => (/* binding */ Principal)\n/* harmony export */ });\n/* harmony import */ var _utils_base32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/base32 */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/base32.js\");\n/* harmony import */ var _utils_getCrc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/getCrc */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js\");\n/* harmony import */ var _utils_sha224__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/sha224 */ \"./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/sha224.js\");\n\n\n\nconst JSON_KEY_PRINCIPAL = '__principal__';\nconst SELF_AUTHENTICATING_SUFFIX = 2;\nconst ANONYMOUS_SUFFIX = 4;\nconst MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR = 'aaaaa-aa';\nconst fromHexString = (hexString) => { var _a; return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16))); };\nconst toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\nclass Principal {\n    constructor(_arr) {\n        this._arr = _arr;\n        this._isPrincipal = true;\n    }\n    static anonymous() {\n        return new this(new Uint8Array([ANONYMOUS_SUFFIX]));\n    }\n    /**\n     * Utility method, returning the principal representing the management canister, decoded from the hex string `'aaaaa-aa'`\n     * @returns {Principal} principal of the management canister\n     */\n    static managementCanister() {\n        return this.fromHex(MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR);\n    }\n    static selfAuthenticating(publicKey) {\n        const sha = (0,_utils_sha224__WEBPACK_IMPORTED_MODULE_2__.sha224)(publicKey);\n        return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));\n    }\n    static from(other) {\n        if (typeof other === 'string') {\n            return Principal.fromText(other);\n        }\n        else if (Object.getPrototypeOf(other) === Uint8Array.prototype) {\n            return new Principal(other);\n        }\n        else if (typeof other === 'object' &&\n            other !== null &&\n            other._isPrincipal === true) {\n            return new Principal(other._arr);\n        }\n        throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);\n    }\n    static fromHex(hex) {\n        return new this(fromHexString(hex));\n    }\n    static fromText(text) {\n        let maybePrincipal = text;\n        // If formatted as JSON string, parse it first\n        if (text.includes(JSON_KEY_PRINCIPAL)) {\n            const obj = JSON.parse(text);\n            if (JSON_KEY_PRINCIPAL in obj) {\n                maybePrincipal = obj[JSON_KEY_PRINCIPAL];\n            }\n        }\n        const canisterIdNoDash = maybePrincipal.toLowerCase().replace(/-/g, '');\n        let arr = (0,_utils_base32__WEBPACK_IMPORTED_MODULE_0__.decode)(canisterIdNoDash);\n        arr = arr.slice(4, arr.length);\n        const principal = new this(arr);\n        if (principal.toText() !== maybePrincipal) {\n            throw new Error(`Principal \"${principal.toText()}\" does not have a valid checksum (original value \"${maybePrincipal}\" may not be a valid Principal ID).`);\n        }\n        return principal;\n    }\n    static fromUint8Array(arr) {\n        return new this(arr);\n    }\n    isAnonymous() {\n        return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;\n    }\n    toUint8Array() {\n        return this._arr;\n    }\n    toHex() {\n        return toHexString(this._arr).toUpperCase();\n    }\n    toText() {\n        const checksumArrayBuf = new ArrayBuffer(4);\n        const view = new DataView(checksumArrayBuf);\n        view.setUint32(0, (0,_utils_getCrc__WEBPACK_IMPORTED_MODULE_1__.getCrc32)(this._arr));\n        const checksum = new Uint8Array(checksumArrayBuf);\n        const bytes = Uint8Array.from(this._arr);\n        const array = new Uint8Array([...checksum, ...bytes]);\n        const result = (0,_utils_base32__WEBPACK_IMPORTED_MODULE_0__.encode)(array);\n        const matches = result.match(/.{1,5}/g);\n        if (!matches) {\n            // This should only happen if there's no character, which is unreachable.\n            throw new Error();\n        }\n        return matches.join('-');\n    }\n    toString() {\n        return this.toText();\n    }\n    /**\n     * Serializes to JSON\n     * @returns {JsonnablePrincipal} a JSON object with a single key, {@link JSON_KEY_PRINCIPAL}, whose value is the principal as a string\n     */\n    toJSON() {\n        return { [JSON_KEY_PRINCIPAL]: this.toText() };\n    }\n    /**\n     * Utility method taking a Principal to compare against. Used for determining canister ranges in certificate verification\n     * @param {Principal} other - a {@link Principal} to compare\n     * @returns {'lt' | 'eq' | 'gt'} `'lt' | 'eq' | 'gt'` a string, representing less than, equal to, or greater than\n     */\n    compareTo(other) {\n        for (let i = 0; i < Math.min(this._arr.length, other._arr.length); i++) {\n            if (this._arr[i] < other._arr[i])\n                return 'lt';\n            else if (this._arr[i] > other._arr[i])\n                return 'gt';\n        }\n        // Here, at least one principal is a prefix of the other principal (they could be the same)\n        if (this._arr.length < other._arr.length)\n            return 'lt';\n        if (this._arr.length > other._arr.length)\n            return 'gt';\n        return 'eq';\n    }\n    /**\n     * Utility method checking whether a provided Principal is less than or equal to the current one using the {@link Principal.compareTo} method\n     * @param other a {@link Principal} to compare\n     * @returns {boolean} boolean\n     */\n    ltEq(other) {\n        const cmp = this.compareTo(other);\n        return cmp == 'lt' || cmp == 'eq';\n    }\n    /**\n     * Utility method checking whether a provided Principal is greater than or equal to the current one using the {@link Principal.compareTo} method\n     * @param other a {@link Principal} to compare\n     * @returns {boolean} boolean\n     */\n    gtEq(other) {\n        const cmp = this.compareTo(other);\n        return cmp == 'gt' || cmp == 'eq';\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnRDtBQUNOO0FBQ0Y7QUFDakM7QUFDUDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUSxnREFBZ0QsSUFBSTtBQUNuRztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUIsb0RBQW9ELGVBQWU7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBTTtBQUM3Qix3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQixrQ0FBa0MseUJBQXlCO0FBQ2hHO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXLFdBQVcsaUJBQWlCO0FBQ3RELGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBLHdCQUF3QixtREFBbUQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsMkJBQTJCO0FBQzNJLHVCQUF1QixpQkFBaUI7QUFDeEMsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1ILDJCQUEyQjtBQUM5SSx1QkFBdUIsaUJBQWlCO0FBQ3hDLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvcHJpbmNpcGFsL2xpYi9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVjb2RlLCBlbmNvZGUgfSBmcm9tICcuL3V0aWxzL2Jhc2UzMic7XG5pbXBvcnQgeyBnZXRDcmMzMiB9IGZyb20gJy4vdXRpbHMvZ2V0Q3JjJztcbmltcG9ydCB7IHNoYTIyNCB9IGZyb20gJy4vdXRpbHMvc2hhMjI0JztcbmV4cG9ydCBjb25zdCBKU09OX0tFWV9QUklOQ0lQQUwgPSAnX19wcmluY2lwYWxfXyc7XG5jb25zdCBTRUxGX0FVVEhFTlRJQ0FUSU5HX1NVRkZJWCA9IDI7XG5jb25zdCBBTk9OWU1PVVNfU1VGRklYID0gNDtcbmNvbnN0IE1BTkFHRU1FTlRfQ0FOSVNURVJfUFJJTkNJUEFMX0hFWF9TVFIgPSAnYWFhYWEtYWEnO1xuY29uc3QgZnJvbUhleFN0cmluZyA9IChoZXhTdHJpbmcpID0+IHsgdmFyIF9hOyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKChfYSA9IGhleFN0cmluZy5tYXRjaCgvLnsxLDJ9L2cpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkubWFwKGJ5dGUgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSk7IH07XG5jb25zdCB0b0hleFN0cmluZyA9IChieXRlcykgPT4gYnl0ZXMucmVkdWNlKChzdHIsIGJ5dGUpID0+IHN0ciArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyksICcnKTtcbmV4cG9ydCBjbGFzcyBQcmluY2lwYWwge1xuICAgIGNvbnN0cnVjdG9yKF9hcnIpIHtcbiAgICAgICAgdGhpcy5fYXJyID0gX2FycjtcbiAgICAgICAgdGhpcy5faXNQcmluY2lwYWwgPSB0cnVlO1xuICAgIH1cbiAgICBzdGF0aWMgYW5vbnltb3VzKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMobmV3IFVpbnQ4QXJyYXkoW0FOT05ZTU9VU19TVUZGSVhdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kLCByZXR1cm5pbmcgdGhlIHByaW5jaXBhbCByZXByZXNlbnRpbmcgdGhlIG1hbmFnZW1lbnQgY2FuaXN0ZXIsIGRlY29kZWQgZnJvbSB0aGUgaGV4IHN0cmluZyBgJ2FhYWFhLWFhJ2BcbiAgICAgKiBAcmV0dXJucyB7UHJpbmNpcGFsfSBwcmluY2lwYWwgb2YgdGhlIG1hbmFnZW1lbnQgY2FuaXN0ZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgbWFuYWdlbWVudENhbmlzdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSGV4KE1BTkFHRU1FTlRfQ0FOSVNURVJfUFJJTkNJUEFMX0hFWF9TVFIpO1xuICAgIH1cbiAgICBzdGF0aWMgc2VsZkF1dGhlbnRpY2F0aW5nKHB1YmxpY0tleSkge1xuICAgICAgICBjb25zdCBzaGEgPSBzaGEyMjQocHVibGljS2V5KTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG5ldyBVaW50OEFycmF5KFsuLi5zaGEsIFNFTEZfQVVUSEVOVElDQVRJTkdfU1VGRklYXSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShvdGhlcikge1xuICAgICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFByaW5jaXBhbC5mcm9tVGV4dChvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG90aGVyKSA9PT0gVWludDhBcnJheS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJpbmNpcGFsKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBvdGhlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgb3RoZXIuX2lzUHJpbmNpcGFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByaW5jaXBhbChvdGhlci5fYXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltcG9zc2libGUgdG8gY29udmVydCAke0pTT04uc3RyaW5naWZ5KG90aGVyKX0gdG8gUHJpbmNpcGFsLmApO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGZyb21IZXhTdHJpbmcoaGV4KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVGV4dCh0ZXh0KSB7XG4gICAgICAgIGxldCBtYXliZVByaW5jaXBhbCA9IHRleHQ7XG4gICAgICAgIC8vIElmIGZvcm1hdHRlZCBhcyBKU09OIHN0cmluZywgcGFyc2UgaXQgZmlyc3RcbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoSlNPTl9LRVlfUFJJTkNJUEFMKSkge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChKU09OX0tFWV9QUklOQ0lQQUwgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcmluY2lwYWwgPSBvYmpbSlNPTl9LRVlfUFJJTkNJUEFMXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5pc3RlcklkTm9EYXNoID0gbWF5YmVQcmluY2lwYWwudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tL2csICcnKTtcbiAgICAgICAgbGV0IGFyciA9IGRlY29kZShjYW5pc3RlcklkTm9EYXNoKTtcbiAgICAgICAgYXJyID0gYXJyLnNsaWNlKDQsIGFyci5sZW5ndGgpO1xuICAgICAgICBjb25zdCBwcmluY2lwYWwgPSBuZXcgdGhpcyhhcnIpO1xuICAgICAgICBpZiAocHJpbmNpcGFsLnRvVGV4dCgpICE9PSBtYXliZVByaW5jaXBhbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmluY2lwYWwgXCIke3ByaW5jaXBhbC50b1RleHQoKX1cIiBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgY2hlY2tzdW0gKG9yaWdpbmFsIHZhbHVlIFwiJHttYXliZVByaW5jaXBhbH1cIiBtYXkgbm90IGJlIGEgdmFsaWQgUHJpbmNpcGFsIElEKS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpbmNpcGFsO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVVpbnQ4QXJyYXkoYXJyKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhhcnIpO1xuICAgIH1cbiAgICBpc0Fub255bW91cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fyci5ieXRlTGVuZ3RoID09PSAxICYmIHRoaXMuX2FyclswXSA9PT0gQU5PTllNT1VTX1NVRkZJWDtcbiAgICB9XG4gICAgdG9VaW50OEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJyO1xuICAgIH1cbiAgICB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4U3RyaW5nKHRoaXMuX2FycikudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgdG9UZXh0KCkge1xuICAgICAgICBjb25zdCBjaGVja3N1bUFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGNoZWNrc3VtQXJyYXlCdWYpO1xuICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBnZXRDcmMzMih0aGlzLl9hcnIpKTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBuZXcgVWludDhBcnJheShjaGVja3N1bUFycmF5QnVmKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBVaW50OEFycmF5LmZyb20odGhpcy5fYXJyKTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShbLi4uY2hlY2tzdW0sIC4uLmJ5dGVzXSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGVuY29kZShhcnJheSk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSByZXN1bHQubWF0Y2goLy57MSw1fS9nKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSdzIG5vIGNoYXJhY3Rlciwgd2hpY2ggaXMgdW5yZWFjaGFibGUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hlcy5qb2luKCctJyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1RleHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0byBKU09OXG4gICAgICogQHJldHVybnMge0pzb25uYWJsZVByaW5jaXBhbH0gYSBKU09OIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleSwge0BsaW5rIEpTT05fS0VZX1BSSU5DSVBBTH0sIHdob3NlIHZhbHVlIGlzIHRoZSBwcmluY2lwYWwgYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IFtKU09OX0tFWV9QUklOQ0lQQUxdOiB0aGlzLnRvVGV4dCgpIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kIHRha2luZyBhIFByaW5jaXBhbCB0byBjb21wYXJlIGFnYWluc3QuIFVzZWQgZm9yIGRldGVybWluaW5nIGNhbmlzdGVyIHJhbmdlcyBpbiBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb25cbiAgICAgKiBAcGFyYW0ge1ByaW5jaXBhbH0gb3RoZXIgLSBhIHtAbGluayBQcmluY2lwYWx9IHRvIGNvbXBhcmVcbiAgICAgKiBAcmV0dXJucyB7J2x0JyB8ICdlcScgfCAnZ3QnfSBgJ2x0JyB8ICdlcScgfCAnZ3QnYCBhIHN0cmluZywgcmVwcmVzZW50aW5nIGxlc3MgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhblxuICAgICAqL1xuICAgIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKHRoaXMuX2Fyci5sZW5ndGgsIG90aGVyLl9hcnIubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXJyW2ldIDwgb3RoZXIuX2FycltpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2x0JztcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2FycltpXSA+IG90aGVyLl9hcnJbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuICdndCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGVyZSwgYXQgbGVhc3Qgb25lIHByaW5jaXBhbCBpcyBhIHByZWZpeCBvZiB0aGUgb3RoZXIgcHJpbmNpcGFsICh0aGV5IGNvdWxkIGJlIHRoZSBzYW1lKVxuICAgICAgICBpZiAodGhpcy5fYXJyLmxlbmd0aCA8IG90aGVyLl9hcnIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuICdsdCc7XG4gICAgICAgIGlmICh0aGlzLl9hcnIubGVuZ3RoID4gb3RoZXIuX2Fyci5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gJ2d0JztcbiAgICAgICAgcmV0dXJuICdlcSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kIGNoZWNraW5nIHdoZXRoZXIgYSBwcm92aWRlZCBQcmluY2lwYWwgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBjdXJyZW50IG9uZSB1c2luZyB0aGUge0BsaW5rIFByaW5jaXBhbC5jb21wYXJlVG99IG1ldGhvZFxuICAgICAqIEBwYXJhbSBvdGhlciBhIHtAbGluayBQcmluY2lwYWx9IHRvIGNvbXBhcmVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhblxuICAgICAqL1xuICAgIGx0RXEob3RoZXIpIHtcbiAgICAgICAgY29uc3QgY21wID0gdGhpcy5jb21wYXJlVG8ob3RoZXIpO1xuICAgICAgICByZXR1cm4gY21wID09ICdsdCcgfHwgY21wID09ICdlcSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kIGNoZWNraW5nIHdoZXRoZXIgYSBwcm92aWRlZCBQcmluY2lwYWwgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBjdXJyZW50IG9uZSB1c2luZyB0aGUge0BsaW5rIFByaW5jaXBhbC5jb21wYXJlVG99IG1ldGhvZFxuICAgICAqIEBwYXJhbSBvdGhlciBhIHtAbGluayBQcmluY2lwYWx9IHRvIGNvbXBhcmVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYm9vbGVhblxuICAgICAqL1xuICAgIGd0RXEob3RoZXIpIHtcbiAgICAgICAgY29uc3QgY21wID0gdGhpcy5jb21wYXJlVG8ob3RoZXIpO1xuICAgICAgICByZXR1cm4gY21wID09ICdndCcgfHwgY21wID09ICdlcSc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/base32.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/base32.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\nconst alphabet = 'abcdefghijklmnopqrstuvwxyz234567';\n// Build a lookup table for decoding.\nconst lookupTable = Object.create(null);\nfor (let i = 0; i < alphabet.length; i++) {\n    lookupTable[alphabet[i]] = i;\n}\n// Add aliases for rfc4648.\nlookupTable['0'] = lookupTable.o;\nlookupTable['1'] = lookupTable.i;\n/**\n * @param input The input array to encode.\n * @returns A Base32 string encoding the input.\n */\nfunction encode(input) {\n    // How many bits will we skip from the first byte.\n    let skip = 0;\n    // 5 high bits, carry from one byte to the next.\n    let bits = 0;\n    // The output string in base32.\n    let output = '';\n    function encodeByte(byte) {\n        if (skip < 0) {\n            // we have a carry from the previous byte\n            bits |= byte >> -skip;\n        }\n        else {\n            // no carry\n            bits = (byte << skip) & 248;\n        }\n        if (skip > 3) {\n            // Not enough data to produce a character, get us another one\n            skip -= 8;\n            return 1;\n        }\n        if (skip < 4) {\n            // produce a character\n            output += alphabet[bits >> 3];\n            skip += 5;\n        }\n        return 0;\n    }\n    for (let i = 0; i < input.length;) {\n        i += encodeByte(input[i]);\n    }\n    return output + (skip < 0 ? alphabet[bits >> 3] : '');\n}\n/**\n * @param input The base32 encoded string to decode.\n */\nfunction decode(input) {\n    // how many bits we have from the previous character.\n    let skip = 0;\n    // current byte we're producing.\n    let byte = 0;\n    const output = new Uint8Array(((input.length * 4) / 3) | 0);\n    let o = 0;\n    function decodeChar(char) {\n        // Consume a character from the stream, store\n        // the output in this.output. As before, better\n        // to use update().\n        let val = lookupTable[char.toLowerCase()];\n        if (val === undefined) {\n            throw new Error(`Invalid character: ${JSON.stringify(char)}`);\n        }\n        // move to the high bits\n        val <<= 3;\n        byte |= val >>> skip;\n        skip += 5;\n        if (skip >= 8) {\n            // We have enough bytes to produce an output\n            output[o++] = byte;\n            skip -= 8;\n            if (skip > 0) {\n                byte = (val << (5 - skip)) & 255;\n            }\n            else {\n                byte = 0;\n            }\n        }\n    }\n    for (const c of input) {\n        decodeChar(c);\n    }\n    return output.slice(0, o);\n}\n//# sourceMappingURL=base32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9iYXNlMzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0BkZmluaXR5K3ByaW5jaXBhbEAyLjEuMy9ub2RlX21vZHVsZXMvQGRmaW5pdHkvcHJpbmNpcGFsL2xpYi9lc20vdXRpbHMvYmFzZTMyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3Jztcbi8vIEJ1aWxkIGEgbG9va3VwIHRhYmxlIGZvciBkZWNvZGluZy5cbmNvbnN0IGxvb2t1cFRhYmxlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBUYWJsZVthbHBoYWJldFtpXV0gPSBpO1xufVxuLy8gQWRkIGFsaWFzZXMgZm9yIHJmYzQ2NDguXG5sb29rdXBUYWJsZVsnMCddID0gbG9va3VwVGFibGUubztcbmxvb2t1cFRhYmxlWycxJ10gPSBsb29rdXBUYWJsZS5pO1xuLyoqXG4gKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIEEgQmFzZTMyIHN0cmluZyBlbmNvZGluZyB0aGUgaW5wdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICAvLyBIb3cgbWFueSBiaXRzIHdpbGwgd2Ugc2tpcCBmcm9tIHRoZSBmaXJzdCBieXRlLlxuICAgIGxldCBza2lwID0gMDtcbiAgICAvLyA1IGhpZ2ggYml0cywgY2FycnkgZnJvbSBvbmUgYnl0ZSB0byB0aGUgbmV4dC5cbiAgICBsZXQgYml0cyA9IDA7XG4gICAgLy8gVGhlIG91dHB1dCBzdHJpbmcgaW4gYmFzZTMyLlxuICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICBmdW5jdGlvbiBlbmNvZGVCeXRlKGJ5dGUpIHtcbiAgICAgICAgaWYgKHNraXAgPCAwKSB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGEgY2FycnkgZnJvbSB0aGUgcHJldmlvdXMgYnl0ZVxuICAgICAgICAgICAgYml0cyB8PSBieXRlID4+IC1za2lwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gY2FycnlcbiAgICAgICAgICAgIGJpdHMgPSAoYnl0ZSA8PCBza2lwKSAmIDI0ODtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcCA+IDMpIHtcbiAgICAgICAgICAgIC8vIE5vdCBlbm91Z2ggZGF0YSB0byBwcm9kdWNlIGEgY2hhcmFjdGVyLCBnZXQgdXMgYW5vdGhlciBvbmVcbiAgICAgICAgICAgIHNraXAgLT0gODtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwIDwgNCkge1xuICAgICAgICAgICAgLy8gcHJvZHVjZSBhIGNoYXJhY3RlclxuICAgICAgICAgICAgb3V0cHV0ICs9IGFscGhhYmV0W2JpdHMgPj4gM107XG4gICAgICAgICAgICBza2lwICs9IDU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBpICs9IGVuY29kZUJ5dGUoaW5wdXRbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0ICsgKHNraXAgPCAwID8gYWxwaGFiZXRbYml0cyA+PiAzXSA6ICcnKTtcbn1cbi8qKlxuICogQHBhcmFtIGlucHV0IFRoZSBiYXNlMzIgZW5jb2RlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gICAgLy8gaG93IG1hbnkgYml0cyB3ZSBoYXZlIGZyb20gdGhlIHByZXZpb3VzIGNoYXJhY3Rlci5cbiAgICBsZXQgc2tpcCA9IDA7XG4gICAgLy8gY3VycmVudCBieXRlIHdlJ3JlIHByb2R1Y2luZy5cbiAgICBsZXQgYnl0ZSA9IDA7XG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoKChpbnB1dC5sZW5ndGggKiA0KSAvIDMpIHwgMCk7XG4gICAgbGV0IG8gPSAwO1xuICAgIGZ1bmN0aW9uIGRlY29kZUNoYXIoY2hhcikge1xuICAgICAgICAvLyBDb25zdW1lIGEgY2hhcmFjdGVyIGZyb20gdGhlIHN0cmVhbSwgc3RvcmVcbiAgICAgICAgLy8gdGhlIG91dHB1dCBpbiB0aGlzLm91dHB1dC4gQXMgYmVmb3JlLCBiZXR0ZXJcbiAgICAgICAgLy8gdG8gdXNlIHVwZGF0ZSgpLlxuICAgICAgICBsZXQgdmFsID0gbG9va3VwVGFibGVbY2hhci50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyOiAke0pTT04uc3RyaW5naWZ5KGNoYXIpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vdmUgdG8gdGhlIGhpZ2ggYml0c1xuICAgICAgICB2YWwgPDw9IDM7XG4gICAgICAgIGJ5dGUgfD0gdmFsID4+PiBza2lwO1xuICAgICAgICBza2lwICs9IDU7XG4gICAgICAgIGlmIChza2lwID49IDgpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZW5vdWdoIGJ5dGVzIHRvIHByb2R1Y2UgYW4gb3V0cHV0XG4gICAgICAgICAgICBvdXRwdXRbbysrXSA9IGJ5dGU7XG4gICAgICAgICAgICBza2lwIC09IDg7XG4gICAgICAgICAgICBpZiAoc2tpcCA+IDApIHtcbiAgICAgICAgICAgICAgICBieXRlID0gKHZhbCA8PCAoNSAtIHNraXApKSAmIDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ5dGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgYyBvZiBpbnB1dCkge1xuICAgICAgICBkZWNvZGVDaGFyKGMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LnNsaWNlKDAsIG8pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTMyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/base32.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCrc32: () => (/* binding */ getCrc32)\n/* harmony export */ });\n// This file is translated to JavaScript from\n// https://lxp32.github.io/docs/a-simple-example-crc32-calculation/\nconst lookUpTable = new Uint32Array([\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n]);\n/**\n * Calculate the CRC32 of an ArrayBufferLike.\n * @param buf The BufferLike to calculate the CRC32 of.\n */\nfunction getCrc32(buf) {\n    const b = new Uint8Array(buf);\n    let crc = -1;\n    for (let i = 0; i < b.length; i++) {\n        const byte = b[i];\n        const t = (byte ^ crc) & 0xff;\n        crc = lookUpTable[t] ^ (crc >>> 8);\n    }\n    return (crc ^ -1) >>> 0;\n}\n//# sourceMappingURL=getCrc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9nZXRDcmMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9nZXRDcmMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGlzIHRyYW5zbGF0ZWQgdG8gSmF2YVNjcmlwdCBmcm9tXG4vLyBodHRwczovL2x4cDMyLmdpdGh1Yi5pby9kb2NzL2Etc2ltcGxlLWV4YW1wbGUtY3JjMzItY2FsY3VsYXRpb24vXG5jb25zdCBsb29rVXBUYWJsZSA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHgwMDAwMDAwMCwgMHg3NzA3MzA5NiwgMHhlZTBlNjEyYywgMHg5OTA5NTFiYSwgMHgwNzZkYzQxOSwgMHg3MDZhZjQ4ZiwgMHhlOTYzYTUzNSwgMHg5ZTY0OTVhMyxcbiAgICAweDBlZGI4ODMyLCAweDc5ZGNiOGE0LCAweGUwZDVlOTFlLCAweDk3ZDJkOTg4LCAweDA5YjY0YzJiLCAweDdlYjE3Y2JkLCAweGU3YjgyZDA3LCAweDkwYmYxZDkxLFxuICAgIDB4MWRiNzEwNjQsIDB4NmFiMDIwZjIsIDB4ZjNiOTcxNDgsIDB4ODRiZTQxZGUsIDB4MWFkYWQ0N2QsIDB4NmRkZGU0ZWIsIDB4ZjRkNGI1NTEsIDB4ODNkMzg1YzcsXG4gICAgMHgxMzZjOTg1NiwgMHg2NDZiYThjMCwgMHhmZDYyZjk3YSwgMHg4YTY1YzllYywgMHgxNDAxNWM0ZiwgMHg2MzA2NmNkOSwgMHhmYTBmM2Q2MywgMHg4ZDA4MGRmNSxcbiAgICAweDNiNmUyMGM4LCAweDRjNjkxMDVlLCAweGQ1NjA0MWU0LCAweGEyNjc3MTcyLCAweDNjMDNlNGQxLCAweDRiMDRkNDQ3LCAweGQyMGQ4NWZkLCAweGE1MGFiNTZiLFxuICAgIDB4MzViNWE4ZmEsIDB4NDJiMjk4NmMsIDB4ZGJiYmM5ZDYsIDB4YWNiY2Y5NDAsIDB4MzJkODZjZTMsIDB4NDVkZjVjNzUsIDB4ZGNkNjBkY2YsIDB4YWJkMTNkNTksXG4gICAgMHgyNmQ5MzBhYywgMHg1MWRlMDAzYSwgMHhjOGQ3NTE4MCwgMHhiZmQwNjExNiwgMHgyMWI0ZjRiNSwgMHg1NmIzYzQyMywgMHhjZmJhOTU5OSwgMHhiOGJkYTUwZixcbiAgICAweDI4MDJiODllLCAweDVmMDU4ODA4LCAweGM2MGNkOWIyLCAweGIxMGJlOTI0LCAweDJmNmY3Yzg3LCAweDU4Njg0YzExLCAweGMxNjExZGFiLCAweGI2NjYyZDNkLFxuICAgIDB4NzZkYzQxOTAsIDB4MDFkYjcxMDYsIDB4OThkMjIwYmMsIDB4ZWZkNTEwMmEsIDB4NzFiMTg1ODksIDB4MDZiNmI1MWYsIDB4OWZiZmU0YTUsIDB4ZThiOGQ0MzMsXG4gICAgMHg3ODA3YzlhMiwgMHgwZjAwZjkzNCwgMHg5NjA5YTg4ZSwgMHhlMTBlOTgxOCwgMHg3ZjZhMGRiYiwgMHgwODZkM2QyZCwgMHg5MTY0NmM5NywgMHhlNjYzNWMwMSxcbiAgICAweDZiNmI1MWY0LCAweDFjNmM2MTYyLCAweDg1NjUzMGQ4LCAweGYyNjIwMDRlLCAweDZjMDY5NWVkLCAweDFiMDFhNTdiLCAweDgyMDhmNGMxLCAweGY1MGZjNDU3LFxuICAgIDB4NjViMGQ5YzYsIDB4MTJiN2U5NTAsIDB4OGJiZWI4ZWEsIDB4ZmNiOTg4N2MsIDB4NjJkZDFkZGYsIDB4MTVkYTJkNDksIDB4OGNkMzdjZjMsIDB4ZmJkNDRjNjUsXG4gICAgMHg0ZGIyNjE1OCwgMHgzYWI1NTFjZSwgMHhhM2JjMDA3NCwgMHhkNGJiMzBlMiwgMHg0YWRmYTU0MSwgMHgzZGQ4OTVkNywgMHhhNGQxYzQ2ZCwgMHhkM2Q2ZjRmYixcbiAgICAweDQzNjllOTZhLCAweDM0NmVkOWZjLCAweGFkNjc4ODQ2LCAweGRhNjBiOGQwLCAweDQ0MDQyZDczLCAweDMzMDMxZGU1LCAweGFhMGE0YzVmLCAweGRkMGQ3Y2M5LFxuICAgIDB4NTAwNTcxM2MsIDB4MjcwMjQxYWEsIDB4YmUwYjEwMTAsIDB4YzkwYzIwODYsIDB4NTc2OGI1MjUsIDB4MjA2Zjg1YjMsIDB4Yjk2NmQ0MDksIDB4Y2U2MWU0OWYsXG4gICAgMHg1ZWRlZjkwZSwgMHgyOWQ5Yzk5OCwgMHhiMGQwOTgyMiwgMHhjN2Q3YThiNCwgMHg1OWIzM2QxNywgMHgyZWI0MGQ4MSwgMHhiN2JkNWMzYiwgMHhjMGJhNmNhZCxcbiAgICAweGVkYjg4MzIwLCAweDlhYmZiM2I2LCAweDAzYjZlMjBjLCAweDc0YjFkMjlhLCAweGVhZDU0NzM5LCAweDlkZDI3N2FmLCAweDA0ZGIyNjE1LCAweDczZGMxNjgzLFxuICAgIDB4ZTM2MzBiMTIsIDB4OTQ2NDNiODQsIDB4MGQ2ZDZhM2UsIDB4N2E2YTVhYTgsIDB4ZTQwZWNmMGIsIDB4OTMwOWZmOWQsIDB4MGEwMGFlMjcsIDB4N2QwNzllYjEsXG4gICAgMHhmMDBmOTM0NCwgMHg4NzA4YTNkMiwgMHgxZTAxZjI2OCwgMHg2OTA2YzJmZSwgMHhmNzYyNTc1ZCwgMHg4MDY1NjdjYiwgMHgxOTZjMzY3MSwgMHg2ZTZiMDZlNyxcbiAgICAweGZlZDQxYjc2LCAweDg5ZDMyYmUwLCAweDEwZGE3YTVhLCAweDY3ZGQ0YWNjLCAweGY5YjlkZjZmLCAweDhlYmVlZmY5LCAweDE3YjdiZTQzLCAweDYwYjA4ZWQ1LFxuICAgIDB4ZDZkNmEzZTgsIDB4YTFkMTkzN2UsIDB4MzhkOGMyYzQsIDB4NGZkZmYyNTIsIDB4ZDFiYjY3ZjEsIDB4YTZiYzU3NjcsIDB4M2ZiNTA2ZGQsIDB4NDhiMjM2NGIsXG4gICAgMHhkODBkMmJkYSwgMHhhZjBhMWI0YywgMHgzNjAzNGFmNiwgMHg0MTA0N2E2MCwgMHhkZjYwZWZjMywgMHhhODY3ZGY1NSwgMHgzMTZlOGVlZiwgMHg0NjY5YmU3OSxcbiAgICAweGNiNjFiMzhjLCAweGJjNjY4MzFhLCAweDI1NmZkMmEwLCAweDUyNjhlMjM2LCAweGNjMGM3Nzk1LCAweGJiMGI0NzAzLCAweDIyMDIxNmI5LCAweDU1MDUyNjJmLFxuICAgIDB4YzViYTNiYmUsIDB4YjJiZDBiMjgsIDB4MmJiNDVhOTIsIDB4NWNiMzZhMDQsIDB4YzJkN2ZmYTcsIDB4YjVkMGNmMzEsIDB4MmNkOTllOGIsIDB4NWJkZWFlMWQsXG4gICAgMHg5YjY0YzJiMCwgMHhlYzYzZjIyNiwgMHg3NTZhYTM5YywgMHgwMjZkOTMwYSwgMHg5YzA5MDZhOSwgMHhlYjBlMzYzZiwgMHg3MjA3Njc4NSwgMHgwNTAwNTcxMyxcbiAgICAweDk1YmY0YTgyLCAweGUyYjg3YTE0LCAweDdiYjEyYmFlLCAweDBjYjYxYjM4LCAweDkyZDI4ZTliLCAweGU1ZDViZTBkLCAweDdjZGNlZmI3LCAweDBiZGJkZjIxLFxuICAgIDB4ODZkM2QyZDQsIDB4ZjFkNGUyNDIsIDB4NjhkZGIzZjgsIDB4MWZkYTgzNmUsIDB4ODFiZTE2Y2QsIDB4ZjZiOTI2NWIsIDB4NmZiMDc3ZTEsIDB4MThiNzQ3NzcsXG4gICAgMHg4ODA4NWFlNiwgMHhmZjBmNmE3MCwgMHg2NjA2M2JjYSwgMHgxMTAxMGI1YywgMHg4ZjY1OWVmZiwgMHhmODYyYWU2OSwgMHg2MTZiZmZkMywgMHgxNjZjY2Y0NSxcbiAgICAweGEwMGFlMjc4LCAweGQ3MGRkMmVlLCAweDRlMDQ4MzU0LCAweDM5MDNiM2MyLCAweGE3NjcyNjYxLCAweGQwNjAxNmY3LCAweDQ5Njk0NzRkLCAweDNlNmU3N2RiLFxuICAgIDB4YWVkMTZhNGEsIDB4ZDlkNjVhZGMsIDB4NDBkZjBiNjYsIDB4MzdkODNiZjAsIDB4YTliY2FlNTMsIDB4ZGViYjllYzUsIDB4NDdiMmNmN2YsIDB4MzBiNWZmZTksXG4gICAgMHhiZGJkZjIxYywgMHhjYWJhYzI4YSwgMHg1M2IzOTMzMCwgMHgyNGI0YTNhNiwgMHhiYWQwMzYwNSwgMHhjZGQ3MDY5MywgMHg1NGRlNTcyOSwgMHgyM2Q5NjdiZixcbiAgICAweGIzNjY3YTJlLCAweGM0NjE0YWI4LCAweDVkNjgxYjAyLCAweDJhNmYyYjk0LCAweGI0MGJiZTM3LCAweGMzMGM4ZWExLCAweDVhMDVkZjFiLCAweDJkMDJlZjhkLFxuXSk7XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgQ1JDMzIgb2YgYW4gQXJyYXlCdWZmZXJMaWtlLlxuICogQHBhcmFtIGJ1ZiBUaGUgQnVmZmVyTGlrZSB0byBjYWxjdWxhdGUgdGhlIENSQzMyIG9mLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JjMzIoYnVmKSB7XG4gICAgY29uc3QgYiA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgbGV0IGNyYyA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBieXRlID0gYltpXTtcbiAgICAgICAgY29uc3QgdCA9IChieXRlIF4gY3JjKSAmIDB4ZmY7XG4gICAgICAgIGNyYyA9IGxvb2tVcFRhYmxlW3RdIF4gKGNyYyA+Pj4gOCk7XG4gICAgfVxuICAgIHJldHVybiAoY3JjIF4gLTEpID4+PiAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q3JjLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/getCrc.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/sha224.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/sha224.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha256.js\");\n\n/**\n * Returns the SHA224 hash of the buffer.\n * @param data Arraybuffer to encode\n */\nfunction sha224(data) {\n    return _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha224.create().update(new Uint8Array(data)).digest();\n}\n//# sourceMappingURL=sha224.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQGRmaW5pdHkrcHJpbmNpcGFsQDIuMS4zL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9zaGEyMjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsd0RBQVE7QUFDbkI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9AZGZpbml0eStwcmluY2lwYWxAMi4xLjMvbm9kZV9tb2R1bGVzL0BkZmluaXR5L3ByaW5jaXBhbC9saWIvZXNtL3V0aWxzL3NoYTIyNC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzaGEyMjQgYXMganNTaGEyMjQgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG4vKipcbiAqIFJldHVybnMgdGhlIFNIQTIyNCBoYXNoIG9mIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0gZGF0YSBBcnJheWJ1ZmZlciB0byBlbmNvZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYTIyNChkYXRhKSB7XG4gICAgcmV0dXJuIGpzU2hhMjI0LmNyZWF0ZSgpLnVwZGF0ZShuZXcgVWludDhBcnJheShkYXRhKSkuZGlnZXN0KCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyMjQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@dfinity+principal@2.1.3/node_modules/@dfinity/principal/lib/esm/utils/sha224.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL2Jhc2U2NC1qc0AxLjUuMS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.js ***!
  \**************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.1.2\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n      alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if less than two characters,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, -1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    // If any number is NaN, return NaN.\r\n    function maxOrMin(args, n) {\r\n      var k, y,\r\n        i = 1,\r\n        x = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        y = new BigNumber(args[i]);\r\n        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\r\n          x = y;\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on ±Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = mathfloor(n / pows10[d - j - 1] % 10);\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and ±Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to ±Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = ±Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return ±0, else return ±Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) {\r\n        t = xc;\r\n        xc = yc;\r\n        yc = t;\r\n        y.s = -y.s;\r\n      }\r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, ±Infinity or ±0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return ±Infinity if either is ±Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return ±0 if either is ±0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) {\r\n        zc = xc;\r\n        xc = yc;\r\n        yc = zc;\r\n        i = xcL;\r\n        xcL = ycL;\r\n        ycL = i;\r\n      }\r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return ±Infinity if either ±Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) {\r\n        t = yc;\r\n        yc = xc;\r\n        xc = t;\r\n        b = a;\r\n      }\r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '5e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) {\r\n          i = g1;\r\n          g1 = g2;\r\n          g2 = i;\r\n          len -= i;\r\n        }\r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYmlnbnVtYmVyLmpzQDkuMS4yL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLG1DQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1REFBdUQ7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsRUFBRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsRUFBRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBLDZCQUE2Qiw2QkFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsRUFBRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QywyQkFBMkIsa0JBQWtCO0FBQzdDLDJCQUEyQixrQkFBa0I7QUFDN0MsMkJBQTJCLGtCQUFrQjtBQUM3QywyQkFBMkIsa0JBQWtCO0FBQzdDLDJCQUEyQixrQkFBa0I7QUFDN0MsOEJBQThCLGtCQUFrQjtBQUNoRCwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdDQUF3QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQyxnREFBZ0QsbURBQW1ELEdBQUcsRUFBRTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQywrQ0FBK0MsbURBQW1ELEdBQUcsRUFBRTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGdEQUFnRCxtREFBbUQsR0FBRyxFQUFFO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0EsdUNBQXVDLGtFQUFrRSxHQUFHLEVBQUU7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLDJEQUEyRCxFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMsNkNBQTZDLG1EQUFtRCxHQUFHLEVBQUU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEMsK0NBQStDLG1EQUFtRCxHQUFHLEVBQUU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHVEQUF1RCxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esb0NBQW9DLG1EQUFtRCxHQUFHLEdBQUc7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxFQUFFO0FBQ2pELDRDQUE0QyxHQUFHLFNBQVMsRUFBRTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsTUFBTTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esb0NBQW9DLG1EQUFtRCxHQUFHLEdBQUc7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsTUFBTTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsRUFBRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnREFBZ0QsS0FBSyxNQUFNLElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esb0NBQW9DLG1EQUFtRCxHQUFHLE1BQU07QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsTUFBTTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsTUFBTTtBQUNoRyxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBLG9DQUFvQyw2QkFBNkIsR0FBRyxHQUFHO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esb0NBQW9DLG1EQUFtRCxHQUFHLE1BQU07QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGdDQUFnQyxtREFBbUQsR0FBRyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXlDO0FBQy9DLElBQUksbUNBQU8sY0FBYyxtQkFBbUI7QUFBQSxrR0FBQztBQUM3QztBQUNBO0FBQ0EsSUFBSSxLQUFLLEVBVU47QUFDSCxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL2JpZ251bWJlci5qc0A5LjEuMi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4xLjJcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMiBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXHJcbiAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHYuc2xpY2UoMCwgMTApID09ICcwMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgLTEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgICAvKlxyXG4gICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgLS1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgYzAgPSBuLmNbMF07XHJcbiAgICAgIG5lID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgbmUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIGksIHJtKTtcclxuXHJcbiAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIGlmIChpZCA9PSAxIHx8IGlkID09IDIgJiYgKGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcpKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoc3RyLCBlKTtcclxuXHJcbiAgICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbmU7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICBpZiAoZSArIDEgPT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG4pIHtcclxuICAgICAgdmFyIGssIHksXHJcbiAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihhcmdzW2ldKTtcclxuICAgICAgICBpZiAoIXkucyB8fCAoayA9IGNvbXBhcmUoeCwgeSkpID09PSBuIHx8IGsgPT09IDAgJiYgeC5zID09PSBuKSB7XHJcbiAgICAgICAgICB4ID0geTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTApO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm5cclxuICAgICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgKi9cclxuICAgIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICBuID0gKCh2ID0gYy5sZW5ndGggLSAxKSAtIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgICAgaWYgKG4gPCAwKSBuID0gMDtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC8gMCA9IElcclxuICAgICAqICBuIC8gTiA9IE5cclxuICAgICAqICBuIC8gSSA9IDBcclxuICAgICAqICAwIC8gbiA9IDBcclxuICAgICAqICAwIC8gMCA9IE5cclxuICAgICAqICAwIC8gTiA9IE5cclxuICAgICAqICAwIC8gSSA9IDBcclxuICAgICAqICBOIC8gbiA9IE5cclxuICAgICAqICBOIC8gMCA9IE5cclxuICAgICAqICBOIC8gTiA9IE5cclxuICAgICAqICBOIC8gSSA9IE5cclxuICAgICAqICBJIC8gbiA9IElcclxuICAgICAqICBJIC8gMCA9IElcclxuICAgICAqICBJIC8gTiA9IE5cclxuICAgICAqICBJIC8gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5pZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBtIGlzIHByZXNlbnQsIHJldHVybiB0aGUgcmVzdWx0IG1vZHVsbyBtLlxyXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICAgKlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAgICovXHJcbiAgICBQLmV4cG9uZW50aWF0ZWRCeSA9IFAucG93ID0gZnVuY3Rpb24gKG4sIG0pIHtcclxuICAgICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobik7XHJcblxyXG4gICAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobSAhPSBudWxsKSBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBOYU4sIMKxSW5maW5pdHksIMKxMCBvciDCsTEsIG9yIG4gaXMgwrFJbmZpbml0eSwgTmFOIG9yIMKxMC5cclxuICAgICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgICAgLy8gSWYgK24gb3ZlcmZsb3dzIHRvIMKxSW5maW5pdHksIHRoZSBldmVubmVzcyBvZiBuIHdvdWxkIGJlIG5vdCBiZSBrbm93bi5cclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gbi5zICogKDIgLSBpc09kZChuKSkgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHtcclxuICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgeGMgPSB5YztcclxuICAgICAgICB5YyA9IHQ7XHJcbiAgICAgICAgeS5zID0gLXkucztcclxuICAgICAgfVxyXG5cclxuICAgICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIpO1xyXG4gICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXHJcbiAgICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICBzID0geS5zO1xyXG4gICAgICAgIHkucyA9IDE7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCAzKTtcclxuICAgICAgICB5LnMgPSBzO1xyXG4gICAgICAgIHEucyAqPSBzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0geC5taW51cyhxLnRpbWVzKHkpKTtcclxuXHJcbiAgICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAqIDAgPSAwXHJcbiAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgKiAgMCAqIG4gPSAwXHJcbiAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgKiAgMCAqIEkgPSBOXHJcbiAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgKiAgTiAqIE4gPSBOXHJcbiAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgKiAgSSAqIDAgPSBOXHJcbiAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgIGJhc2UsIHNxcnRCYXNlLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0gKHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpKS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgaWYgKCF4YyB8fCAheWMpIHtcclxuICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgeS5zICo9IHgucztcclxuICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgIGlmICh4Y0wgPCB5Y0wpIHtcclxuICAgICAgICB6YyA9IHhjO1xyXG4gICAgICAgIHhjID0geWM7XHJcbiAgICAgICAgeWMgPSB6YztcclxuICAgICAgICBpID0geGNMO1xyXG4gICAgICAgIHhjTCA9IHljTDtcclxuICAgICAgICB5Y0wgPSBpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB7XHJcbiAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIHljID0geGM7XHJcbiAgICAgICAgeGMgPSB0O1xyXG4gICAgICAgIGIgPSBhO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEpIHtcclxuICAgICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICsreWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICpcclxuICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgICAqL1xyXG4gICAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoTikgPSAgTlxyXG4gICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAqICBzcXJ0KEkpID0gIElcclxuICAgICAqICBzcXJ0KDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBjID0geC5jLFxyXG4gICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgZSA9IHguZSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgICBlID0gci5lO1xyXG4gICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgICAgbiA9IG4uc2xpY2UocyAtIDMsIHMgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwKys7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0sIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCA9IGRwICsgdGhpcy5lICsgMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgICAqIG9mIHRoZSBmb3JtYXQgb3IgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5zZXQpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb3JtYXR0aW5nIG9iamVjdCBtYXkgY29udGFpbiBzb21lIG9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyBzaG93biBiZWxvdy5cclxuICAgICAqXHJcbiAgICAgKiBGT1JNQVQgPSB7XHJcbiAgICAgKiAgIHByZWZpeDogJycsXHJcbiAgICAgKiAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICogICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICogICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICogICBzdWZmaXg6ICcnXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqIFtmb3JtYXRdIHtvYmplY3R9IEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlIEZPUk1BVCBwYmplY3QgYWJvdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQgbm90IGFuIG9iamVjdDoge2Zvcm1hdH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChkcCAhPSBudWxsICYmIHJtICYmIHR5cGVvZiBybSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gcm07XHJcbiAgICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkcCAmJiB0eXBlb2YgZHAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IGRwO1xyXG4gICAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvcm1hdCA9IEZPUk1BVDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IHgudG9GaXhlZChkcCwgcm0pO1xyXG5cclxuICAgICAgaWYgKHguYykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgICAgZzIgPSArZm9ybWF0LnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICAgIGdyb3VwU2VwYXJhdG9yID0gZm9ybWF0Lmdyb3VwU2VwYXJhdG9yIHx8ICcnLFxyXG4gICAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICAgIGlzTmVnID0geC5zIDwgMCxcclxuICAgICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoZzIpIHtcclxuICAgICAgICAgIGkgPSBnMTtcclxuICAgICAgICAgIGcxID0gZzI7XHJcbiAgICAgICAgICBnMiA9IGk7XHJcbiAgICAgICAgICBsZW4gLT0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgICAgZXhwID0gTUFYX0VYUDtcclxuICAgICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgICAgZm9yICg7IDspICB7XHJcbiAgICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgICBkMCA9IGQxO1xyXG4gICAgICAgIGQxID0gZDI7XHJcbiAgICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgICBuID0gZDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICovXHJcbiAgICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBuID0gdGhpcyxcclxuICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAgICogbmVnYXRpdmUgemVyby5cclxuICAgICAqL1xyXG4gICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICAgIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4gIC8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbiAgLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbiAgZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gICAgdmFyIGkgPSBuIHwgMDtcclxuICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG4gIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgdmFyIHMsIHosXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBqID0gYS5sZW5ndGgsXHJcbiAgICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gICAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICAgIHIgKz0gcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gICAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gIGZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gICAgdmFyIGEsIGIsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYyxcclxuICAgICAgaSA9IHgucyxcclxuICAgICAgaiA9IHkucyxcclxuICAgICAgayA9IHguZSxcclxuICAgICAgbCA9IHkuZTtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gICAgYSA9IGkgPCAwO1xyXG4gICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICAgIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbiAgZnVuY3Rpb24gaXNPZGQobikge1xyXG4gICAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICAgIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICAgIHZhciBsZW4sIHpzO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gICAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgICAgc3RyICs9IHpzO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuICBCaWdOdW1iZXJbJ2RlZmF1bHQnXSA9IEJpZ051bWJlci5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEFNRC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0pO1xyXG5cclxuICAvLyBOb2RlLmpzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEJyb3dzZXIuXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghZ2xvYmFsT2JqZWN0KSB7XHJcbiAgICAgIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbE9iamVjdC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgfVxyXG59KSh0aGlzKTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/constants.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/constants.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nexports.MT = {\n  POS_INT: 0,\n  NEG_INT: 1,\n  BYTE_STRING: 2,\n  UTF8_STRING: 3,\n  ARRAY: 4,\n  MAP: 5,\n  TAG: 6,\n  SIMPLE_FLOAT: 7\n}\n\nexports.TAG = {\n  DATE_STRING: 0,\n  DATE_EPOCH: 1,\n  POS_BIGINT: 2,\n  NEG_BIGINT: 3,\n  DECIMAL_FRAC: 4,\n  BIGFLOAT: 5,\n  BASE64URL_EXPECTED: 21,\n  BASE64_EXPECTED: 22,\n  BASE16_EXPECTED: 23,\n  CBOR: 24,\n  URI: 32,\n  BASE64URL: 33,\n  BASE64: 34,\n  REGEXP: 35,\n  MIME: 36\n}\n\nexports.NUMBYTES = {\n  ZERO: 0,\n  ONE: 24,\n  TWO: 25,\n  FOUR: 26,\n  EIGHT: 27,\n  INDEFINITE: 31\n}\n\nexports.SIMPLE = {\n  FALSE: 20,\n  TRUE: 21,\n  NULL: 22,\n  UNDEFINED: 23\n}\n\nexports.SYMS = {\n  NULL: Symbol('null'),\n  UNDEFINED: Symbol('undef'),\n  PARENT: Symbol('parent'),\n  BREAK: Symbol('break'),\n  STREAM: Symbol('stream')\n}\n\nexports.SHIFT32 = Math.pow(2, 32)\nexports.SHIFT16 = Math.pow(2, 16)\n\nexports.MAX_SAFE_HIGH = 0x1fffff\nexports.NEG_ONE = new Bignumber(-1)\nexports.TEN = new Bignumber(10)\nexports.TWO = new Bignumber(2)\n\nexports.PARENT = {\n  ARRAY: 0,\n  OBJECT: 1,\n  MAP: 2,\n  TAG: 3,\n  BYTE_STRING: 4,\n  UTF8_STRING: 5\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yY0AyLjEuMi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQixxSUFBaUM7O0FBRW5ELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixlQUFlOztBQUVmLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2YsV0FBVztBQUNYLFdBQVc7O0FBRVgsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL2JvcmNAMi4xLjIvbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgQmlnbnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJykuQmlnTnVtYmVyXG5cbmV4cG9ydHMuTVQgPSB7XG4gIFBPU19JTlQ6IDAsXG4gIE5FR19JTlQ6IDEsXG4gIEJZVEVfU1RSSU5HOiAyLFxuICBVVEY4X1NUUklORzogMyxcbiAgQVJSQVk6IDQsXG4gIE1BUDogNSxcbiAgVEFHOiA2LFxuICBTSU1QTEVfRkxPQVQ6IDdcbn1cblxuZXhwb3J0cy5UQUcgPSB7XG4gIERBVEVfU1RSSU5HOiAwLFxuICBEQVRFX0VQT0NIOiAxLFxuICBQT1NfQklHSU5UOiAyLFxuICBORUdfQklHSU5UOiAzLFxuICBERUNJTUFMX0ZSQUM6IDQsXG4gIEJJR0ZMT0FUOiA1LFxuICBCQVNFNjRVUkxfRVhQRUNURUQ6IDIxLFxuICBCQVNFNjRfRVhQRUNURUQ6IDIyLFxuICBCQVNFMTZfRVhQRUNURUQ6IDIzLFxuICBDQk9SOiAyNCxcbiAgVVJJOiAzMixcbiAgQkFTRTY0VVJMOiAzMyxcbiAgQkFTRTY0OiAzNCxcbiAgUkVHRVhQOiAzNSxcbiAgTUlNRTogMzZcbn1cblxuZXhwb3J0cy5OVU1CWVRFUyA9IHtcbiAgWkVSTzogMCxcbiAgT05FOiAyNCxcbiAgVFdPOiAyNSxcbiAgRk9VUjogMjYsXG4gIEVJR0hUOiAyNyxcbiAgSU5ERUZJTklURTogMzFcbn1cblxuZXhwb3J0cy5TSU1QTEUgPSB7XG4gIEZBTFNFOiAyMCxcbiAgVFJVRTogMjEsXG4gIE5VTEw6IDIyLFxuICBVTkRFRklORUQ6IDIzXG59XG5cbmV4cG9ydHMuU1lNUyA9IHtcbiAgTlVMTDogU3ltYm9sKCdudWxsJyksXG4gIFVOREVGSU5FRDogU3ltYm9sKCd1bmRlZicpLFxuICBQQVJFTlQ6IFN5bWJvbCgncGFyZW50JyksXG4gIEJSRUFLOiBTeW1ib2woJ2JyZWFrJyksXG4gIFNUUkVBTTogU3ltYm9sKCdzdHJlYW0nKVxufVxuXG5leHBvcnRzLlNISUZUMzIgPSBNYXRoLnBvdygyLCAzMilcbmV4cG9ydHMuU0hJRlQxNiA9IE1hdGgucG93KDIsIDE2KVxuXG5leHBvcnRzLk1BWF9TQUZFX0hJR0ggPSAweDFmZmZmZlxuZXhwb3J0cy5ORUdfT05FID0gbmV3IEJpZ251bWJlcigtMSlcbmV4cG9ydHMuVEVOID0gbmV3IEJpZ251bWJlcigxMClcbmV4cG9ydHMuVFdPID0gbmV3IEJpZ251bWJlcigyKVxuXG5leHBvcnRzLlBBUkVOVCA9IHtcbiAgQVJSQVk6IDAsXG4gIE9CSkVDVDogMSxcbiAgTUFQOiAyLFxuICBUQUc6IDMsXG4gIEJZVEVfU1RSSU5HOiA0LFxuICBVVEY4X1NUUklORzogNVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/constants.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/decoder.asm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/decoder.asm.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* eslint-disable */\n\nmodule.exports = function decodeAsm (stdlib, foreign, buffer) {\n  'use asm'\n\n  // -- Imports\n\n  var heap = new stdlib.Uint8Array(buffer)\n  // var log = foreign.log\n  var pushInt = foreign.pushInt\n  var pushInt32 = foreign.pushInt32\n  var pushInt32Neg = foreign.pushInt32Neg\n  var pushInt64 = foreign.pushInt64\n  var pushInt64Neg = foreign.pushInt64Neg\n  var pushFloat = foreign.pushFloat\n  var pushFloatSingle = foreign.pushFloatSingle\n  var pushFloatDouble = foreign.pushFloatDouble\n  var pushTrue = foreign.pushTrue\n  var pushFalse = foreign.pushFalse\n  var pushUndefined = foreign.pushUndefined\n  var pushNull = foreign.pushNull\n  var pushInfinity = foreign.pushInfinity\n  var pushInfinityNeg = foreign.pushInfinityNeg\n  var pushNaN = foreign.pushNaN\n  var pushNaNNeg = foreign.pushNaNNeg\n\n  var pushArrayStart = foreign.pushArrayStart\n  var pushArrayStartFixed = foreign.pushArrayStartFixed\n  var pushArrayStartFixed32 = foreign.pushArrayStartFixed32\n  var pushArrayStartFixed64 = foreign.pushArrayStartFixed64\n  var pushObjectStart = foreign.pushObjectStart\n  var pushObjectStartFixed = foreign.pushObjectStartFixed\n  var pushObjectStartFixed32 = foreign.pushObjectStartFixed32\n  var pushObjectStartFixed64 = foreign.pushObjectStartFixed64\n\n  var pushByteString = foreign.pushByteString\n  var pushByteStringStart = foreign.pushByteStringStart\n  var pushUtf8String = foreign.pushUtf8String\n  var pushUtf8StringStart = foreign.pushUtf8StringStart\n\n  var pushSimpleUnassigned = foreign.pushSimpleUnassigned\n\n  var pushTagStart = foreign.pushTagStart\n  var pushTagStart4 = foreign.pushTagStart4\n  var pushTagStart8 = foreign.pushTagStart8\n  var pushTagUnassigned = foreign.pushTagUnassigned\n\n  var pushBreak = foreign.pushBreak\n\n  var pow = stdlib.Math.pow\n\n  // -- Constants\n\n\n  // -- Mutable Variables\n\n  var offset = 0\n  var inputLength = 0\n  var code = 0\n\n  // Decode a cbor string represented as Uint8Array\n  // which is allocated on the heap from 0 to inputLength\n  //\n  // input - Int\n  //\n  // Returns Code - Int,\n  // Success = 0\n  // Error > 0\n  function parse (input) {\n    input = input | 0\n\n    offset = 0\n    inputLength = input\n\n    while ((offset | 0) < (inputLength | 0)) {\n      code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0\n\n      if ((code | 0) > 0) {\n        break\n      }\n    }\n\n    return code | 0\n  }\n\n  // -- Helper Function\n\n  function checkOffset (n) {\n    n = n | 0\n\n    if ((((offset | 0) + (n | 0)) | 0) < (inputLength | 0)) {\n      return 0\n    }\n\n    return 1\n  }\n\n  function readUInt16 (n) {\n    n = n | 0\n\n    return (\n      (heap[n | 0] << 8) | heap[(n + 1) | 0]\n    ) | 0\n  }\n\n  function readUInt32 (n) {\n    n = n | 0\n\n    return (\n      (heap[n | 0] << 24) | (heap[(n + 1) | 0] << 16) | (heap[(n + 2) | 0] << 8) | heap[(n + 3) | 0]\n    ) | 0\n  }\n\n  // -- Initial Byte Handlers\n\n  function INT_P (octet) {\n    octet = octet | 0\n\n    pushInt(octet | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UINT_P_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushInt(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function UINT_P_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushInt(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function UINT_P_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushInt32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function UINT_P_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushInt64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function INT_N (octet) {\n    octet = octet | 0\n\n    pushInt((-1 - ((octet - 32) | 0)) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UINT_N_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushInt(\n      (-1 - (heap[(offset + 1) | 0] | 0)) | 0\n    )\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function UINT_N_16 (octet) {\n    octet = octet | 0\n\n    var val = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    val = readUInt16((offset + 1) | 0) | 0\n    pushInt((-1 - (val | 0)) | 0)\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function UINT_N_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushInt32Neg(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function UINT_N_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushInt64Neg(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function BYTE_STRING (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var step = 0\n\n    step = (octet - 64) | 0\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    start = (offset + 1) | 0\n    end = (((offset + 1) | 0) + (step | 0)) | 0\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_8 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    length = heap[(offset + 1) | 0] | 0\n    start = (offset + 2) | 0\n    end = (((offset + 2) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 1) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_16 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    length = readUInt16((offset + 1) | 0) | 0\n    start = (offset + 3) | 0\n    end = (((offset + 3) | 0) + (length | 0)) | 0\n\n\n    if (checkOffset((length + 2) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_32 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    length = readUInt32((offset + 1) | 0) | 0\n    start = (offset + 5) | 0\n    end = (((offset + 5) | 0) + (length | 0)) | 0\n\n\n    if (checkOffset((length + 4) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_64 (octet) {\n    // NOT IMPLEMENTED\n    octet = octet | 0\n\n    return 1\n  }\n\n  function BYTE_STRING_BREAK (octet) {\n    octet = octet | 0\n\n    pushByteStringStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UTF8_STRING (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var step = 0\n\n    step = (octet - 96) | 0\n\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    start = (offset + 1) | 0\n    end = (((offset + 1) | 0) + (step | 0)) | 0\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_8 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    length = heap[(offset + 1) | 0] | 0\n    start = (offset + 2) | 0\n    end = (((offset + 2) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 1) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_16 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    length = readUInt16((offset + 1) | 0) | 0\n    start = (offset + 3) | 0\n    end = (((offset + 3) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 2) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_32 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    length = readUInt32((offset + 1) | 0) | 0\n    start = (offset + 5) | 0\n    end = (((offset + 5) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 4) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_64 (octet) {\n    // NOT IMPLEMENTED\n    octet = octet | 0\n\n    return 1\n  }\n\n  function UTF8_STRING_BREAK (octet) {\n    octet = octet | 0\n\n    pushUtf8StringStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function ARRAY (octet) {\n    octet = octet | 0\n\n    pushArrayStartFixed((octet - 128) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function ARRAY_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function ARRAY_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function ARRAY_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function ARRAY_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function ARRAY_BREAK (octet) {\n    octet = octet | 0\n\n    pushArrayStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function MAP (octet) {\n    octet = octet | 0\n\n    var step = 0\n\n    step = (octet - 160) | 0\n\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(step | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function MAP_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function MAP_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function MAP_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function MAP_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function MAP_BREAK (octet) {\n    octet = octet | 0\n\n    pushObjectStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function TAG_KNOWN (octet) {\n    octet = octet | 0\n\n    pushTagStart((octet - 192| 0) | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_POS (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_NEG (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_FRAC (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_FLOAT (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_UNASSIGNED (octet) {\n    octet = octet | 0\n\n    pushTagStart((octet - 192| 0) | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE64_URL (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE64 (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE16 (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_1 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushTagStart(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_2 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushTagStart(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_4 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushTagStart4(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushTagStart8(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9 | 0)\n\n    return 0\n  }\n\n  function SIMPLE_UNASSIGNED (octet) {\n    octet = octet | 0\n\n    pushSimpleUnassigned(((octet | 0) - 224) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FALSE (octet) {\n    octet = octet | 0\n\n    pushFalse()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_TRUE (octet) {\n    octet = octet | 0\n\n    pushTrue()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_NULL (octet) {\n    octet = octet | 0\n\n    pushNull()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_UNDEFINED (octet) {\n    octet = octet | 0\n\n    pushUndefined()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_BYTE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushSimpleUnassigned(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2)  | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_HALF (octet) {\n    octet = octet | 0\n\n    var f = 0\n    var g = 0\n    var sign = 1.0\n    var exp = 0.0\n    var mant = 0.0\n    var r = 0.0\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    f = heap[(offset + 1) | 0] | 0\n    g = heap[(offset + 2) | 0] | 0\n\n    if ((f | 0) & 0x80) {\n      sign = -1.0\n    }\n\n    exp = +(((f | 0) & 0x7C) >> 2)\n    mant = +((((f | 0) & 0x03) << 8) | g)\n\n    if (+exp == 0.0) {\n      pushFloat(+(\n        (+sign) * +5.9604644775390625e-8 * (+mant)\n      ))\n    } else if (+exp == 31.0) {\n      if (+sign == 1.0) {\n        if (+mant > 0.0) {\n          pushNaN()\n        } else {\n          pushInfinity()\n        }\n      } else {\n        if (+mant > 0.0) {\n          pushNaNNeg()\n        } else {\n          pushInfinityNeg()\n        }\n      }\n    } else {\n      pushFloat(+(\n        +sign * pow(+2, +(+exp - 25.0)) * +(1024.0 + mant)\n      ))\n    }\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_SINGLE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushFloatSingle(\n      heap[(offset + 1) | 0] | 0,\n      heap[(offset + 2) | 0] | 0,\n      heap[(offset + 3) | 0] | 0,\n      heap[(offset + 4) | 0] | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_DOUBLE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushFloatDouble(\n      heap[(offset + 1) | 0] | 0,\n      heap[(offset + 2) | 0] | 0,\n      heap[(offset + 3) | 0] | 0,\n      heap[(offset + 4) | 0] | 0,\n      heap[(offset + 5) | 0] | 0,\n      heap[(offset + 6) | 0] | 0,\n      heap[(offset + 7) | 0] | 0,\n      heap[(offset + 8) | 0] | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function ERROR (octet) {\n    octet = octet | 0\n\n    return 1\n  }\n\n  function BREAK (octet) {\n    octet = octet | 0\n\n    pushBreak()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  // -- Jump Table\n\n  var jumpTable = [\n    // Integer 0x00..0x17 (0..23)\n    INT_P, // 0x00\n    INT_P, // 0x01\n    INT_P, // 0x02\n    INT_P, // 0x03\n    INT_P, // 0x04\n    INT_P, // 0x05\n    INT_P, // 0x06\n    INT_P, // 0x07\n    INT_P, // 0x08\n    INT_P, // 0x09\n    INT_P, // 0x0A\n    INT_P, // 0x0B\n    INT_P, // 0x0C\n    INT_P, // 0x0D\n    INT_P, // 0x0E\n    INT_P, // 0x0F\n    INT_P, // 0x10\n    INT_P, // 0x11\n    INT_P, // 0x12\n    INT_P, // 0x13\n    INT_P, // 0x14\n    INT_P, // 0x15\n    INT_P, // 0x16\n    INT_P, // 0x17\n    // Unsigned integer (one-byte uint8_t follows)\n    UINT_P_8, // 0x18\n    // Unsigned integer (two-byte uint16_t follows)\n    UINT_P_16, // 0x19\n    // Unsigned integer (four-byte uint32_t follows)\n    UINT_P_32, // 0x1a\n    // Unsigned integer (eight-byte uint64_t follows)\n    UINT_P_64, // 0x1b\n    ERROR, // 0x1c\n    ERROR, // 0x1d\n    ERROR, // 0x1e\n    ERROR, // 0x1f\n    // Negative integer -1-0x00..-1-0x17 (-1..-24)\n    INT_N, // 0x20\n    INT_N, // 0x21\n    INT_N, // 0x22\n    INT_N, // 0x23\n    INT_N, // 0x24\n    INT_N, // 0x25\n    INT_N, // 0x26\n    INT_N, // 0x27\n    INT_N, // 0x28\n    INT_N, // 0x29\n    INT_N, // 0x2A\n    INT_N, // 0x2B\n    INT_N, // 0x2C\n    INT_N, // 0x2D\n    INT_N, // 0x2E\n    INT_N, // 0x2F\n    INT_N, // 0x30\n    INT_N, // 0x31\n    INT_N, // 0x32\n    INT_N, // 0x33\n    INT_N, // 0x34\n    INT_N, // 0x35\n    INT_N, // 0x36\n    INT_N, // 0x37\n    // Negative integer -1-n (one-byte uint8_t for n follows)\n    UINT_N_8, // 0x38\n    // Negative integer -1-n (two-byte uint16_t for n follows)\n    UINT_N_16, // 0x39\n    // Negative integer -1-n (four-byte uint32_t for nfollows)\n    UINT_N_32, // 0x3a\n    // Negative integer -1-n (eight-byte uint64_t for n follows)\n    UINT_N_64, // 0x3b\n    ERROR, // 0x3c\n    ERROR, // 0x3d\n    ERROR, // 0x3e\n    ERROR, // 0x3f\n    // byte string (0x00..0x17 bytes follow)\n    BYTE_STRING, // 0x40\n    BYTE_STRING, // 0x41\n    BYTE_STRING, // 0x42\n    BYTE_STRING, // 0x43\n    BYTE_STRING, // 0x44\n    BYTE_STRING, // 0x45\n    BYTE_STRING, // 0x46\n    BYTE_STRING, // 0x47\n    BYTE_STRING, // 0x48\n    BYTE_STRING, // 0x49\n    BYTE_STRING, // 0x4A\n    BYTE_STRING, // 0x4B\n    BYTE_STRING, // 0x4C\n    BYTE_STRING, // 0x4D\n    BYTE_STRING, // 0x4E\n    BYTE_STRING, // 0x4F\n    BYTE_STRING, // 0x50\n    BYTE_STRING, // 0x51\n    BYTE_STRING, // 0x52\n    BYTE_STRING, // 0x53\n    BYTE_STRING, // 0x54\n    BYTE_STRING, // 0x55\n    BYTE_STRING, // 0x56\n    BYTE_STRING, // 0x57\n    // byte string (one-byte uint8_t for n, and then n bytes follow)\n    BYTE_STRING_8, // 0x58\n    // byte string (two-byte uint16_t for n, and then n bytes follow)\n    BYTE_STRING_16, // 0x59\n    // byte string (four-byte uint32_t for n, and then n bytes follow)\n    BYTE_STRING_32, // 0x5a\n    // byte string (eight-byte uint64_t for n, and then n bytes follow)\n    BYTE_STRING_64, // 0x5b\n    ERROR, // 0x5c\n    ERROR, // 0x5d\n    ERROR, // 0x5e\n    // byte string, byte strings follow, terminated by \"break\"\n    BYTE_STRING_BREAK, // 0x5f\n    // UTF-8 string (0x00..0x17 bytes follow)\n    UTF8_STRING, // 0x60\n    UTF8_STRING, // 0x61\n    UTF8_STRING, // 0x62\n    UTF8_STRING, // 0x63\n    UTF8_STRING, // 0x64\n    UTF8_STRING, // 0x65\n    UTF8_STRING, // 0x66\n    UTF8_STRING, // 0x67\n    UTF8_STRING, // 0x68\n    UTF8_STRING, // 0x69\n    UTF8_STRING, // 0x6A\n    UTF8_STRING, // 0x6B\n    UTF8_STRING, // 0x6C\n    UTF8_STRING, // 0x6D\n    UTF8_STRING, // 0x6E\n    UTF8_STRING, // 0x6F\n    UTF8_STRING, // 0x70\n    UTF8_STRING, // 0x71\n    UTF8_STRING, // 0x72\n    UTF8_STRING, // 0x73\n    UTF8_STRING, // 0x74\n    UTF8_STRING, // 0x75\n    UTF8_STRING, // 0x76\n    UTF8_STRING, // 0x77\n    // UTF-8 string (one-byte uint8_t for n, and then n bytes follow)\n    UTF8_STRING_8, // 0x78\n    // UTF-8 string (two-byte uint16_t for n, and then n bytes follow)\n    UTF8_STRING_16, // 0x79\n    // UTF-8 string (four-byte uint32_t for n, and then n bytes follow)\n    UTF8_STRING_32, // 0x7a\n    // UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)\n    UTF8_STRING_64, // 0x7b\n    // UTF-8 string, UTF-8 strings follow, terminated by \"break\"\n    ERROR, // 0x7c\n    ERROR, // 0x7d\n    ERROR, // 0x7e\n    UTF8_STRING_BREAK, // 0x7f\n    // array (0x00..0x17 data items follow)\n    ARRAY, // 0x80\n    ARRAY, // 0x81\n    ARRAY, // 0x82\n    ARRAY, // 0x83\n    ARRAY, // 0x84\n    ARRAY, // 0x85\n    ARRAY, // 0x86\n    ARRAY, // 0x87\n    ARRAY, // 0x88\n    ARRAY, // 0x89\n    ARRAY, // 0x8A\n    ARRAY, // 0x8B\n    ARRAY, // 0x8C\n    ARRAY, // 0x8D\n    ARRAY, // 0x8E\n    ARRAY, // 0x8F\n    ARRAY, // 0x90\n    ARRAY, // 0x91\n    ARRAY, // 0x92\n    ARRAY, // 0x93\n    ARRAY, // 0x94\n    ARRAY, // 0x95\n    ARRAY, // 0x96\n    ARRAY, // 0x97\n    // array (one-byte uint8_t fo, and then n data items follow)\n    ARRAY_8, // 0x98\n    // array (two-byte uint16_t for n, and then n data items follow)\n    ARRAY_16, // 0x99\n    // array (four-byte uint32_t for n, and then n data items follow)\n    ARRAY_32, // 0x9a\n    // array (eight-byte uint64_t for n, and then n data items follow)\n    ARRAY_64, // 0x9b\n    // array, data items follow, terminated by \"break\"\n    ERROR, // 0x9c\n    ERROR, // 0x9d\n    ERROR, // 0x9e\n    ARRAY_BREAK, // 0x9f\n    // map (0x00..0x17 pairs of data items follow)\n    MAP, // 0xa0\n    MAP, // 0xa1\n    MAP, // 0xa2\n    MAP, // 0xa3\n    MAP, // 0xa4\n    MAP, // 0xa5\n    MAP, // 0xa6\n    MAP, // 0xa7\n    MAP, // 0xa8\n    MAP, // 0xa9\n    MAP, // 0xaA\n    MAP, // 0xaB\n    MAP, // 0xaC\n    MAP, // 0xaD\n    MAP, // 0xaE\n    MAP, // 0xaF\n    MAP, // 0xb0\n    MAP, // 0xb1\n    MAP, // 0xb2\n    MAP, // 0xb3\n    MAP, // 0xb4\n    MAP, // 0xb5\n    MAP, // 0xb6\n    MAP, // 0xb7\n    // map (one-byte uint8_t for n, and then n pairs of data items follow)\n    MAP_8, // 0xb8\n    // map (two-byte uint16_t for n, and then n pairs of data items follow)\n    MAP_16, // 0xb9\n    // map (four-byte uint32_t for n, and then n pairs of data items follow)\n    MAP_32, // 0xba\n    // map (eight-byte uint64_t for n, and then n pairs of data items follow)\n    MAP_64, // 0xbb\n    ERROR, // 0xbc\n    ERROR, // 0xbd\n    ERROR, // 0xbe\n    // map, pairs of data items follow, terminated by \"break\"\n    MAP_BREAK, // 0xbf\n    // Text-based date/time (data item follows; see Section 2.4.1)\n    TAG_KNOWN, // 0xc0\n    // Epoch-based date/time (data item follows; see Section 2.4.1)\n    TAG_KNOWN, // 0xc1\n    // Positive bignum (data item \"byte string\" follows)\n    TAG_KNOWN, // 0xc2\n    // Negative bignum (data item \"byte string\" follows)\n    TAG_KNOWN, // 0xc3\n    // Decimal Fraction (data item \"array\" follows; see Section 2.4.3)\n    TAG_KNOWN, // 0xc4\n    // Bigfloat (data item \"array\" follows; see Section 2.4.3)\n    TAG_KNOWN, // 0xc5\n    // (tagged item)\n    TAG_UNASSIGNED, // 0xc6\n    TAG_UNASSIGNED, // 0xc7\n    TAG_UNASSIGNED, // 0xc8\n    TAG_UNASSIGNED, // 0xc9\n    TAG_UNASSIGNED, // 0xca\n    TAG_UNASSIGNED, // 0xcb\n    TAG_UNASSIGNED, // 0xcc\n    TAG_UNASSIGNED, // 0xcd\n    TAG_UNASSIGNED, // 0xce\n    TAG_UNASSIGNED, // 0xcf\n    TAG_UNASSIGNED, // 0xd0\n    TAG_UNASSIGNED, // 0xd1\n    TAG_UNASSIGNED, // 0xd2\n    TAG_UNASSIGNED, // 0xd3\n    TAG_UNASSIGNED, // 0xd4\n    // Expected Conversion (data item follows; see Section 2.4.4.2)\n    TAG_UNASSIGNED, // 0xd5\n    TAG_UNASSIGNED, // 0xd6\n    TAG_UNASSIGNED, // 0xd7\n    // (more tagged items, 1/2/4/8 bytes and then a data item follow)\n    TAG_MORE_1, // 0xd8\n    TAG_MORE_2, // 0xd9\n    TAG_MORE_4, // 0xda\n    TAG_MORE_8, // 0xdb\n    ERROR, // 0xdc\n    ERROR, // 0xdd\n    ERROR, // 0xde\n    ERROR, // 0xdf\n    // (simple value)\n    SIMPLE_UNASSIGNED, // 0xe0\n    SIMPLE_UNASSIGNED, // 0xe1\n    SIMPLE_UNASSIGNED, // 0xe2\n    SIMPLE_UNASSIGNED, // 0xe3\n    SIMPLE_UNASSIGNED, // 0xe4\n    SIMPLE_UNASSIGNED, // 0xe5\n    SIMPLE_UNASSIGNED, // 0xe6\n    SIMPLE_UNASSIGNED, // 0xe7\n    SIMPLE_UNASSIGNED, // 0xe8\n    SIMPLE_UNASSIGNED, // 0xe9\n    SIMPLE_UNASSIGNED, // 0xea\n    SIMPLE_UNASSIGNED, // 0xeb\n    SIMPLE_UNASSIGNED, // 0xec\n    SIMPLE_UNASSIGNED, // 0xed\n    SIMPLE_UNASSIGNED, // 0xee\n    SIMPLE_UNASSIGNED, // 0xef\n    SIMPLE_UNASSIGNED, // 0xf0\n    SIMPLE_UNASSIGNED, // 0xf1\n    SIMPLE_UNASSIGNED, // 0xf2\n    SIMPLE_UNASSIGNED, // 0xf3\n    // False\n    SIMPLE_FALSE, // 0xf4\n    // True\n    SIMPLE_TRUE, // 0xf5\n    // Null\n    SIMPLE_NULL, // 0xf6\n    // Undefined\n    SIMPLE_UNDEFINED, // 0xf7\n    // (simple value, one byte follows)\n    SIMPLE_BYTE, // 0xf8\n    // Half-Precision Float (two-byte IEEE 754)\n    SIMPLE_FLOAT_HALF, // 0xf9\n    // Single-Precision Float (four-byte IEEE 754)\n    SIMPLE_FLOAT_SINGLE, // 0xfa\n    // Double-Precision Float (eight-byte IEEE 754)\n    SIMPLE_FLOAT_DOUBLE, // 0xfb\n    ERROR, // 0xfc\n    ERROR, // 0xfd\n    ERROR, // 0xfe\n    // \"break\" stop code\n    BREAK // 0xff\n  ]\n\n  // --\n\n  return {\n    parse: parse\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yY0AyLjEuMi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZGVjb2Rlci5hc20uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL2JvcmNAMi4xLjIvbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RlY29kZXIuYXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVjb2RlQXNtIChzdGRsaWIsIGZvcmVpZ24sIGJ1ZmZlcikge1xuICAndXNlIGFzbSdcblxuICAvLyAtLSBJbXBvcnRzXG5cbiAgdmFyIGhlYXAgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKVxuICAvLyB2YXIgbG9nID0gZm9yZWlnbi5sb2dcbiAgdmFyIHB1c2hJbnQgPSBmb3JlaWduLnB1c2hJbnRcbiAgdmFyIHB1c2hJbnQzMiA9IGZvcmVpZ24ucHVzaEludDMyXG4gIHZhciBwdXNoSW50MzJOZWcgPSBmb3JlaWduLnB1c2hJbnQzMk5lZ1xuICB2YXIgcHVzaEludDY0ID0gZm9yZWlnbi5wdXNoSW50NjRcbiAgdmFyIHB1c2hJbnQ2NE5lZyA9IGZvcmVpZ24ucHVzaEludDY0TmVnXG4gIHZhciBwdXNoRmxvYXQgPSBmb3JlaWduLnB1c2hGbG9hdFxuICB2YXIgcHVzaEZsb2F0U2luZ2xlID0gZm9yZWlnbi5wdXNoRmxvYXRTaW5nbGVcbiAgdmFyIHB1c2hGbG9hdERvdWJsZSA9IGZvcmVpZ24ucHVzaEZsb2F0RG91YmxlXG4gIHZhciBwdXNoVHJ1ZSA9IGZvcmVpZ24ucHVzaFRydWVcbiAgdmFyIHB1c2hGYWxzZSA9IGZvcmVpZ24ucHVzaEZhbHNlXG4gIHZhciBwdXNoVW5kZWZpbmVkID0gZm9yZWlnbi5wdXNoVW5kZWZpbmVkXG4gIHZhciBwdXNoTnVsbCA9IGZvcmVpZ24ucHVzaE51bGxcbiAgdmFyIHB1c2hJbmZpbml0eSA9IGZvcmVpZ24ucHVzaEluZmluaXR5XG4gIHZhciBwdXNoSW5maW5pdHlOZWcgPSBmb3JlaWduLnB1c2hJbmZpbml0eU5lZ1xuICB2YXIgcHVzaE5hTiA9IGZvcmVpZ24ucHVzaE5hTlxuICB2YXIgcHVzaE5hTk5lZyA9IGZvcmVpZ24ucHVzaE5hTk5lZ1xuXG4gIHZhciBwdXNoQXJyYXlTdGFydCA9IGZvcmVpZ24ucHVzaEFycmF5U3RhcnRcbiAgdmFyIHB1c2hBcnJheVN0YXJ0Rml4ZWQgPSBmb3JlaWduLnB1c2hBcnJheVN0YXJ0Rml4ZWRcbiAgdmFyIHB1c2hBcnJheVN0YXJ0Rml4ZWQzMiA9IGZvcmVpZ24ucHVzaEFycmF5U3RhcnRGaXhlZDMyXG4gIHZhciBwdXNoQXJyYXlTdGFydEZpeGVkNjQgPSBmb3JlaWduLnB1c2hBcnJheVN0YXJ0Rml4ZWQ2NFxuICB2YXIgcHVzaE9iamVjdFN0YXJ0ID0gZm9yZWlnbi5wdXNoT2JqZWN0U3RhcnRcbiAgdmFyIHB1c2hPYmplY3RTdGFydEZpeGVkID0gZm9yZWlnbi5wdXNoT2JqZWN0U3RhcnRGaXhlZFxuICB2YXIgcHVzaE9iamVjdFN0YXJ0Rml4ZWQzMiA9IGZvcmVpZ24ucHVzaE9iamVjdFN0YXJ0Rml4ZWQzMlxuICB2YXIgcHVzaE9iamVjdFN0YXJ0Rml4ZWQ2NCA9IGZvcmVpZ24ucHVzaE9iamVjdFN0YXJ0Rml4ZWQ2NFxuXG4gIHZhciBwdXNoQnl0ZVN0cmluZyA9IGZvcmVpZ24ucHVzaEJ5dGVTdHJpbmdcbiAgdmFyIHB1c2hCeXRlU3RyaW5nU3RhcnQgPSBmb3JlaWduLnB1c2hCeXRlU3RyaW5nU3RhcnRcbiAgdmFyIHB1c2hVdGY4U3RyaW5nID0gZm9yZWlnbi5wdXNoVXRmOFN0cmluZ1xuICB2YXIgcHVzaFV0ZjhTdHJpbmdTdGFydCA9IGZvcmVpZ24ucHVzaFV0ZjhTdHJpbmdTdGFydFxuXG4gIHZhciBwdXNoU2ltcGxlVW5hc3NpZ25lZCA9IGZvcmVpZ24ucHVzaFNpbXBsZVVuYXNzaWduZWRcblxuICB2YXIgcHVzaFRhZ1N0YXJ0ID0gZm9yZWlnbi5wdXNoVGFnU3RhcnRcbiAgdmFyIHB1c2hUYWdTdGFydDQgPSBmb3JlaWduLnB1c2hUYWdTdGFydDRcbiAgdmFyIHB1c2hUYWdTdGFydDggPSBmb3JlaWduLnB1c2hUYWdTdGFydDhcbiAgdmFyIHB1c2hUYWdVbmFzc2lnbmVkID0gZm9yZWlnbi5wdXNoVGFnVW5hc3NpZ25lZFxuXG4gIHZhciBwdXNoQnJlYWsgPSBmb3JlaWduLnB1c2hCcmVha1xuXG4gIHZhciBwb3cgPSBzdGRsaWIuTWF0aC5wb3dcblxuICAvLyAtLSBDb25zdGFudHNcblxuXG4gIC8vIC0tIE11dGFibGUgVmFyaWFibGVzXG5cbiAgdmFyIG9mZnNldCA9IDBcbiAgdmFyIGlucHV0TGVuZ3RoID0gMFxuICB2YXIgY29kZSA9IDBcblxuICAvLyBEZWNvZGUgYSBjYm9yIHN0cmluZyByZXByZXNlbnRlZCBhcyBVaW50OEFycmF5XG4gIC8vIHdoaWNoIGlzIGFsbG9jYXRlZCBvbiB0aGUgaGVhcCBmcm9tIDAgdG8gaW5wdXRMZW5ndGhcbiAgLy9cbiAgLy8gaW5wdXQgLSBJbnRcbiAgLy9cbiAgLy8gUmV0dXJucyBDb2RlIC0gSW50LFxuICAvLyBTdWNjZXNzID0gMFxuICAvLyBFcnJvciA+IDBcbiAgZnVuY3Rpb24gcGFyc2UgKGlucHV0KSB7XG4gICAgaW5wdXQgPSBpbnB1dCB8IDBcblxuICAgIG9mZnNldCA9IDBcbiAgICBpbnB1dExlbmd0aCA9IGlucHV0XG5cbiAgICB3aGlsZSAoKG9mZnNldCB8IDApIDwgKGlucHV0TGVuZ3RoIHwgMCkpIHtcbiAgICAgIGNvZGUgPSBqdW1wVGFibGVbaGVhcFtvZmZzZXRdICYgMjU1XShoZWFwW29mZnNldF0gfCAwKSB8IDBcblxuICAgICAgaWYgKChjb2RlIHwgMCkgPiAwKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGUgfCAwXG4gIH1cblxuICAvLyAtLSBIZWxwZXIgRnVuY3Rpb25cblxuICBmdW5jdGlvbiBjaGVja09mZnNldCAobikge1xuICAgIG4gPSBuIHwgMFxuXG4gICAgaWYgKCgoKG9mZnNldCB8IDApICsgKG4gfCAwKSkgfCAwKSA8IChpbnB1dExlbmd0aCB8IDApKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiAxXG4gIH1cblxuICBmdW5jdGlvbiByZWFkVUludDE2IChuKSB7XG4gICAgbiA9IG4gfCAwXG5cbiAgICByZXR1cm4gKFxuICAgICAgKGhlYXBbbiB8IDBdIDw8IDgpIHwgaGVhcFsobiArIDEpIHwgMF1cbiAgICApIHwgMFxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFVJbnQzMiAobikge1xuICAgIG4gPSBuIHwgMFxuXG4gICAgcmV0dXJuIChcbiAgICAgIChoZWFwW24gfCAwXSA8PCAyNCkgfCAoaGVhcFsobiArIDEpIHwgMF0gPDwgMTYpIHwgKGhlYXBbKG4gKyAyKSB8IDBdIDw8IDgpIHwgaGVhcFsobiArIDMpIHwgMF1cbiAgICApIHwgMFxuICB9XG5cbiAgLy8gLS0gSW5pdGlhbCBCeXRlIEhhbmRsZXJzXG5cbiAgZnVuY3Rpb24gSU5UX1AgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hJbnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfUF84IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQoaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMikgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9QXzE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAzKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX1BfMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludDMyKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX1BfNjQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg4KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludDY0KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDUpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gSU5UX04gKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hJbnQoKC0xIC0gKChvY3RldCAtIDMyKSB8IDApKSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9OXzggKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludChcbiAgICAgICgtMSAtIChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMCkpIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX05fMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciB2YWwgPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHZhbCA9IHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgcHVzaEludCgoLTEgLSAodmFsIHwgMCkpIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAzKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX05fMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludDMyTmVnKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX05fNjQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg4KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludDY0TmVnKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDUpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkcgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBzdGVwID0gMFxuXG4gICAgc3RlcCA9IChvY3RldCAtIDY0KSB8IDBcbiAgICBpZiAoY2hlY2tPZmZzZXQoc3RlcCB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBzdGFydCA9IChvZmZzZXQgKyAxKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAxKSB8IDApICsgKHN0ZXAgfCAwKSkgfCAwXG5cbiAgICBwdXNoQnl0ZVN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkdfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyAyKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAyKSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgobGVuZ3RoICsgMSkgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEJ5dGVTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEJZVEVfU1RSSU5HXzE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZW5ndGggPSByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDMpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDMpIHwgMCkgKyAobGVuZ3RoIHwgMCkpIHwgMFxuXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoKGxlbmd0aCArIDIpIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hCeXRlU3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBCWVRFX1NUUklOR18zMiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gcmVhZFVJbnQzMigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyA1KSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyA1KSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KChsZW5ndGggKyA0KSB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQnl0ZVN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkdfNjQgKG9jdGV0KSB7XG4gICAgLy8gTk9UIElNUExFTUVOVEVEXG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHJldHVybiAxXG4gIH1cblxuICBmdW5jdGlvbiBCWVRFX1NUUklOR19CUkVBSyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEJ5dGVTdHJpbmdTdGFydCgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkcgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBzdGVwID0gMFxuXG4gICAgc3RlcCA9IChvY3RldCAtIDk2KSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldChzdGVwIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDEpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDEpIHwgMCkgKyAoc3RlcCB8IDApKSB8IDBcblxuICAgIHB1c2hVdGY4U3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVVEY4X1NUUklOR184IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZW5ndGggPSBoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMFxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDIpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDIpIHwgMCkgKyAobGVuZ3RoIHwgMCkpIHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KChsZW5ndGggKyAxKSB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVXRmOFN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkdfMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxlbmd0aCA9IHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgMykgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgMykgfCAwKSArIChsZW5ndGggfCAwKSkgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoKGxlbmd0aCArIDIpIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hVdGY4U3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVVEY4X1NUUklOR18zMiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gcmVhZFVJbnQzMigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyA1KSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyA1KSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgobGVuZ3RoICsgNCkgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFV0ZjhTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVURjhfU1RSSU5HXzY0IChvY3RldCkge1xuICAgIC8vIE5PVCBJTVBMRU1FTlRFRFxuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICByZXR1cm4gMVxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkdfQlJFQUsgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hVdGY4U3RyaW5nU3RhcnQoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEFSUkFZIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoQXJyYXlTdGFydEZpeGVkKChvY3RldCAtIDEyOCkgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEFSUkFZXzggKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEFycmF5U3RhcnRGaXhlZChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWV8xNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQXJyYXlTdGFydEZpeGVkKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMykgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQVJSQVlfMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEFycmF5U3RhcnRGaXhlZDMyKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWV82NCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDgpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQXJyYXlTdGFydEZpeGVkNjQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA3KSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA5KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWV9CUkVBSyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEFycmF5U3RhcnQoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0ZXAgPSAwXG5cbiAgICBzdGVwID0gKG9jdGV0IC0gMTYwKSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldChzdGVwIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hPYmplY3RTdGFydEZpeGVkKHN0ZXAgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUF84IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hPYmplY3RTdGFydEZpeGVkKGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDIpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUF8xNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDMpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUF8zMiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZDMyKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVBfNjQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg4KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQ2NChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA1KSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDcpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDkpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUF9CUkVBSyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaE9iamVjdFN0YXJ0KClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfS05PV04gKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydCgob2N0ZXQgLSAxOTJ8IDApIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfQklHTlVNX1BPUyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfQklHTlVNX05FRyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfRlJBQyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfQklHTlVNX0ZMT0FUIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19VTkFTU0lHTkVEIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQoKG9jdGV0IC0gMTkyfCAwKSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JBU0U2NF9VUkwgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JBU0U2NCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfQkFTRTE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19NT1JFXzEgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFRhZ1N0YXJ0KGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDIgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19NT1JFXzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFRhZ1N0YXJ0KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMyB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX01PUkVfNCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVGFnU3RhcnQ0KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1IHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfTU9SRV84IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hUYWdTdGFydDgoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA3KSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA5IHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfVU5BU1NJR05FRCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFNpbXBsZVVuYXNzaWduZWQoKChvY3RldCB8IDApIC0gMjI0KSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX0ZBTFNFIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoRmFsc2UoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9UUlVFIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVHJ1ZSgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX05VTEwgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hOdWxsKClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfVU5ERUZJTkVEIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVW5kZWZpbmVkKClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfQllURSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoU2ltcGxlVW5hc3NpZ25lZChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyKSAgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX0ZMT0FUX0hBTEYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBmID0gMFxuICAgIHZhciBnID0gMFxuICAgIHZhciBzaWduID0gMS4wXG4gICAgdmFyIGV4cCA9IDAuMFxuICAgIHZhciBtYW50ID0gMC4wXG4gICAgdmFyIHIgPSAwLjBcbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGYgPSBoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMFxuICAgIGcgPSBoZWFwWyhvZmZzZXQgKyAyKSB8IDBdIHwgMFxuXG4gICAgaWYgKChmIHwgMCkgJiAweDgwKSB7XG4gICAgICBzaWduID0gLTEuMFxuICAgIH1cblxuICAgIGV4cCA9ICsoKChmIHwgMCkgJiAweDdDKSA+PiAyKVxuICAgIG1hbnQgPSArKCgoKGYgfCAwKSAmIDB4MDMpIDw8IDgpIHwgZylcblxuICAgIGlmICgrZXhwID09IDAuMCkge1xuICAgICAgcHVzaEZsb2F0KCsoXG4gICAgICAgICgrc2lnbikgKiArNS45NjA0NjQ0Nzc1MzkwNjI1ZS04ICogKCttYW50KVxuICAgICAgKSlcbiAgICB9IGVsc2UgaWYgKCtleHAgPT0gMzEuMCkge1xuICAgICAgaWYgKCtzaWduID09IDEuMCkge1xuICAgICAgICBpZiAoK21hbnQgPiAwLjApIHtcbiAgICAgICAgICBwdXNoTmFOKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoSW5maW5pdHkoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoK21hbnQgPiAwLjApIHtcbiAgICAgICAgICBwdXNoTmFOTmVnKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoSW5maW5pdHlOZWcoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hGbG9hdCgrKFxuICAgICAgICArc2lnbiAqIHBvdygrMiwgKygrZXhwIC0gMjUuMCkpICogKygxMDI0LjAgKyBtYW50KVxuICAgICAgKSlcbiAgICB9XG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMykgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX0ZMT0FUX1NJTkdMRSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoRmxvYXRTaW5nbGUoXG4gICAgICBoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDIpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgMykgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyA0KSB8IDBdIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA1KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfRkxPQVRfRE9VQkxFIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hGbG9hdERvdWJsZShcbiAgICAgIGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgMikgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyAzKSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDQpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgNSkgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyA2KSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDcpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgOCkgfCAwXSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gRVJST1IgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHJldHVybiAxXG4gIH1cblxuICBmdW5jdGlvbiBCUkVBSyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEJyZWFrKClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICAvLyAtLSBKdW1wIFRhYmxlXG5cbiAgdmFyIGp1bXBUYWJsZSA9IFtcbiAgICAvLyBJbnRlZ2VyIDB4MDAuLjB4MTcgKDAuLjIzKVxuICAgIElOVF9QLCAvLyAweDAwXG4gICAgSU5UX1AsIC8vIDB4MDFcbiAgICBJTlRfUCwgLy8gMHgwMlxuICAgIElOVF9QLCAvLyAweDAzXG4gICAgSU5UX1AsIC8vIDB4MDRcbiAgICBJTlRfUCwgLy8gMHgwNVxuICAgIElOVF9QLCAvLyAweDA2XG4gICAgSU5UX1AsIC8vIDB4MDdcbiAgICBJTlRfUCwgLy8gMHgwOFxuICAgIElOVF9QLCAvLyAweDA5XG4gICAgSU5UX1AsIC8vIDB4MEFcbiAgICBJTlRfUCwgLy8gMHgwQlxuICAgIElOVF9QLCAvLyAweDBDXG4gICAgSU5UX1AsIC8vIDB4MERcbiAgICBJTlRfUCwgLy8gMHgwRVxuICAgIElOVF9QLCAvLyAweDBGXG4gICAgSU5UX1AsIC8vIDB4MTBcbiAgICBJTlRfUCwgLy8gMHgxMVxuICAgIElOVF9QLCAvLyAweDEyXG4gICAgSU5UX1AsIC8vIDB4MTNcbiAgICBJTlRfUCwgLy8gMHgxNFxuICAgIElOVF9QLCAvLyAweDE1XG4gICAgSU5UX1AsIC8vIDB4MTZcbiAgICBJTlRfUCwgLy8gMHgxN1xuICAgIC8vIFVuc2lnbmVkIGludGVnZXIgKG9uZS1ieXRlIHVpbnQ4X3QgZm9sbG93cylcbiAgICBVSU5UX1BfOCwgLy8gMHgxOFxuICAgIC8vIFVuc2lnbmVkIGludGVnZXIgKHR3by1ieXRlIHVpbnQxNl90IGZvbGxvd3MpXG4gICAgVUlOVF9QXzE2LCAvLyAweDE5XG4gICAgLy8gVW5zaWduZWQgaW50ZWdlciAoZm91ci1ieXRlIHVpbnQzMl90IGZvbGxvd3MpXG4gICAgVUlOVF9QXzMyLCAvLyAweDFhXG4gICAgLy8gVW5zaWduZWQgaW50ZWdlciAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb2xsb3dzKVxuICAgIFVJTlRfUF82NCwgLy8gMHgxYlxuICAgIEVSUk9SLCAvLyAweDFjXG4gICAgRVJST1IsIC8vIDB4MWRcbiAgICBFUlJPUiwgLy8gMHgxZVxuICAgIEVSUk9SLCAvLyAweDFmXG4gICAgLy8gTmVnYXRpdmUgaW50ZWdlciAtMS0weDAwLi4tMS0weDE3ICgtMS4uLTI0KVxuICAgIElOVF9OLCAvLyAweDIwXG4gICAgSU5UX04sIC8vIDB4MjFcbiAgICBJTlRfTiwgLy8gMHgyMlxuICAgIElOVF9OLCAvLyAweDIzXG4gICAgSU5UX04sIC8vIDB4MjRcbiAgICBJTlRfTiwgLy8gMHgyNVxuICAgIElOVF9OLCAvLyAweDI2XG4gICAgSU5UX04sIC8vIDB4MjdcbiAgICBJTlRfTiwgLy8gMHgyOFxuICAgIElOVF9OLCAvLyAweDI5XG4gICAgSU5UX04sIC8vIDB4MkFcbiAgICBJTlRfTiwgLy8gMHgyQlxuICAgIElOVF9OLCAvLyAweDJDXG4gICAgSU5UX04sIC8vIDB4MkRcbiAgICBJTlRfTiwgLy8gMHgyRVxuICAgIElOVF9OLCAvLyAweDJGXG4gICAgSU5UX04sIC8vIDB4MzBcbiAgICBJTlRfTiwgLy8gMHgzMVxuICAgIElOVF9OLCAvLyAweDMyXG4gICAgSU5UX04sIC8vIDB4MzNcbiAgICBJTlRfTiwgLy8gMHgzNFxuICAgIElOVF9OLCAvLyAweDM1XG4gICAgSU5UX04sIC8vIDB4MzZcbiAgICBJTlRfTiwgLy8gMHgzN1xuICAgIC8vIE5lZ2F0aXZlIGludGVnZXIgLTEtbiAob25lLWJ5dGUgdWludDhfdCBmb3IgbiBmb2xsb3dzKVxuICAgIFVJTlRfTl84LCAvLyAweDM4XG4gICAgLy8gTmVnYXRpdmUgaW50ZWdlciAtMS1uICh0d28tYnl0ZSB1aW50MTZfdCBmb3IgbiBmb2xsb3dzKVxuICAgIFVJTlRfTl8xNiwgLy8gMHgzOVxuICAgIC8vIE5lZ2F0aXZlIGludGVnZXIgLTEtbiAoZm91ci1ieXRlIHVpbnQzMl90IGZvciBuZm9sbG93cylcbiAgICBVSU5UX05fMzIsIC8vIDB4M2FcbiAgICAvLyBOZWdhdGl2ZSBpbnRlZ2VyIC0xLW4gKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9yIG4gZm9sbG93cylcbiAgICBVSU5UX05fNjQsIC8vIDB4M2JcbiAgICBFUlJPUiwgLy8gMHgzY1xuICAgIEVSUk9SLCAvLyAweDNkXG4gICAgRVJST1IsIC8vIDB4M2VcbiAgICBFUlJPUiwgLy8gMHgzZlxuICAgIC8vIGJ5dGUgc3RyaW5nICgweDAwLi4weDE3IGJ5dGVzIGZvbGxvdylcbiAgICBCWVRFX1NUUklORywgLy8gMHg0MFxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQxXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDJcbiAgICBCWVRFX1NUUklORywgLy8gMHg0M1xuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQ0XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDVcbiAgICBCWVRFX1NUUklORywgLy8gMHg0NlxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQ3XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDhcbiAgICBCWVRFX1NUUklORywgLy8gMHg0OVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDRBXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NEJcbiAgICBCWVRFX1NUUklORywgLy8gMHg0Q1xuICAgIEJZVEVfU1RSSU5HLCAvLyAweDREXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NEVcbiAgICBCWVRFX1NUUklORywgLy8gMHg0RlxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDUwXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTFcbiAgICBCWVRFX1NUUklORywgLy8gMHg1MlxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDUzXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTRcbiAgICBCWVRFX1NUUklORywgLy8gMHg1NVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDU2XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTdcbiAgICAvLyBieXRlIHN0cmluZyAob25lLWJ5dGUgdWludDhfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgQllURV9TVFJJTkdfOCwgLy8gMHg1OFxuICAgIC8vIGJ5dGUgc3RyaW5nICh0d28tYnl0ZSB1aW50MTZfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgQllURV9TVFJJTkdfMTYsIC8vIDB4NTlcbiAgICAvLyBieXRlIHN0cmluZyAoZm91ci1ieXRlIHVpbnQzMl90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBCWVRFX1NUUklOR18zMiwgLy8gMHg1YVxuICAgIC8vIGJ5dGUgc3RyaW5nIChlaWdodC1ieXRlIHVpbnQ2NF90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBCWVRFX1NUUklOR182NCwgLy8gMHg1YlxuICAgIEVSUk9SLCAvLyAweDVjXG4gICAgRVJST1IsIC8vIDB4NWRcbiAgICBFUlJPUiwgLy8gMHg1ZVxuICAgIC8vIGJ5dGUgc3RyaW5nLCBieXRlIHN0cmluZ3MgZm9sbG93LCB0ZXJtaW5hdGVkIGJ5IFwiYnJlYWtcIlxuICAgIEJZVEVfU1RSSU5HX0JSRUFLLCAvLyAweDVmXG4gICAgLy8gVVRGLTggc3RyaW5nICgweDAwLi4weDE3IGJ5dGVzIGZvbGxvdylcbiAgICBVVEY4X1NUUklORywgLy8gMHg2MFxuICAgIFVURjhfU1RSSU5HLCAvLyAweDYxXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjJcbiAgICBVVEY4X1NUUklORywgLy8gMHg2M1xuICAgIFVURjhfU1RSSU5HLCAvLyAweDY0XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjVcbiAgICBVVEY4X1NUUklORywgLy8gMHg2NlxuICAgIFVURjhfU1RSSU5HLCAvLyAweDY3XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjhcbiAgICBVVEY4X1NUUklORywgLy8gMHg2OVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDZBXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NkJcbiAgICBVVEY4X1NUUklORywgLy8gMHg2Q1xuICAgIFVURjhfU1RSSU5HLCAvLyAweDZEXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NkVcbiAgICBVVEY4X1NUUklORywgLy8gMHg2RlxuICAgIFVURjhfU1RSSU5HLCAvLyAweDcwXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzFcbiAgICBVVEY4X1NUUklORywgLy8gMHg3MlxuICAgIFVURjhfU1RSSU5HLCAvLyAweDczXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzRcbiAgICBVVEY4X1NUUklORywgLy8gMHg3NVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDc2XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzdcbiAgICAvLyBVVEYtOCBzdHJpbmcgKG9uZS1ieXRlIHVpbnQ4X3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIFVURjhfU1RSSU5HXzgsIC8vIDB4NzhcbiAgICAvLyBVVEYtOCBzdHJpbmcgKHR3by1ieXRlIHVpbnQxNl90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBVVEY4X1NUUklOR18xNiwgLy8gMHg3OVxuICAgIC8vIFVURi04IHN0cmluZyAoZm91ci1ieXRlIHVpbnQzMl90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBVVEY4X1NUUklOR18zMiwgLy8gMHg3YVxuICAgIC8vIFVURi04IHN0cmluZyAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgVVRGOF9TVFJJTkdfNjQsIC8vIDB4N2JcbiAgICAvLyBVVEYtOCBzdHJpbmcsIFVURi04IHN0cmluZ3MgZm9sbG93LCB0ZXJtaW5hdGVkIGJ5IFwiYnJlYWtcIlxuICAgIEVSUk9SLCAvLyAweDdjXG4gICAgRVJST1IsIC8vIDB4N2RcbiAgICBFUlJPUiwgLy8gMHg3ZVxuICAgIFVURjhfU1RSSU5HX0JSRUFLLCAvLyAweDdmXG4gICAgLy8gYXJyYXkgKDB4MDAuLjB4MTcgZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgQVJSQVksIC8vIDB4ODBcbiAgICBBUlJBWSwgLy8gMHg4MVxuICAgIEFSUkFZLCAvLyAweDgyXG4gICAgQVJSQVksIC8vIDB4ODNcbiAgICBBUlJBWSwgLy8gMHg4NFxuICAgIEFSUkFZLCAvLyAweDg1XG4gICAgQVJSQVksIC8vIDB4ODZcbiAgICBBUlJBWSwgLy8gMHg4N1xuICAgIEFSUkFZLCAvLyAweDg4XG4gICAgQVJSQVksIC8vIDB4ODlcbiAgICBBUlJBWSwgLy8gMHg4QVxuICAgIEFSUkFZLCAvLyAweDhCXG4gICAgQVJSQVksIC8vIDB4OENcbiAgICBBUlJBWSwgLy8gMHg4RFxuICAgIEFSUkFZLCAvLyAweDhFXG4gICAgQVJSQVksIC8vIDB4OEZcbiAgICBBUlJBWSwgLy8gMHg5MFxuICAgIEFSUkFZLCAvLyAweDkxXG4gICAgQVJSQVksIC8vIDB4OTJcbiAgICBBUlJBWSwgLy8gMHg5M1xuICAgIEFSUkFZLCAvLyAweDk0XG4gICAgQVJSQVksIC8vIDB4OTVcbiAgICBBUlJBWSwgLy8gMHg5NlxuICAgIEFSUkFZLCAvLyAweDk3XG4gICAgLy8gYXJyYXkgKG9uZS1ieXRlIHVpbnQ4X3QgZm8sIGFuZCB0aGVuIG4gZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgQVJSQVlfOCwgLy8gMHg5OFxuICAgIC8vIGFycmF5ICh0d28tYnl0ZSB1aW50MTZfdCBmb3IgbiwgYW5kIHRoZW4gbiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBBUlJBWV8xNiwgLy8gMHg5OVxuICAgIC8vIGFycmF5IChmb3VyLWJ5dGUgdWludDMyX3QgZm9yIG4sIGFuZCB0aGVuIG4gZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgQVJSQVlfMzIsIC8vIDB4OWFcbiAgICAvLyBhcnJheSAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb3IgbiwgYW5kIHRoZW4gbiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBBUlJBWV82NCwgLy8gMHg5YlxuICAgIC8vIGFycmF5LCBkYXRhIGl0ZW1zIGZvbGxvdywgdGVybWluYXRlZCBieSBcImJyZWFrXCJcbiAgICBFUlJPUiwgLy8gMHg5Y1xuICAgIEVSUk9SLCAvLyAweDlkXG4gICAgRVJST1IsIC8vIDB4OWVcbiAgICBBUlJBWV9CUkVBSywgLy8gMHg5ZlxuICAgIC8vIG1hcCAoMHgwMC4uMHgxNyBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBNQVAsIC8vIDB4YTBcbiAgICBNQVAsIC8vIDB4YTFcbiAgICBNQVAsIC8vIDB4YTJcbiAgICBNQVAsIC8vIDB4YTNcbiAgICBNQVAsIC8vIDB4YTRcbiAgICBNQVAsIC8vIDB4YTVcbiAgICBNQVAsIC8vIDB4YTZcbiAgICBNQVAsIC8vIDB4YTdcbiAgICBNQVAsIC8vIDB4YThcbiAgICBNQVAsIC8vIDB4YTlcbiAgICBNQVAsIC8vIDB4YUFcbiAgICBNQVAsIC8vIDB4YUJcbiAgICBNQVAsIC8vIDB4YUNcbiAgICBNQVAsIC8vIDB4YURcbiAgICBNQVAsIC8vIDB4YUVcbiAgICBNQVAsIC8vIDB4YUZcbiAgICBNQVAsIC8vIDB4YjBcbiAgICBNQVAsIC8vIDB4YjFcbiAgICBNQVAsIC8vIDB4YjJcbiAgICBNQVAsIC8vIDB4YjNcbiAgICBNQVAsIC8vIDB4YjRcbiAgICBNQVAsIC8vIDB4YjVcbiAgICBNQVAsIC8vIDB4YjZcbiAgICBNQVAsIC8vIDB4YjdcbiAgICAvLyBtYXAgKG9uZS1ieXRlIHVpbnQ4X3QgZm9yIG4sIGFuZCB0aGVuIG4gcGFpcnMgb2YgZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgTUFQXzgsIC8vIDB4YjhcbiAgICAvLyBtYXAgKHR3by1ieXRlIHVpbnQxNl90IGZvciBuLCBhbmQgdGhlbiBuIHBhaXJzIG9mIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIE1BUF8xNiwgLy8gMHhiOVxuICAgIC8vIG1hcCAoZm91ci1ieXRlIHVpbnQzMl90IGZvciBuLCBhbmQgdGhlbiBuIHBhaXJzIG9mIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIE1BUF8zMiwgLy8gMHhiYVxuICAgIC8vIG1hcCAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb3IgbiwgYW5kIHRoZW4gbiBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBNQVBfNjQsIC8vIDB4YmJcbiAgICBFUlJPUiwgLy8gMHhiY1xuICAgIEVSUk9SLCAvLyAweGJkXG4gICAgRVJST1IsIC8vIDB4YmVcbiAgICAvLyBtYXAsIHBhaXJzIG9mIGRhdGEgaXRlbXMgZm9sbG93LCB0ZXJtaW5hdGVkIGJ5IFwiYnJlYWtcIlxuICAgIE1BUF9CUkVBSywgLy8gMHhiZlxuICAgIC8vIFRleHQtYmFzZWQgZGF0ZS90aW1lIChkYXRhIGl0ZW0gZm9sbG93czsgc2VlIFNlY3Rpb24gMi40LjEpXG4gICAgVEFHX0tOT1dOLCAvLyAweGMwXG4gICAgLy8gRXBvY2gtYmFzZWQgZGF0ZS90aW1lIChkYXRhIGl0ZW0gZm9sbG93czsgc2VlIFNlY3Rpb24gMi40LjEpXG4gICAgVEFHX0tOT1dOLCAvLyAweGMxXG4gICAgLy8gUG9zaXRpdmUgYmlnbnVtIChkYXRhIGl0ZW0gXCJieXRlIHN0cmluZ1wiIGZvbGxvd3MpXG4gICAgVEFHX0tOT1dOLCAvLyAweGMyXG4gICAgLy8gTmVnYXRpdmUgYmlnbnVtIChkYXRhIGl0ZW0gXCJieXRlIHN0cmluZ1wiIGZvbGxvd3MpXG4gICAgVEFHX0tOT1dOLCAvLyAweGMzXG4gICAgLy8gRGVjaW1hbCBGcmFjdGlvbiAoZGF0YSBpdGVtIFwiYXJyYXlcIiBmb2xsb3dzOyBzZWUgU2VjdGlvbiAyLjQuMylcbiAgICBUQUdfS05PV04sIC8vIDB4YzRcbiAgICAvLyBCaWdmbG9hdCAoZGF0YSBpdGVtIFwiYXJyYXlcIiBmb2xsb3dzOyBzZWUgU2VjdGlvbiAyLjQuMylcbiAgICBUQUdfS05PV04sIC8vIDB4YzVcbiAgICAvLyAodGFnZ2VkIGl0ZW0pXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4YzZcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjN1xuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGM4XG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4YzlcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjYVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGNiXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4Y2NcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjZFxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGNlXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4Y2ZcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkMFxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQxXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDJcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkM1xuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQ0XG4gICAgLy8gRXhwZWN0ZWQgQ29udmVyc2lvbiAoZGF0YSBpdGVtIGZvbGxvd3M7IHNlZSBTZWN0aW9uIDIuNC40LjIpXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDVcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkNlxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQ3XG4gICAgLy8gKG1vcmUgdGFnZ2VkIGl0ZW1zLCAxLzIvNC84IGJ5dGVzIGFuZCB0aGVuIGEgZGF0YSBpdGVtIGZvbGxvdylcbiAgICBUQUdfTU9SRV8xLCAvLyAweGQ4XG4gICAgVEFHX01PUkVfMiwgLy8gMHhkOVxuICAgIFRBR19NT1JFXzQsIC8vIDB4ZGFcbiAgICBUQUdfTU9SRV84LCAvLyAweGRiXG4gICAgRVJST1IsIC8vIDB4ZGNcbiAgICBFUlJPUiwgLy8gMHhkZFxuICAgIEVSUk9SLCAvLyAweGRlXG4gICAgRVJST1IsIC8vIDB4ZGZcbiAgICAvLyAoc2ltcGxlIHZhbHVlKVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGUwXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTFcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlMlxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGUzXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTRcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlNVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGU2XG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTdcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlOFxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGU5XG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZWFcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlYlxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGVjXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZWRcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlZVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGVmXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZjBcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhmMVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGYyXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZjNcbiAgICAvLyBGYWxzZVxuICAgIFNJTVBMRV9GQUxTRSwgLy8gMHhmNFxuICAgIC8vIFRydWVcbiAgICBTSU1QTEVfVFJVRSwgLy8gMHhmNVxuICAgIC8vIE51bGxcbiAgICBTSU1QTEVfTlVMTCwgLy8gMHhmNlxuICAgIC8vIFVuZGVmaW5lZFxuICAgIFNJTVBMRV9VTkRFRklORUQsIC8vIDB4ZjdcbiAgICAvLyAoc2ltcGxlIHZhbHVlLCBvbmUgYnl0ZSBmb2xsb3dzKVxuICAgIFNJTVBMRV9CWVRFLCAvLyAweGY4XG4gICAgLy8gSGFsZi1QcmVjaXNpb24gRmxvYXQgKHR3by1ieXRlIElFRUUgNzU0KVxuICAgIFNJTVBMRV9GTE9BVF9IQUxGLCAvLyAweGY5XG4gICAgLy8gU2luZ2xlLVByZWNpc2lvbiBGbG9hdCAoZm91ci1ieXRlIElFRUUgNzU0KVxuICAgIFNJTVBMRV9GTE9BVF9TSU5HTEUsIC8vIDB4ZmFcbiAgICAvLyBEb3VibGUtUHJlY2lzaW9uIEZsb2F0IChlaWdodC1ieXRlIElFRUUgNzU0KVxuICAgIFNJTVBMRV9GTE9BVF9ET1VCTEUsIC8vIDB4ZmJcbiAgICBFUlJPUiwgLy8gMHhmY1xuICAgIEVSUk9SLCAvLyAweGZkXG4gICAgRVJST1IsIC8vIDB4ZmVcbiAgICAvLyBcImJyZWFrXCIgc3RvcCBjb2RlXG4gICAgQlJFQUsgLy8gMHhmZlxuICBdXG5cbiAgLy8gLS1cblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBwYXJzZVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/decoder.asm.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/decoder.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/decoder.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"./node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst parser = __webpack_require__(/*! ./decoder.asm */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/decoder.asm.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/utils.js\")\nconst c = __webpack_require__(/*! ./constants */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/constants.js\")\nconst Simple = __webpack_require__(/*! ./simple */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/simple.js\")\nconst Tagged = __webpack_require__(/*! ./tagged */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/tagged.js\")\nconst { URL } = __webpack_require__(/*! iso-url */ \"./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/index.js\")\n\n/**\n * Transform binary cbor data into JavaScript objects.\n */\nclass Decoder {\n  /**\n   * @param {Object} [opts={}]\n   * @param {number} [opts.size=65536] - Size of the allocated heap.\n   */\n  constructor (opts) {\n    opts = opts || {}\n\n    if (!opts.size || opts.size < 0x10000) {\n      opts.size = 0x10000\n    } else {\n      // Ensure the size is a power of 2\n      opts.size = utils.nextPowerOf2(opts.size)\n    }\n\n    // Heap use to share the input with the parser\n    this._heap = new ArrayBuffer(opts.size)\n    this._heap8 = new Uint8Array(this._heap)\n    this._buffer = Buffer.from(this._heap)\n\n    this._reset()\n\n    // Known tags\n    this._knownTags = Object.assign({\n      0: (val) => new Date(val),\n      1: (val) => new Date(val * 1000),\n      2: (val) => utils.arrayBufferToBignumber(val),\n      3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),\n      4: (v) => {\n        // const v = new Uint8Array(val)\n        return c.TEN.pow(v[0]).times(v[1])\n      },\n      5: (v) => {\n        // const v = new Uint8Array(val)\n        return c.TWO.pow(v[0]).times(v[1])\n      },\n      32: (val) => new URL(val),\n      35: (val) => new RegExp(val)\n    }, opts.tags)\n\n    // Initialize asm based parser\n    this.parser = parser(__webpack_require__.g, {\n      // eslint-disable-next-line no-console\n      log: console.log.bind(console),\n      pushInt: this.pushInt.bind(this),\n      pushInt32: this.pushInt32.bind(this),\n      pushInt32Neg: this.pushInt32Neg.bind(this),\n      pushInt64: this.pushInt64.bind(this),\n      pushInt64Neg: this.pushInt64Neg.bind(this),\n      pushFloat: this.pushFloat.bind(this),\n      pushFloatSingle: this.pushFloatSingle.bind(this),\n      pushFloatDouble: this.pushFloatDouble.bind(this),\n      pushTrue: this.pushTrue.bind(this),\n      pushFalse: this.pushFalse.bind(this),\n      pushUndefined: this.pushUndefined.bind(this),\n      pushNull: this.pushNull.bind(this),\n      pushInfinity: this.pushInfinity.bind(this),\n      pushInfinityNeg: this.pushInfinityNeg.bind(this),\n      pushNaN: this.pushNaN.bind(this),\n      pushNaNNeg: this.pushNaNNeg.bind(this),\n      pushArrayStart: this.pushArrayStart.bind(this),\n      pushArrayStartFixed: this.pushArrayStartFixed.bind(this),\n      pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),\n      pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),\n      pushObjectStart: this.pushObjectStart.bind(this),\n      pushObjectStartFixed: this.pushObjectStartFixed.bind(this),\n      pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),\n      pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),\n      pushByteString: this.pushByteString.bind(this),\n      pushByteStringStart: this.pushByteStringStart.bind(this),\n      pushUtf8String: this.pushUtf8String.bind(this),\n      pushUtf8StringStart: this.pushUtf8StringStart.bind(this),\n      pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),\n      pushTagUnassigned: this.pushTagUnassigned.bind(this),\n      pushTagStart: this.pushTagStart.bind(this),\n      pushTagStart4: this.pushTagStart4.bind(this),\n      pushTagStart8: this.pushTagStart8.bind(this),\n      pushBreak: this.pushBreak.bind(this)\n    }, this._heap)\n  }\n\n  get _depth () {\n    return this._parents.length\n  }\n\n  get _currentParent () {\n    return this._parents[this._depth - 1]\n  }\n\n  get _ref () {\n    return this._currentParent.ref\n  }\n\n  // Finish the current parent\n  _closeParent () {\n    var p = this._parents.pop()\n\n    if (p.length > 0) {\n      throw new Error(`Missing ${p.length} elements`)\n    }\n\n    switch (p.type) {\n      case c.PARENT.TAG:\n        this._push(\n          this.createTag(p.ref[0], p.ref[1])\n        )\n        break\n      case c.PARENT.BYTE_STRING:\n        this._push(this.createByteString(p.ref, p.length))\n        break\n      case c.PARENT.UTF8_STRING:\n        this._push(this.createUtf8String(p.ref, p.length))\n        break\n      case c.PARENT.MAP:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map')\n        }\n        this._push(this.createMap(p.ref, p.length))\n        break\n      case c.PARENT.OBJECT:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map')\n        }\n        this._push(this.createObject(p.ref, p.length))\n        break\n      case c.PARENT.ARRAY:\n        this._push(this.createArray(p.ref, p.length))\n        break\n      default:\n        break\n    }\n\n    if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {\n      this._dec()\n    }\n  }\n\n  // Reduce the expected length of the current parent by one\n  _dec () {\n    const p = this._currentParent\n    // The current parent does not know the epxected child length\n\n    if (p.length < 0) {\n      return\n    }\n\n    p.length--\n\n    // All children were seen, we can close the current parent\n    if (p.length === 0) {\n      this._closeParent()\n    }\n  }\n\n  // Push any value to the current parent\n  _push (val, hasChildren) {\n    const p = this._currentParent\n    p.values++\n\n    switch (p.type) {\n      case c.PARENT.ARRAY:\n      case c.PARENT.BYTE_STRING:\n      case c.PARENT.UTF8_STRING:\n        if (p.length > -1) {\n          this._ref[this._ref.length - p.length] = val\n        } else {\n          this._ref.push(val)\n        }\n        this._dec()\n        break\n      case c.PARENT.OBJECT:\n        if (p.tmpKey != null) {\n          this._ref[p.tmpKey] = val\n          p.tmpKey = null\n          this._dec()\n        } else {\n          p.tmpKey = val\n\n          if (typeof p.tmpKey !== 'string') {\n            // too bad, convert to a Map\n            p.type = c.PARENT.MAP\n            p.ref = utils.buildMap(p.ref)\n          }\n        }\n        break\n      case c.PARENT.MAP:\n        if (p.tmpKey != null) {\n          this._ref.set(p.tmpKey, val)\n          p.tmpKey = null\n          this._dec()\n        } else {\n          p.tmpKey = val\n        }\n        break\n      case c.PARENT.TAG:\n        this._ref.push(val)\n        if (!hasChildren) {\n          this._dec()\n        }\n        break\n      default:\n        throw new Error('Unknown parent type')\n    }\n  }\n\n  // Create a new parent in the parents list\n  _createParent (obj, type, len) {\n    this._parents[this._depth] = {\n      type: type,\n      length: len,\n      ref: obj,\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  // Reset all state back to the beginning, also used for initiatlization\n  _reset () {\n    this._res = []\n    this._parents = [{\n      type: c.PARENT.ARRAY,\n      length: -1,\n      ref: this._res,\n      values: 0,\n      tmpKey: null\n    }]\n  }\n\n  // -- Interface to customize deoding behaviour\n  createTag (tagNumber, value) {\n    const typ = this._knownTags[tagNumber]\n\n    if (!typ) {\n      return new Tagged(tagNumber, value)\n    }\n\n    return typ(value)\n  }\n\n  createMap (obj, len) {\n    return obj\n  }\n\n  createObject (obj, len) {\n    return obj\n  }\n\n  createArray (arr, len) {\n    return arr\n  }\n\n  createByteString (raw, len) {\n    return Buffer.concat(raw)\n  }\n\n  createByteStringFromHeap (start, end) {\n    if (start === end) {\n      return Buffer.alloc(0)\n    }\n\n    return Buffer.from(this._heap.slice(start, end))\n  }\n\n  createInt (val) {\n    return val\n  }\n\n  createInt32 (f, g) {\n    return utils.buildInt32(f, g)\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return utils.buildInt64(f1, f2, g1, g2)\n  }\n\n  createFloat (val) {\n    return val\n  }\n\n  createFloatSingle (a, b, c, d) {\n    return ieee754.read([a, b, c, d], 0, false, 23, 4)\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    return ieee754.read([a, b, c, d, e, f, g, h], 0, false, 52, 8)\n  }\n\n  createInt32Neg (f, g) {\n    return -1 - utils.buildInt32(f, g)\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    const f = utils.buildInt32(f1, f2)\n    const g = utils.buildInt32(g1, g2)\n\n    if (f > c.MAX_SAFE_HIGH) {\n      return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g))\n    }\n\n    return -1 - ((f * c.SHIFT32) + g)\n  }\n\n  createTrue () {\n    return true\n  }\n\n  createFalse () {\n    return false\n  }\n\n  createNull () {\n    return null\n  }\n\n  createUndefined () {\n    return undefined\n  }\n\n  createInfinity () {\n    return Infinity\n  }\n\n  createInfinityNeg () {\n    return -Infinity\n  }\n\n  createNaN () {\n    return NaN\n  }\n\n  createNaNNeg () {\n    return -NaN\n  }\n\n  createUtf8String (raw, len) {\n    return raw.join('')\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    if (start === end) {\n      return ''\n    }\n\n    return this._buffer.toString('utf8', start, end)\n  }\n\n  createSimpleUnassigned (val) {\n    return new Simple(val)\n  }\n\n  // -- Interface for decoder.asm.js\n\n  pushInt (val) {\n    this._push(this.createInt(val))\n  }\n\n  pushInt32 (f, g) {\n    this._push(this.createInt32(f, g))\n  }\n\n  pushInt64 (f1, f2, g1, g2) {\n    this._push(this.createInt64(f1, f2, g1, g2))\n  }\n\n  pushFloat (val) {\n    this._push(this.createFloat(val))\n  }\n\n  pushFloatSingle (a, b, c, d) {\n    this._push(this.createFloatSingle(a, b, c, d))\n  }\n\n  pushFloatDouble (a, b, c, d, e, f, g, h) {\n    this._push(this.createFloatDouble(a, b, c, d, e, f, g, h))\n  }\n\n  pushInt32Neg (f, g) {\n    this._push(this.createInt32Neg(f, g))\n  }\n\n  pushInt64Neg (f1, f2, g1, g2) {\n    this._push(this.createInt64Neg(f1, f2, g1, g2))\n  }\n\n  pushTrue () {\n    this._push(this.createTrue())\n  }\n\n  pushFalse () {\n    this._push(this.createFalse())\n  }\n\n  pushNull () {\n    this._push(this.createNull())\n  }\n\n  pushUndefined () {\n    this._push(this.createUndefined())\n  }\n\n  pushInfinity () {\n    this._push(this.createInfinity())\n  }\n\n  pushInfinityNeg () {\n    this._push(this.createInfinityNeg())\n  }\n\n  pushNaN () {\n    this._push(this.createNaN())\n  }\n\n  pushNaNNeg () {\n    this._push(this.createNaNNeg())\n  }\n\n  pushArrayStart () {\n    this._createParent([], c.PARENT.ARRAY, -1)\n  }\n\n  pushArrayStartFixed (len) {\n    this._createArrayStartFixed(len)\n  }\n\n  pushArrayStartFixed32 (len1, len2) {\n    const len = utils.buildInt32(len1, len2)\n    this._createArrayStartFixed(len)\n  }\n\n  pushArrayStartFixed64 (len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4)\n    this._createArrayStartFixed(len)\n  }\n\n  pushObjectStart () {\n    this._createObjectStartFixed(-1)\n  }\n\n  pushObjectStartFixed (len) {\n    this._createObjectStartFixed(len)\n  }\n\n  pushObjectStartFixed32 (len1, len2) {\n    const len = utils.buildInt32(len1, len2)\n    this._createObjectStartFixed(len)\n  }\n\n  pushObjectStartFixed64 (len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4)\n    this._createObjectStartFixed(len)\n  }\n\n  pushByteStringStart () {\n    this._parents[this._depth] = {\n      type: c.PARENT.BYTE_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  pushByteString (start, end) {\n    this._push(this.createByteStringFromHeap(start, end))\n  }\n\n  pushUtf8StringStart () {\n    this._parents[this._depth] = {\n      type: c.PARENT.UTF8_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  pushUtf8String (start, end) {\n    this._push(this.createUtf8StringFromHeap(start, end))\n  }\n\n  pushSimpleUnassigned (val) {\n    this._push(this.createSimpleUnassigned(val))\n  }\n\n  pushTagStart (tag) {\n    this._parents[this._depth] = {\n      type: c.PARENT.TAG,\n      length: 1,\n      ref: [tag]\n    }\n  }\n\n  pushTagStart4 (f, g) {\n    this.pushTagStart(utils.buildInt32(f, g))\n  }\n\n  pushTagStart8 (f1, f2, g1, g2) {\n    this.pushTagStart(utils.buildInt64(f1, f2, g1, g2))\n  }\n\n  pushTagUnassigned (tagNumber) {\n    this._push(this.createTag(tagNumber))\n  }\n\n  pushBreak () {\n    if (this._currentParent.length > -1) {\n      throw new Error('Unexpected break')\n    }\n\n    this._closeParent()\n  }\n\n  _createObjectStartFixed (len) {\n    if (len === 0) {\n      this._push(this.createObject({}))\n      return\n    }\n\n    this._createParent({}, c.PARENT.OBJECT, len)\n  }\n\n  _createArrayStartFixed (len) {\n    if (len === 0) {\n      this._push(this.createArray([]))\n      return\n    }\n\n    this._createParent(new Array(len), c.PARENT.ARRAY, len)\n  }\n\n  _decode (input) {\n    if (input.byteLength === 0) {\n      throw new Error('Input too short')\n    }\n\n    this._reset()\n    this._heap8.set(input)\n    const code = this.parser.parse(input.byteLength)\n\n    if (this._depth > 1) {\n      while (this._currentParent.length === 0) {\n        this._closeParent()\n      }\n      if (this._depth > 1) {\n        throw new Error('Undeterminated nesting')\n      }\n    }\n\n    if (code > 0) {\n      throw new Error('Failed to parse')\n    }\n\n    if (this._res.length === 0) {\n      throw new Error('No valid result')\n    }\n  }\n\n  // -- Public Interface\n\n  decodeFirst (input) {\n    this._decode(input)\n\n    return this._res[0]\n  }\n\n  decodeAll (input) {\n    this._decode(input)\n\n    return this._res\n  }\n\n  /**\n   * Decode the first cbor object.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {*}\n   */\n  static decode (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Decoder({ size: input.length })\n    return dec.decodeFirst(input)\n  }\n\n  /**\n   * Decode all cbor objects.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {Array<*>}\n   */\n  static decodeAll (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Decoder({ size: input.length })\n    return dec.decodeAll(input)\n  }\n}\n\nDecoder.decodeFirst = Decoder.decode\n\nmodule.exports = Decoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yY0AyLjEuMi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDhFQUFRO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLGlGQUFTO0FBQ2pDLGtCQUFrQixxSUFBaUM7O0FBRW5ELGVBQWUsbUJBQU8sQ0FBQywyRkFBZTtBQUN0QyxjQUFjLG1CQUFPLENBQUMsK0VBQVM7QUFDL0IsVUFBVSxtQkFBTyxDQUFDLHVGQUFhO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxpRkFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsaUZBQVU7QUFDakMsUUFBUSxNQUFNLEVBQUUsbUJBQU8sQ0FBQyxpRkFBUzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSxRQUFRO0FBQzdCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlCQUF5QixxQkFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL2JvcmNAMi4xLjIvbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RlY29kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgQmlnbnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJykuQmlnTnVtYmVyXG5cbmNvbnN0IHBhcnNlciA9IHJlcXVpcmUoJy4vZGVjb2Rlci5hc20nKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IGMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBTaW1wbGUgPSByZXF1aXJlKCcuL3NpbXBsZScpXG5jb25zdCBUYWdnZWQgPSByZXF1aXJlKCcuL3RhZ2dlZCcpXG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgnaXNvLXVybCcpXG5cbi8qKlxuICogVHJhbnNmb3JtIGJpbmFyeSBjYm9yIGRhdGEgaW50byBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmNsYXNzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuc2l6ZT02NTUzNl0gLSBTaXplIG9mIHRoZSBhbGxvY2F0ZWQgaGVhcC5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgIGlmICghb3B0cy5zaXplIHx8IG9wdHMuc2l6ZSA8IDB4MTAwMDApIHtcbiAgICAgIG9wdHMuc2l6ZSA9IDB4MTAwMDBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRW5zdXJlIHRoZSBzaXplIGlzIGEgcG93ZXIgb2YgMlxuICAgICAgb3B0cy5zaXplID0gdXRpbHMubmV4dFBvd2VyT2YyKG9wdHMuc2l6ZSlcbiAgICB9XG5cbiAgICAvLyBIZWFwIHVzZSB0byBzaGFyZSB0aGUgaW5wdXQgd2l0aCB0aGUgcGFyc2VyXG4gICAgdGhpcy5faGVhcCA9IG5ldyBBcnJheUJ1ZmZlcihvcHRzLnNpemUpXG4gICAgdGhpcy5faGVhcDggPSBuZXcgVWludDhBcnJheSh0aGlzLl9oZWFwKVxuICAgIHRoaXMuX2J1ZmZlciA9IEJ1ZmZlci5mcm9tKHRoaXMuX2hlYXApXG5cbiAgICB0aGlzLl9yZXNldCgpXG5cbiAgICAvLyBLbm93biB0YWdzXG4gICAgdGhpcy5fa25vd25UYWdzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAwOiAodmFsKSA9PiBuZXcgRGF0ZSh2YWwpLFxuICAgICAgMTogKHZhbCkgPT4gbmV3IERhdGUodmFsICogMTAwMCksXG4gICAgICAyOiAodmFsKSA9PiB1dGlscy5hcnJheUJ1ZmZlclRvQmlnbnVtYmVyKHZhbCksXG4gICAgICAzOiAodmFsKSA9PiBjLk5FR19PTkUubWludXModXRpbHMuYXJyYXlCdWZmZXJUb0JpZ251bWJlcih2YWwpKSxcbiAgICAgIDQ6ICh2KSA9PiB7XG4gICAgICAgIC8vIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheSh2YWwpXG4gICAgICAgIHJldHVybiBjLlRFTi5wb3codlswXSkudGltZXModlsxXSlcbiAgICAgIH0sXG4gICAgICA1OiAodikgPT4ge1xuICAgICAgICAvLyBjb25zdCB2ID0gbmV3IFVpbnQ4QXJyYXkodmFsKVxuICAgICAgICByZXR1cm4gYy5UV08ucG93KHZbMF0pLnRpbWVzKHZbMV0pXG4gICAgICB9LFxuICAgICAgMzI6ICh2YWwpID0+IG5ldyBVUkwodmFsKSxcbiAgICAgIDM1OiAodmFsKSA9PiBuZXcgUmVnRXhwKHZhbClcbiAgICB9LCBvcHRzLnRhZ3MpXG5cbiAgICAvLyBJbml0aWFsaXplIGFzbSBiYXNlZCBwYXJzZXJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcihnbG9iYWwsIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBsb2c6IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXG4gICAgICBwdXNoSW50OiB0aGlzLnB1c2hJbnQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hJbnQzMjogdGhpcy5wdXNoSW50MzIuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hJbnQzMk5lZzogdGhpcy5wdXNoSW50MzJOZWcuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hJbnQ2NDogdGhpcy5wdXNoSW50NjQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hJbnQ2NE5lZzogdGhpcy5wdXNoSW50NjROZWcuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hGbG9hdDogdGhpcy5wdXNoRmxvYXQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hGbG9hdFNpbmdsZTogdGhpcy5wdXNoRmxvYXRTaW5nbGUuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hGbG9hdERvdWJsZTogdGhpcy5wdXNoRmxvYXREb3VibGUuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hUcnVlOiB0aGlzLnB1c2hUcnVlLmJpbmQodGhpcyksXG4gICAgICBwdXNoRmFsc2U6IHRoaXMucHVzaEZhbHNlLmJpbmQodGhpcyksXG4gICAgICBwdXNoVW5kZWZpbmVkOiB0aGlzLnB1c2hVbmRlZmluZWQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hOdWxsOiB0aGlzLnB1c2hOdWxsLmJpbmQodGhpcyksXG4gICAgICBwdXNoSW5maW5pdHk6IHRoaXMucHVzaEluZmluaXR5LmJpbmQodGhpcyksXG4gICAgICBwdXNoSW5maW5pdHlOZWc6IHRoaXMucHVzaEluZmluaXR5TmVnLmJpbmQodGhpcyksXG4gICAgICBwdXNoTmFOOiB0aGlzLnB1c2hOYU4uYmluZCh0aGlzKSxcbiAgICAgIHB1c2hOYU5OZWc6IHRoaXMucHVzaE5hTk5lZy5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEFycmF5U3RhcnQ6IHRoaXMucHVzaEFycmF5U3RhcnQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hBcnJheVN0YXJ0Rml4ZWQ6IHRoaXMucHVzaEFycmF5U3RhcnRGaXhlZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEFycmF5U3RhcnRGaXhlZDMyOiB0aGlzLnB1c2hBcnJheVN0YXJ0Rml4ZWQzMi5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEFycmF5U3RhcnRGaXhlZDY0OiB0aGlzLnB1c2hBcnJheVN0YXJ0Rml4ZWQ2NC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE9iamVjdFN0YXJ0OiB0aGlzLnB1c2hPYmplY3RTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQ6IHRoaXMucHVzaE9iamVjdFN0YXJ0Rml4ZWQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hPYmplY3RTdGFydEZpeGVkMzI6IHRoaXMucHVzaE9iamVjdFN0YXJ0Rml4ZWQzMi5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQ2NDogdGhpcy5wdXNoT2JqZWN0U3RhcnRGaXhlZDY0LmJpbmQodGhpcyksXG4gICAgICBwdXNoQnl0ZVN0cmluZzogdGhpcy5wdXNoQnl0ZVN0cmluZy5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEJ5dGVTdHJpbmdTdGFydDogdGhpcy5wdXNoQnl0ZVN0cmluZ1N0YXJ0LmJpbmQodGhpcyksXG4gICAgICBwdXNoVXRmOFN0cmluZzogdGhpcy5wdXNoVXRmOFN0cmluZy5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFV0ZjhTdHJpbmdTdGFydDogdGhpcy5wdXNoVXRmOFN0cmluZ1N0YXJ0LmJpbmQodGhpcyksXG4gICAgICBwdXNoU2ltcGxlVW5hc3NpZ25lZDogdGhpcy5wdXNoU2ltcGxlVW5hc3NpZ25lZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRhZ1VuYXNzaWduZWQ6IHRoaXMucHVzaFRhZ1VuYXNzaWduZWQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hUYWdTdGFydDogdGhpcy5wdXNoVGFnU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hUYWdTdGFydDQ6IHRoaXMucHVzaFRhZ1N0YXJ0NC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRhZ1N0YXJ0ODogdGhpcy5wdXNoVGFnU3RhcnQ4LmJpbmQodGhpcyksXG4gICAgICBwdXNoQnJlYWs6IHRoaXMucHVzaEJyZWFrLmJpbmQodGhpcylcbiAgICB9LCB0aGlzLl9oZWFwKVxuICB9XG5cbiAgZ2V0IF9kZXB0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudHMubGVuZ3RoXG4gIH1cblxuICBnZXQgX2N1cnJlbnRQYXJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRzW3RoaXMuX2RlcHRoIC0gMV1cbiAgfVxuXG4gIGdldCBfcmVmICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFBhcmVudC5yZWZcbiAgfVxuXG4gIC8vIEZpbmlzaCB0aGUgY3VycmVudCBwYXJlbnRcbiAgX2Nsb3NlUGFyZW50ICgpIHtcbiAgICB2YXIgcCA9IHRoaXMuX3BhcmVudHMucG9wKClcblxuICAgIGlmIChwLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyAke3AubGVuZ3RofSBlbGVtZW50c2ApXG4gICAgfVxuXG4gICAgc3dpdGNoIChwLnR5cGUpIHtcbiAgICAgIGNhc2UgYy5QQVJFTlQuVEFHOlxuICAgICAgICB0aGlzLl9wdXNoKFxuICAgICAgICAgIHRoaXMuY3JlYXRlVGFnKHAucmVmWzBdLCBwLnJlZlsxXSlcbiAgICAgICAgKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5CWVRFX1NUUklORzpcbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUJ5dGVTdHJpbmcocC5yZWYsIHAubGVuZ3RoKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuVVRGOF9TVFJJTkc6XG4gICAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVVdGY4U3RyaW5nKHAucmVmLCBwLmxlbmd0aCkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULk1BUDpcbiAgICAgICAgaWYgKHAudmFsdWVzICUgMiA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09kZCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIG1hcCcpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZU1hcChwLnJlZiwgcC5sZW5ndGgpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5PQkpFQ1Q6XG4gICAgICAgIGlmIChwLnZhbHVlcyAlIDIgPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPZGQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBtYXAnKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVPYmplY3QocC5yZWYsIHAubGVuZ3RoKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuQVJSQVk6XG4gICAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVBcnJheShwLnJlZiwgcC5sZW5ndGgpKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFBhcmVudCAmJiB0aGlzLl9jdXJyZW50UGFyZW50LnR5cGUgPT09IGMuUEFSRU5ULlRBRykge1xuICAgICAgdGhpcy5fZGVjKClcbiAgICB9XG4gIH1cblxuICAvLyBSZWR1Y2UgdGhlIGV4cGVjdGVkIGxlbmd0aCBvZiB0aGUgY3VycmVudCBwYXJlbnQgYnkgb25lXG4gIF9kZWMgKCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLl9jdXJyZW50UGFyZW50XG4gICAgLy8gVGhlIGN1cnJlbnQgcGFyZW50IGRvZXMgbm90IGtub3cgdGhlIGVweGVjdGVkIGNoaWxkIGxlbmd0aFxuXG4gICAgaWYgKHAubGVuZ3RoIDwgMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcC5sZW5ndGgtLVxuXG4gICAgLy8gQWxsIGNoaWxkcmVuIHdlcmUgc2Vlbiwgd2UgY2FuIGNsb3NlIHRoZSBjdXJyZW50IHBhcmVudFxuICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fY2xvc2VQYXJlbnQoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggYW55IHZhbHVlIHRvIHRoZSBjdXJyZW50IHBhcmVudFxuICBfcHVzaCAodmFsLCBoYXNDaGlsZHJlbikge1xuICAgIGNvbnN0IHAgPSB0aGlzLl9jdXJyZW50UGFyZW50XG4gICAgcC52YWx1ZXMrK1xuXG4gICAgc3dpdGNoIChwLnR5cGUpIHtcbiAgICAgIGNhc2UgYy5QQVJFTlQuQVJSQVk6XG4gICAgICBjYXNlIGMuUEFSRU5ULkJZVEVfU1RSSU5HOlxuICAgICAgY2FzZSBjLlBBUkVOVC5VVEY4X1NUUklORzpcbiAgICAgICAgaWYgKHAubGVuZ3RoID4gLTEpIHtcbiAgICAgICAgICB0aGlzLl9yZWZbdGhpcy5fcmVmLmxlbmd0aCAtIHAubGVuZ3RoXSA9IHZhbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlZi5wdXNoKHZhbClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWMoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5PQkpFQ1Q6XG4gICAgICAgIGlmIChwLnRtcEtleSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fcmVmW3AudG1wS2V5XSA9IHZhbFxuICAgICAgICAgIHAudG1wS2V5ID0gbnVsbFxuICAgICAgICAgIHRoaXMuX2RlYygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcC50bXBLZXkgPSB2YWxcblxuICAgICAgICAgIGlmICh0eXBlb2YgcC50bXBLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyB0b28gYmFkLCBjb252ZXJ0IHRvIGEgTWFwXG4gICAgICAgICAgICBwLnR5cGUgPSBjLlBBUkVOVC5NQVBcbiAgICAgICAgICAgIHAucmVmID0gdXRpbHMuYnVpbGRNYXAocC5yZWYpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULk1BUDpcbiAgICAgICAgaWYgKHAudG1wS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9yZWYuc2V0KHAudG1wS2V5LCB2YWwpXG4gICAgICAgICAgcC50bXBLZXkgPSBudWxsXG4gICAgICAgICAgdGhpcy5fZGVjKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwLnRtcEtleSA9IHZhbFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULlRBRzpcbiAgICAgICAgdGhpcy5fcmVmLnB1c2godmFsKVxuICAgICAgICBpZiAoIWhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgdGhpcy5fZGVjKClcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBhcmVudCB0eXBlJylcbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgcGFyZW50IGluIHRoZSBwYXJlbnRzIGxpc3RcbiAgX2NyZWF0ZVBhcmVudCAob2JqLCB0eXBlLCBsZW4pIHtcbiAgICB0aGlzLl9wYXJlbnRzW3RoaXMuX2RlcHRoXSA9IHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBsZW5ndGg6IGxlbixcbiAgICAgIHJlZjogb2JqLFxuICAgICAgdmFsdWVzOiAwLFxuICAgICAgdG1wS2V5OiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gUmVzZXQgYWxsIHN0YXRlIGJhY2sgdG8gdGhlIGJlZ2lubmluZywgYWxzbyB1c2VkIGZvciBpbml0aWF0bGl6YXRpb25cbiAgX3Jlc2V0ICgpIHtcbiAgICB0aGlzLl9yZXMgPSBbXVxuICAgIHRoaXMuX3BhcmVudHMgPSBbe1xuICAgICAgdHlwZTogYy5QQVJFTlQuQVJSQVksXG4gICAgICBsZW5ndGg6IC0xLFxuICAgICAgcmVmOiB0aGlzLl9yZXMsXG4gICAgICB2YWx1ZXM6IDAsXG4gICAgICB0bXBLZXk6IG51bGxcbiAgICB9XVxuICB9XG5cbiAgLy8gLS0gSW50ZXJmYWNlIHRvIGN1c3RvbWl6ZSBkZW9kaW5nIGJlaGF2aW91clxuICBjcmVhdGVUYWcgKHRhZ051bWJlciwgdmFsdWUpIHtcbiAgICBjb25zdCB0eXAgPSB0aGlzLl9rbm93blRhZ3NbdGFnTnVtYmVyXVxuXG4gICAgaWYgKCF0eXApIHtcbiAgICAgIHJldHVybiBuZXcgVGFnZ2VkKHRhZ051bWJlciwgdmFsdWUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cCh2YWx1ZSlcbiAgfVxuXG4gIGNyZWF0ZU1hcCAob2JqLCBsZW4pIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICBjcmVhdGVPYmplY3QgKG9iaiwgbGVuKSB7XG4gICAgcmV0dXJuIG9ialxuICB9XG5cbiAgY3JlYXRlQXJyYXkgKGFyciwgbGVuKSB7XG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgY3JlYXRlQnl0ZVN0cmluZyAocmF3LCBsZW4pIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChyYXcpXG4gIH1cblxuICBjcmVhdGVCeXRlU3RyaW5nRnJvbUhlYXAgKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICAgIH1cblxuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLl9oZWFwLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG5cbiAgY3JlYXRlSW50ICh2YWwpIHtcbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICBjcmVhdGVJbnQzMiAoZiwgZykge1xuICAgIHJldHVybiB1dGlscy5idWlsZEludDMyKGYsIGcpXG4gIH1cblxuICBjcmVhdGVJbnQ2NCAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICByZXR1cm4gdXRpbHMuYnVpbGRJbnQ2NChmMSwgZjIsIGcxLCBnMilcbiAgfVxuXG4gIGNyZWF0ZUZsb2F0ICh2YWwpIHtcbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICBjcmVhdGVGbG9hdFNpbmdsZSAoYSwgYiwgYywgZCkge1xuICAgIHJldHVybiBpZWVlNzU0LnJlYWQoW2EsIGIsIGMsIGRdLCAwLCBmYWxzZSwgMjMsIDQpXG4gIH1cblxuICBjcmVhdGVGbG9hdERvdWJsZSAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCkge1xuICAgIHJldHVybiBpZWVlNzU0LnJlYWQoW2EsIGIsIGMsIGQsIGUsIGYsIGcsIGhdLCAwLCBmYWxzZSwgNTIsIDgpXG4gIH1cblxuICBjcmVhdGVJbnQzMk5lZyAoZiwgZykge1xuICAgIHJldHVybiAtMSAtIHV0aWxzLmJ1aWxkSW50MzIoZiwgZylcbiAgfVxuXG4gIGNyZWF0ZUludDY0TmVnIChmMSwgZjIsIGcxLCBnMikge1xuICAgIGNvbnN0IGYgPSB1dGlscy5idWlsZEludDMyKGYxLCBmMilcbiAgICBjb25zdCBnID0gdXRpbHMuYnVpbGRJbnQzMihnMSwgZzIpXG5cbiAgICBpZiAoZiA+IGMuTUFYX1NBRkVfSElHSCkge1xuICAgICAgcmV0dXJuIGMuTkVHX09ORS5taW51cyhuZXcgQmlnbnVtYmVyKGYpLnRpbWVzKGMuU0hJRlQzMikucGx1cyhnKSlcbiAgICB9XG5cbiAgICByZXR1cm4gLTEgLSAoKGYgKiBjLlNISUZUMzIpICsgZylcbiAgfVxuXG4gIGNyZWF0ZVRydWUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjcmVhdGVGYWxzZSAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjcmVhdGVOdWxsICgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY3JlYXRlVW5kZWZpbmVkICgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjcmVhdGVJbmZpbml0eSAoKSB7XG4gICAgcmV0dXJuIEluZmluaXR5XG4gIH1cblxuICBjcmVhdGVJbmZpbml0eU5lZyAoKSB7XG4gICAgcmV0dXJuIC1JbmZpbml0eVxuICB9XG5cbiAgY3JlYXRlTmFOICgpIHtcbiAgICByZXR1cm4gTmFOXG4gIH1cblxuICBjcmVhdGVOYU5OZWcgKCkge1xuICAgIHJldHVybiAtTmFOXG4gIH1cblxuICBjcmVhdGVVdGY4U3RyaW5nIChyYXcsIGxlbikge1xuICAgIHJldHVybiByYXcuam9pbignJylcbiAgfVxuXG4gIGNyZWF0ZVV0ZjhTdHJpbmdGcm9tSGVhcCAoc3RhcnQsIGVuZCkge1xuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZClcbiAgfVxuXG4gIGNyZWF0ZVNpbXBsZVVuYXNzaWduZWQgKHZhbCkge1xuICAgIHJldHVybiBuZXcgU2ltcGxlKHZhbClcbiAgfVxuXG4gIC8vIC0tIEludGVyZmFjZSBmb3IgZGVjb2Rlci5hc20uanNcblxuICBwdXNoSW50ICh2YWwpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW50KHZhbCkpXG4gIH1cblxuICBwdXNoSW50MzIgKGYsIGcpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW50MzIoZiwgZykpXG4gIH1cblxuICBwdXNoSW50NjQgKGYxLCBmMiwgZzEsIGcyKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUludDY0KGYxLCBmMiwgZzEsIGcyKSlcbiAgfVxuXG4gIHB1c2hGbG9hdCAodmFsKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUZsb2F0KHZhbCkpXG4gIH1cblxuICBwdXNoRmxvYXRTaW5nbGUgKGEsIGIsIGMsIGQpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlRmxvYXRTaW5nbGUoYSwgYiwgYywgZCkpXG4gIH1cblxuICBwdXNoRmxvYXREb3VibGUgKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlRmxvYXREb3VibGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCkpXG4gIH1cblxuICBwdXNoSW50MzJOZWcgKGYsIGcpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW50MzJOZWcoZiwgZykpXG4gIH1cblxuICBwdXNoSW50NjROZWcgKGYxLCBmMiwgZzEsIGcyKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUludDY0TmVnKGYxLCBmMiwgZzEsIGcyKSlcbiAgfVxuXG4gIHB1c2hUcnVlICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlVHJ1ZSgpKVxuICB9XG5cbiAgcHVzaEZhbHNlICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlRmFsc2UoKSlcbiAgfVxuXG4gIHB1c2hOdWxsICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlTnVsbCgpKVxuICB9XG5cbiAgcHVzaFVuZGVmaW5lZCAoKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZVVuZGVmaW5lZCgpKVxuICB9XG5cbiAgcHVzaEluZmluaXR5ICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW5maW5pdHkoKSlcbiAgfVxuXG4gIHB1c2hJbmZpbml0eU5lZyAoKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUluZmluaXR5TmVnKCkpXG4gIH1cblxuICBwdXNoTmFOICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlTmFOKCkpXG4gIH1cblxuICBwdXNoTmFOTmVnICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlTmFOTmVnKCkpXG4gIH1cblxuICBwdXNoQXJyYXlTdGFydCAoKSB7XG4gICAgdGhpcy5fY3JlYXRlUGFyZW50KFtdLCBjLlBBUkVOVC5BUlJBWSwgLTEpXG4gIH1cblxuICBwdXNoQXJyYXlTdGFydEZpeGVkIChsZW4pIHtcbiAgICB0aGlzLl9jcmVhdGVBcnJheVN0YXJ0Rml4ZWQobGVuKVxuICB9XG5cbiAgcHVzaEFycmF5U3RhcnRGaXhlZDMyIChsZW4xLCBsZW4yKSB7XG4gICAgY29uc3QgbGVuID0gdXRpbHMuYnVpbGRJbnQzMihsZW4xLCBsZW4yKVxuICAgIHRoaXMuX2NyZWF0ZUFycmF5U3RhcnRGaXhlZChsZW4pXG4gIH1cblxuICBwdXNoQXJyYXlTdGFydEZpeGVkNjQgKGxlbjEsIGxlbjIsIGxlbjMsIGxlbjQpIHtcbiAgICBjb25zdCBsZW4gPSB1dGlscy5idWlsZEludDY0KGxlbjEsIGxlbjIsIGxlbjMsIGxlbjQpXG4gICAgdGhpcy5fY3JlYXRlQXJyYXlTdGFydEZpeGVkKGxlbilcbiAgfVxuXG4gIHB1c2hPYmplY3RTdGFydCAoKSB7XG4gICAgdGhpcy5fY3JlYXRlT2JqZWN0U3RhcnRGaXhlZCgtMSlcbiAgfVxuXG4gIHB1c2hPYmplY3RTdGFydEZpeGVkIChsZW4pIHtcbiAgICB0aGlzLl9jcmVhdGVPYmplY3RTdGFydEZpeGVkKGxlbilcbiAgfVxuXG4gIHB1c2hPYmplY3RTdGFydEZpeGVkMzIgKGxlbjEsIGxlbjIpIHtcbiAgICBjb25zdCBsZW4gPSB1dGlscy5idWlsZEludDMyKGxlbjEsIGxlbjIpXG4gICAgdGhpcy5fY3JlYXRlT2JqZWN0U3RhcnRGaXhlZChsZW4pXG4gIH1cblxuICBwdXNoT2JqZWN0U3RhcnRGaXhlZDY0IChsZW4xLCBsZW4yLCBsZW4zLCBsZW40KSB7XG4gICAgY29uc3QgbGVuID0gdXRpbHMuYnVpbGRJbnQ2NChsZW4xLCBsZW4yLCBsZW4zLCBsZW40KVxuICAgIHRoaXMuX2NyZWF0ZU9iamVjdFN0YXJ0Rml4ZWQobGVuKVxuICB9XG5cbiAgcHVzaEJ5dGVTdHJpbmdTdGFydCAoKSB7XG4gICAgdGhpcy5fcGFyZW50c1t0aGlzLl9kZXB0aF0gPSB7XG4gICAgICB0eXBlOiBjLlBBUkVOVC5CWVRFX1NUUklORyxcbiAgICAgIGxlbmd0aDogLTEsXG4gICAgICByZWY6IFtdLFxuICAgICAgdmFsdWVzOiAwLFxuICAgICAgdG1wS2V5OiBudWxsXG4gICAgfVxuICB9XG5cbiAgcHVzaEJ5dGVTdHJpbmcgKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlQnl0ZVN0cmluZ0Zyb21IZWFwKHN0YXJ0LCBlbmQpKVxuICB9XG5cbiAgcHVzaFV0ZjhTdHJpbmdTdGFydCAoKSB7XG4gICAgdGhpcy5fcGFyZW50c1t0aGlzLl9kZXB0aF0gPSB7XG4gICAgICB0eXBlOiBjLlBBUkVOVC5VVEY4X1NUUklORyxcbiAgICAgIGxlbmd0aDogLTEsXG4gICAgICByZWY6IFtdLFxuICAgICAgdmFsdWVzOiAwLFxuICAgICAgdG1wS2V5OiBudWxsXG4gICAgfVxuICB9XG5cbiAgcHVzaFV0ZjhTdHJpbmcgKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlVXRmOFN0cmluZ0Zyb21IZWFwKHN0YXJ0LCBlbmQpKVxuICB9XG5cbiAgcHVzaFNpbXBsZVVuYXNzaWduZWQgKHZhbCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVTaW1wbGVVbmFzc2lnbmVkKHZhbCkpXG4gIH1cblxuICBwdXNoVGFnU3RhcnQgKHRhZykge1xuICAgIHRoaXMuX3BhcmVudHNbdGhpcy5fZGVwdGhdID0ge1xuICAgICAgdHlwZTogYy5QQVJFTlQuVEFHLFxuICAgICAgbGVuZ3RoOiAxLFxuICAgICAgcmVmOiBbdGFnXVxuICAgIH1cbiAgfVxuXG4gIHB1c2hUYWdTdGFydDQgKGYsIGcpIHtcbiAgICB0aGlzLnB1c2hUYWdTdGFydCh1dGlscy5idWlsZEludDMyKGYsIGcpKVxuICB9XG5cbiAgcHVzaFRhZ1N0YXJ0OCAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICB0aGlzLnB1c2hUYWdTdGFydCh1dGlscy5idWlsZEludDY0KGYxLCBmMiwgZzEsIGcyKSlcbiAgfVxuXG4gIHB1c2hUYWdVbmFzc2lnbmVkICh0YWdOdW1iZXIpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlVGFnKHRhZ051bWJlcikpXG4gIH1cblxuICBwdXNoQnJlYWsgKCkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50UGFyZW50Lmxlbmd0aCA+IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgYnJlYWsnKVxuICAgIH1cblxuICAgIHRoaXMuX2Nsb3NlUGFyZW50KClcbiAgfVxuXG4gIF9jcmVhdGVPYmplY3RTdGFydEZpeGVkIChsZW4pIHtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlT2JqZWN0KHt9KSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZVBhcmVudCh7fSwgYy5QQVJFTlQuT0JKRUNULCBsZW4pXG4gIH1cblxuICBfY3JlYXRlQXJyYXlTdGFydEZpeGVkIChsZW4pIHtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlQXJyYXkoW10pKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlUGFyZW50KG5ldyBBcnJheShsZW4pLCBjLlBBUkVOVC5BUlJBWSwgbGVuKVxuICB9XG5cbiAgX2RlY29kZSAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB0b28gc2hvcnQnKVxuICAgIH1cblxuICAgIHRoaXMuX3Jlc2V0KClcbiAgICB0aGlzLl9oZWFwOC5zZXQoaW5wdXQpXG4gICAgY29uc3QgY29kZSA9IHRoaXMucGFyc2VyLnBhcnNlKGlucHV0LmJ5dGVMZW5ndGgpXG5cbiAgICBpZiAodGhpcy5fZGVwdGggPiAxKSB7XG4gICAgICB3aGlsZSAodGhpcy5fY3VycmVudFBhcmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fY2xvc2VQYXJlbnQoKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2RlcHRoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZGV0ZXJtaW5hdGVkIG5lc3RpbmcnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIHJlc3VsdCcpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0gUHVibGljIEludGVyZmFjZVxuXG4gIGRlY29kZUZpcnN0IChpbnB1dCkge1xuICAgIHRoaXMuX2RlY29kZShpbnB1dClcblxuICAgIHJldHVybiB0aGlzLl9yZXNbMF1cbiAgfVxuXG4gIGRlY29kZUFsbCAoaW5wdXQpIHtcbiAgICB0aGlzLl9kZWNvZGUoaW5wdXQpXG5cbiAgICByZXR1cm4gdGhpcy5fcmVzXG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHRoZSBmaXJzdCBjYm9yIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBpbnB1dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2VuYz0naGV4J10gLSBFbmNvZGluZyB1c2VkIGlmIGEgc3RyaW5nIGlzIHBhc3NlZC5cbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBzdGF0aWMgZGVjb2RlIChpbnB1dCwgZW5jKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlucHV0ID0gQnVmZmVyLmZyb20oaW5wdXQsIGVuYyB8fCAnaGV4JylcbiAgICB9XG5cbiAgICBjb25zdCBkZWMgPSBuZXcgRGVjb2Rlcih7IHNpemU6IGlucHV0Lmxlbmd0aCB9KVxuICAgIHJldHVybiBkZWMuZGVjb2RlRmlyc3QoaW5wdXQpXG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFsbCBjYm9yIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gaW5wdXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlbmM9J2hleCddIC0gRW5jb2RpbmcgdXNlZCBpZiBhIHN0cmluZyBpcyBwYXNzZWQuXG4gICAqIEByZXR1cm5zIHtBcnJheTwqPn1cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBbGwgKGlucHV0LCBlbmMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgaW5wdXQgPSBCdWZmZXIuZnJvbShpbnB1dCwgZW5jIHx8ICdoZXgnKVxuICAgIH1cblxuICAgIGNvbnN0IGRlYyA9IG5ldyBEZWNvZGVyKHsgc2l6ZTogaW5wdXQubGVuZ3RoIH0pXG4gICAgcmV0dXJuIGRlYy5kZWNvZGVBbGwoaW5wdXQpXG4gIH1cbn1cblxuRGVjb2Rlci5kZWNvZGVGaXJzdCA9IERlY29kZXIuZGVjb2RlXG5cbm1vZHVsZS5leHBvcnRzID0gRGVjb2RlclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/decoder.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/diagnose.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/diagnose.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"./node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js\")\nconst Decoder = __webpack_require__(/*! ./decoder */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/decoder.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/utils.js\")\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n */\nclass Diagnose extends Decoder {\n  createTag (tagNumber, value) {\n    return `${tagNumber}(${value})`\n  }\n\n  createInt (val) {\n    return super.createInt(val).toString()\n  }\n\n  createInt32 (f, g) {\n    return super.createInt32(f, g).toString()\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return super.createInt64(f1, f2, g1, g2).toString()\n  }\n\n  createInt32Neg (f, g) {\n    return super.createInt32Neg(f, g).toString()\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    return super.createInt64Neg(f1, f2, g1, g2).toString()\n  }\n\n  createTrue () {\n    return 'true'\n  }\n\n  createFalse () {\n    return 'false'\n  }\n\n  createFloat (val) {\n    const fl = super.createFloat(val)\n    if (utils.isNegativeZero(val)) {\n      return '-0_1'\n    }\n\n    return `${fl}_1`\n  }\n\n  createFloatSingle (a, b, c, d) {\n    const fl = super.createFloatSingle(a, b, c, d)\n    return `${fl}_2`\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    const fl = super.createFloatDouble(a, b, c, d, e, f, g, h)\n    return `${fl}_3`\n  }\n\n  createByteString (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n    return `h'${val}`\n  }\n\n  createByteStringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createByteStringFromHeap(start, end)\n    )).toString('hex')\n\n    return `h'${val}'`\n  }\n\n  createInfinity () {\n    return 'Infinity_1'\n  }\n\n  createInfinityNeg () {\n    return '-Infinity_1'\n  }\n\n  createNaN () {\n    return 'NaN_1'\n  }\n\n  createNaNNeg () {\n    return '-NaN_1'\n  }\n\n  createNull () {\n    return 'null'\n  }\n\n  createUndefined () {\n    return 'undefined'\n  }\n\n  createSimpleUnassigned (val) {\n    return `simple(${val})`\n  }\n\n  createArray (arr, len) {\n    const val = super.createArray(arr, len)\n\n    if (len === -1) {\n      // indefinite\n      return `[_ ${val.join(', ')}]`\n    }\n\n    return `[${val.join(', ')}]`\n  }\n\n  createMap (map, len) {\n    const val = super.createMap(map)\n    const list = Array.from(val.keys())\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${list}}`\n    }\n\n    return `{${list}}`\n  }\n\n  createObject (obj, len) {\n    const val = super.createObject(obj)\n    const map = Object.keys(val)\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${map}}`\n    }\n\n    return `{${map}}`\n  }\n\n  createUtf8String (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n\n    return `\"${val}\"`\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createUtf8StringFromHeap(start, end)\n    )).toString('utf8')\n\n    return `\"${val}\"`\n  }\n\n  static diagnose (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Diagnose()\n    return dec.decodeFirst(input)\n  }\n}\n\nmodule.exports = Diagnose\n\nfunction collectObject (val) {\n  return (acc, key) => {\n    if (acc) {\n      return `${acc}, ${key}: ${val[key]}`\n    }\n    return `${key}: ${val[key]}`\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yY0AyLjEuMi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZGlhZ25vc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw4RUFBUTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBVztBQUNuQyxjQUFjLG1CQUFPLENBQUMsK0VBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVSxHQUFHLE1BQU07QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxHQUFHO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7O0FBRUE7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLElBQUk7QUFDdkI7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDOztBQUVBLGVBQWUsZUFBZTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsSUFBSSxNQUFNO0FBQ3pCOztBQUVBLGFBQWEsRUFBRSxNQUFNO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxJQUFJLEtBQUs7QUFDeEI7O0FBRUEsYUFBYSxFQUFFLEtBQUs7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCOztBQUVBLGVBQWUsSUFBSTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLElBQUk7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUksSUFBSSxJQUFJLElBQUksU0FBUztBQUN6QztBQUNBLGNBQWMsSUFBSSxJQUFJLFNBQVM7QUFDL0I7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9ib3JjQDIuMS4yL25vZGVfbW9kdWxlcy9ib3JjL3NyYy9kaWFnbm9zZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBEZWNvZGVyID0gcmVxdWlyZSgnLi9kZWNvZGVyJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5cbi8qKlxuICogT3V0cHV0IHRoZSBkaWFnbm9zdGljIGZvcm1hdCBmcm9tIGEgc3RyZWFtIG9mIENCT1IgYnl0ZXMuXG4gKlxuICovXG5jbGFzcyBEaWFnbm9zZSBleHRlbmRzIERlY29kZXIge1xuICBjcmVhdGVUYWcgKHRhZ051bWJlciwgdmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dGFnTnVtYmVyfSgke3ZhbHVlfSlgXG4gIH1cblxuICBjcmVhdGVJbnQgKHZhbCkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVJbnQodmFsKS50b1N0cmluZygpXG4gIH1cblxuICBjcmVhdGVJbnQzMiAoZiwgZykge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVJbnQzMihmLCBnKS50b1N0cmluZygpXG4gIH1cblxuICBjcmVhdGVJbnQ2NCAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlSW50NjQoZjEsIGYyLCBnMSwgZzIpLnRvU3RyaW5nKClcbiAgfVxuXG4gIGNyZWF0ZUludDMyTmVnIChmLCBnKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUludDMyTmVnKGYsIGcpLnRvU3RyaW5nKClcbiAgfVxuXG4gIGNyZWF0ZUludDY0TmVnIChmMSwgZjIsIGcxLCBnMikge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVJbnQ2NE5lZyhmMSwgZjIsIGcxLCBnMikudG9TdHJpbmcoKVxuICB9XG5cbiAgY3JlYXRlVHJ1ZSAoKSB7XG4gICAgcmV0dXJuICd0cnVlJ1xuICB9XG5cbiAgY3JlYXRlRmFsc2UgKCkge1xuICAgIHJldHVybiAnZmFsc2UnXG4gIH1cblxuICBjcmVhdGVGbG9hdCAodmFsKSB7XG4gICAgY29uc3QgZmwgPSBzdXBlci5jcmVhdGVGbG9hdCh2YWwpXG4gICAgaWYgKHV0aWxzLmlzTmVnYXRpdmVaZXJvKHZhbCkpIHtcbiAgICAgIHJldHVybiAnLTBfMSdcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7Zmx9XzFgXG4gIH1cblxuICBjcmVhdGVGbG9hdFNpbmdsZSAoYSwgYiwgYywgZCkge1xuICAgIGNvbnN0IGZsID0gc3VwZXIuY3JlYXRlRmxvYXRTaW5nbGUoYSwgYiwgYywgZClcbiAgICByZXR1cm4gYCR7Zmx9XzJgXG4gIH1cblxuICBjcmVhdGVGbG9hdERvdWJsZSAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCkge1xuICAgIGNvbnN0IGZsID0gc3VwZXIuY3JlYXRlRmxvYXREb3VibGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaClcbiAgICByZXR1cm4gYCR7Zmx9XzNgXG4gIH1cblxuICBjcmVhdGVCeXRlU3RyaW5nIChyYXcsIGxlbikge1xuICAgIGNvbnN0IHZhbCA9IHJhdy5qb2luKCcsICcpXG5cbiAgICBpZiAobGVuID09PSAtMSkge1xuICAgICAgcmV0dXJuIGAoXyAke3ZhbH0pYFxuICAgIH1cbiAgICByZXR1cm4gYGgnJHt2YWx9YFxuICB9XG5cbiAgY3JlYXRlQnl0ZVN0cmluZ0Zyb21IZWFwIChzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgdmFsID0gKEJ1ZmZlci5mcm9tKFxuICAgICAgc3VwZXIuY3JlYXRlQnl0ZVN0cmluZ0Zyb21IZWFwKHN0YXJ0LCBlbmQpXG4gICAgKSkudG9TdHJpbmcoJ2hleCcpXG5cbiAgICByZXR1cm4gYGgnJHt2YWx9J2BcbiAgfVxuXG4gIGNyZWF0ZUluZmluaXR5ICgpIHtcbiAgICByZXR1cm4gJ0luZmluaXR5XzEnXG4gIH1cblxuICBjcmVhdGVJbmZpbml0eU5lZyAoKSB7XG4gICAgcmV0dXJuICctSW5maW5pdHlfMSdcbiAgfVxuXG4gIGNyZWF0ZU5hTiAoKSB7XG4gICAgcmV0dXJuICdOYU5fMSdcbiAgfVxuXG4gIGNyZWF0ZU5hTk5lZyAoKSB7XG4gICAgcmV0dXJuICctTmFOXzEnXG4gIH1cblxuICBjcmVhdGVOdWxsICgpIHtcbiAgICByZXR1cm4gJ251bGwnXG4gIH1cblxuICBjcmVhdGVVbmRlZmluZWQgKCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJ1xuICB9XG5cbiAgY3JlYXRlU2ltcGxlVW5hc3NpZ25lZCAodmFsKSB7XG4gICAgcmV0dXJuIGBzaW1wbGUoJHt2YWx9KWBcbiAgfVxuXG4gIGNyZWF0ZUFycmF5IChhcnIsIGxlbikge1xuICAgIGNvbnN0IHZhbCA9IHN1cGVyLmNyZWF0ZUFycmF5KGFyciwgbGVuKVxuXG4gICAgaWYgKGxlbiA9PT0gLTEpIHtcbiAgICAgIC8vIGluZGVmaW5pdGVcbiAgICAgIHJldHVybiBgW18gJHt2YWwuam9pbignLCAnKX1dYFxuICAgIH1cblxuICAgIHJldHVybiBgWyR7dmFsLmpvaW4oJywgJyl9XWBcbiAgfVxuXG4gIGNyZWF0ZU1hcCAobWFwLCBsZW4pIHtcbiAgICBjb25zdCB2YWwgPSBzdXBlci5jcmVhdGVNYXAobWFwKVxuICAgIGNvbnN0IGxpc3QgPSBBcnJheS5mcm9tKHZhbC5rZXlzKCkpXG4gICAgICAucmVkdWNlKGNvbGxlY3RPYmplY3QodmFsKSwgJycpXG5cbiAgICBpZiAobGVuID09PSAtMSkge1xuICAgICAgcmV0dXJuIGB7XyAke2xpc3R9fWBcbiAgICB9XG5cbiAgICByZXR1cm4gYHske2xpc3R9fWBcbiAgfVxuXG4gIGNyZWF0ZU9iamVjdCAob2JqLCBsZW4pIHtcbiAgICBjb25zdCB2YWwgPSBzdXBlci5jcmVhdGVPYmplY3Qob2JqKVxuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5rZXlzKHZhbClcbiAgICAgIC5yZWR1Y2UoY29sbGVjdE9iamVjdCh2YWwpLCAnJylcblxuICAgIGlmIChsZW4gPT09IC0xKSB7XG4gICAgICByZXR1cm4gYHtfICR7bWFwfX1gXG4gICAgfVxuXG4gICAgcmV0dXJuIGB7JHttYXB9fWBcbiAgfVxuXG4gIGNyZWF0ZVV0ZjhTdHJpbmcgKHJhdywgbGVuKSB7XG4gICAgY29uc3QgdmFsID0gcmF3LmpvaW4oJywgJylcblxuICAgIGlmIChsZW4gPT09IC0xKSB7XG4gICAgICByZXR1cm4gYChfICR7dmFsfSlgXG4gICAgfVxuXG4gICAgcmV0dXJuIGBcIiR7dmFsfVwiYFxuICB9XG5cbiAgY3JlYXRlVXRmOFN0cmluZ0Zyb21IZWFwIChzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgdmFsID0gKEJ1ZmZlci5mcm9tKFxuICAgICAgc3VwZXIuY3JlYXRlVXRmOFN0cmluZ0Zyb21IZWFwKHN0YXJ0LCBlbmQpXG4gICAgKSkudG9TdHJpbmcoJ3V0ZjgnKVxuXG4gICAgcmV0dXJuIGBcIiR7dmFsfVwiYFxuICB9XG5cbiAgc3RhdGljIGRpYWdub3NlIChpbnB1dCwgZW5jKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlucHV0ID0gQnVmZmVyLmZyb20oaW5wdXQsIGVuYyB8fCAnaGV4JylcbiAgICB9XG5cbiAgICBjb25zdCBkZWMgPSBuZXcgRGlhZ25vc2UoKVxuICAgIHJldHVybiBkZWMuZGVjb2RlRmlyc3QoaW5wdXQpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWFnbm9zZVxuXG5mdW5jdGlvbiBjb2xsZWN0T2JqZWN0ICh2YWwpIHtcbiAgcmV0dXJuIChhY2MsIGtleSkgPT4ge1xuICAgIGlmIChhY2MpIHtcbiAgICAgIHJldHVybiBgJHthY2N9LCAke2tleX06ICR7dmFsW2tleV19YFxuICAgIH1cbiAgICByZXR1cm4gYCR7a2V5fTogJHt2YWxba2V5XX1gXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/diagnose.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/encoder.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/encoder.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"./node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js\")\nconst { URL } = __webpack_require__(/*! iso-url */ \"./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/utils.js\")\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/constants.js\")\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SHIFT32 = constants.SHIFT32\nconst SYMS = constants.SYMS\nconst TAG = constants.TAG\nconst HALF = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.TWO\nconst FLOAT = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.FOUR\nconst DOUBLE = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.EIGHT\nconst TRUE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.TRUE\nconst FALSE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.FALSE\nconst UNDEFINED = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.UNDEFINED\nconst NULL = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.NULL\n\nconst MAXINT_BN = new Bignumber('0x20000000000000')\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\n\nfunction toType (obj) {\n  // [object Type]\n  // --------8---1\n  return ({}).toString.call(obj).slice(8, -1)\n}\n\n/**\n * Transform JavaScript values into CBOR bytes\n *\n */\nclass Encoder {\n  /**\n   * @param {Object} [options={}]\n   * @param {function(Buffer)} options.stream\n   */\n  constructor (options) {\n    options = options || {}\n\n    this.streaming = typeof options.stream === 'function'\n    this.onData = options.stream\n\n    this.semanticTypes = [\n      [URL, this._pushUrl],\n      [Bignumber, this._pushBigNumber]\n    ]\n\n    const addTypes = options.genTypes || []\n    const len = addTypes.length\n    for (let i = 0; i < len; i++) {\n      this.addSemanticType(\n        addTypes[i][0],\n        addTypes[i][1]\n      )\n    }\n\n    this._reset()\n  }\n\n  addSemanticType (type, fun) {\n    const len = this.semanticTypes.length\n    for (let i = 0; i < len; i++) {\n      const typ = this.semanticTypes[i][0]\n      if (typ === type) {\n        const old = this.semanticTypes[i][1]\n        this.semanticTypes[i][1] = fun\n        return old\n      }\n    }\n    this.semanticTypes.push([type, fun])\n    return null\n  }\n\n  push (val) {\n    if (!val) {\n      return true\n    }\n\n    this.result[this.offset] = val\n    this.resultMethod[this.offset] = 0\n    this.resultLength[this.offset] = val.length\n    this.offset++\n\n    if (this.streaming) {\n      this.onData(this.finalize())\n    }\n\n    return true\n  }\n\n  pushWrite (val, method, len) {\n    this.result[this.offset] = val\n    this.resultMethod[this.offset] = method\n    this.resultLength[this.offset] = len\n    this.offset++\n\n    if (this.streaming) {\n      this.onData(this.finalize())\n    }\n\n    return true\n  }\n\n  _pushUInt8 (val) {\n    return this.pushWrite(val, 1, 1)\n  }\n\n  _pushUInt16BE (val) {\n    return this.pushWrite(val, 2, 2)\n  }\n\n  _pushUInt32BE (val) {\n    return this.pushWrite(val, 3, 4)\n  }\n\n  _pushDoubleBE (val) {\n    return this.pushWrite(val, 4, 8)\n  }\n\n  _pushNaN () {\n    return this.push(BUF_NAN)\n  }\n\n  _pushInfinity (obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  _pushFloat (obj) {\n    const b2 = Buffer.allocUnsafe(2)\n\n    if (utils.writeHalf(b2, obj)) {\n      if (utils.parseHalf(b2) === obj) {\n        return this._pushUInt8(HALF) && this.push(b2)\n      }\n    }\n\n    const b4 = Buffer.allocUnsafe(4)\n    b4.writeFloatBE(obj, 0)\n    if (b4.readFloatBE(0) === obj) {\n      return this._pushUInt8(FLOAT) && this.push(b4)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  _pushInt (obj, mt, orig) {\n    const m = mt << 5\n    if (obj < 24) {\n      return this._pushUInt8(m | obj)\n    }\n\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n    }\n\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n    }\n\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n    }\n\n    if (obj <= Number.MAX_SAFE_INTEGER) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32)\n    }\n\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig)\n    }\n\n    return this._pushFloat(obj)\n  }\n\n  _pushIntNum (obj) {\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    } else {\n      return this._pushInt(obj, MT.POS_INT)\n    }\n  }\n\n  _pushNumber (obj) {\n    switch (false) {\n      case (obj === obj): // eslint-disable-line\n        return this._pushNaN(obj)\n      case isFinite(obj):\n        return this._pushInfinity(obj)\n      case ((obj % 1) !== 0):\n        return this._pushIntNum(obj)\n      default:\n        return this._pushFloat(obj)\n    }\n  }\n\n  _pushString (obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len)\n  }\n\n  _pushBoolean (obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  _pushUndefined (obj) {\n    return this._pushUInt8(UNDEFINED)\n  }\n\n  _pushArray (gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushTag (tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  _pushDate (gen, obj) {\n    // Round date, to get seconds since 1970-01-01 00:00:00 as defined in\n    // Sec. 2.4.1 and get a possibly more compact encoding. Note that it is\n    // still allowed to encode fractions of seconds which can be achieved by\n    // changing overwriting the encode function for Date objects.\n    return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1000))\n  }\n\n  _pushBuffer (gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  _pushNoFilter (gen, obj) {\n    return gen._pushBuffer(gen, obj.slice())\n  }\n\n  _pushRegexp (gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  _pushSet (gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushUrl (gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format())\n  }\n\n  _pushBigint (obj) {\n    let tag = TAG.POS_BIGINT\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1)\n      tag = TAG.NEG_BIGINT\n    }\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && this._pushBuffer(this, buf)\n  }\n\n  _pushBigNumber (gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN()\n    }\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)\n    }\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj)\n    }\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) &&\n      gen._pushInt(2, MT.ARRAY))) {\n      return false\n    }\n\n    const dec = obj.decimalPlaces()\n    const slide = obj.multipliedBy(new Bignumber(10).pow(dec))\n    if (!gen._pushIntNum(-dec)) {\n      return false\n    }\n    if (slide.abs().isLessThan(MAXINT_BN)) {\n      return gen._pushIntNum(slide.toNumber())\n    } else {\n      return gen._pushBigint(slide)\n    }\n  }\n\n  _pushMap (gen, obj) {\n    if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false\n    }\n\n    return this._pushRawMap(\n      obj.size,\n      Array.from(obj)\n    )\n  }\n\n  _pushObject (obj) {\n    if (!obj) {\n      return this._pushUInt8(NULL)\n    }\n\n    var len = this.semanticTypes.length\n    for (var i = 0; i < len; i++) {\n      if (obj instanceof this.semanticTypes[i][0]) {\n        return this.semanticTypes[i][1].call(obj, this, obj)\n      }\n    }\n\n    var f = obj.encodeCBOR\n    if (typeof f === 'function') {\n      return f.call(obj, this)\n    }\n\n    var keys = Object.keys(obj)\n    var keyLength = keys.length\n    if (!this._pushInt(keyLength, MT.MAP)) {\n      return false\n    }\n\n    return this._pushRawMap(\n      keyLength,\n      keys.map((k) => [k, obj[k]])\n    )\n  }\n\n  _pushRawMap (len, map) {\n    // Sort keys for canoncialization\n    // 1. encode key\n    // 2. shorter key comes before longer key\n    // 3. same length keys are sorted with lower\n    //    byte value before higher\n\n    map = map.map(function (a) {\n      a[0] = Encoder.encode(a[0])\n      return a\n    }).sort(utils.keySorter)\n\n    for (var j = 0; j < len; j++) {\n      if (!this.push(map[j][0])) {\n        return false\n      }\n\n      if (!this.pushAny(map[j][1])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Alias for `.pushAny`\n   *\n   * @param {*} obj\n   * @returns {boolean} true on success\n   */\n  write (obj) {\n    return this.pushAny(obj)\n  }\n\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n  pushAny (obj) {\n    var typ = toType(obj)\n\n    switch (typ) {\n      case 'Number':\n        return this._pushNumber(obj)\n      case 'String':\n        return this._pushString(obj)\n      case 'Boolean':\n        return this._pushBoolean(obj)\n      case 'Object':\n        return this._pushObject(obj)\n      case 'Array':\n        return this._pushArray(this, obj)\n      case 'Uint8Array':\n        return this._pushBuffer(this, Buffer.isBuffer(obj) ? obj : Buffer.from(obj))\n      case 'Null':\n        return this._pushUInt8(NULL)\n      case 'Undefined':\n        return this._pushUndefined(obj)\n      case 'Map':\n        return this._pushMap(this, obj)\n      case 'Set':\n        return this._pushSet(this, obj)\n      case 'URL':\n        return this._pushUrl(this, obj)\n      case 'BigNumber':\n        return this._pushBigNumber(this, obj)\n      case 'Date':\n        return this._pushDate(this, obj)\n      case 'RegExp':\n        return this._pushRegexp(this, obj)\n      case 'Symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushObject(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString())\n        }\n      default:\n        throw new Error('Unknown type: ' + typeof obj + ', ' + (obj ? obj.toString() : ''))\n    }\n  }\n\n  finalize () {\n    if (this.offset === 0) {\n      return null\n    }\n\n    var result = this.result\n    var resultLength = this.resultLength\n    var resultMethod = this.resultMethod\n    var offset = this.offset\n\n    // Determine the size of the buffer\n    var size = 0\n    var i = 0\n\n    for (; i < offset; i++) {\n      size += resultLength[i]\n    }\n\n    var res = Buffer.allocUnsafe(size)\n    var index = 0\n    var length = 0\n\n    // Write the content into the result buffer\n    for (i = 0; i < offset; i++) {\n      length = resultLength[i]\n\n      switch (resultMethod[i]) {\n        case 0:\n          result[i].copy(res, index)\n          break\n        case 1:\n          res.writeUInt8(result[i], index, true)\n          break\n        case 2:\n          res.writeUInt16BE(result[i], index, true)\n          break\n        case 3:\n          res.writeUInt32BE(result[i], index, true)\n          break\n        case 4:\n          res.writeDoubleBE(result[i], index, true)\n          break\n        case 5:\n          res.write(result[i], index, length, 'utf8')\n          break\n        default:\n          throw new Error('unkown method')\n      }\n\n      index += length\n    }\n\n    var tmp = res\n\n    this._reset()\n\n    return tmp\n  }\n\n  _reset () {\n    this.result = []\n    this.resultMethod = []\n    this.resultLength = []\n    this.offset = 0\n  }\n\n  /**\n   * Encode the given value\n   * @param {*} o\n   * @returns {Buffer}\n   */\n  static encode (o) {\n    const enc = new Encoder()\n    const ret = enc.pushAny(o)\n    if (!ret) {\n      throw new Error('Failed to encode input')\n    }\n\n    return enc.finalize()\n  }\n}\n\nmodule.exports = Encoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yY0AyLjEuMi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZW5jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDhFQUFRO0FBQ25DLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsaUZBQVM7QUFDakMsa0JBQWtCLHFJQUFpQzs7QUFFbkQsY0FBYyxtQkFBTyxDQUFDLCtFQUFTO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLFdBQVc7QUFDaEMsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9ib3JjQDIuMS4yL25vZGVfbW9kdWxlcy9ib3JjL3NyYy9lbmNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCdpc28tdXJsJylcbmNvbnN0IEJpZ251bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpLkJpZ051bWJlclxuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgTVQgPSBjb25zdGFudHMuTVRcbmNvbnN0IE5VTUJZVEVTID0gY29uc3RhbnRzLk5VTUJZVEVTXG5jb25zdCBTSElGVDMyID0gY29uc3RhbnRzLlNISUZUMzJcbmNvbnN0IFNZTVMgPSBjb25zdGFudHMuU1lNU1xuY29uc3QgVEFHID0gY29uc3RhbnRzLlRBR1xuY29uc3QgSEFMRiA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLk5VTUJZVEVTLlRXT1xuY29uc3QgRkxPQVQgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5OVU1CWVRFUy5GT1VSXG5jb25zdCBET1VCTEUgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5OVU1CWVRFUy5FSUdIVFxuY29uc3QgVFJVRSA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLlNJTVBMRS5UUlVFXG5jb25zdCBGQUxTRSA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLlNJTVBMRS5GQUxTRVxuY29uc3QgVU5ERUZJTkVEID0gKGNvbnN0YW50cy5NVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBjb25zdGFudHMuU0lNUExFLlVOREVGSU5FRFxuY29uc3QgTlVMTCA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLlNJTVBMRS5OVUxMXG5cbmNvbnN0IE1BWElOVF9CTiA9IG5ldyBCaWdudW1iZXIoJzB4MjAwMDAwMDAwMDAwMDAnKVxuY29uc3QgQlVGX05BTiA9IEJ1ZmZlci5mcm9tKCdmOTdlMDAnLCAnaGV4JylcbmNvbnN0IEJVRl9JTkZfTkVHID0gQnVmZmVyLmZyb20oJ2Y5ZmMwMCcsICdoZXgnKVxuY29uc3QgQlVGX0lORl9QT1MgPSBCdWZmZXIuZnJvbSgnZjk3YzAwJywgJ2hleCcpXG5cbmZ1bmN0aW9uIHRvVHlwZSAob2JqKSB7XG4gIC8vIFtvYmplY3QgVHlwZV1cbiAgLy8gLS0tLS0tLS04LS0tMVxuICByZXR1cm4gKHt9KS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIEphdmFTY3JpcHQgdmFsdWVzIGludG8gQ0JPUiBieXRlc1xuICpcbiAqL1xuY2xhc3MgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQnVmZmVyKX0gb3B0aW9ucy5zdHJlYW1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAgIHRoaXMuc3RyZWFtaW5nID0gdHlwZW9mIG9wdGlvbnMuc3RyZWFtID09PSAnZnVuY3Rpb24nXG4gICAgdGhpcy5vbkRhdGEgPSBvcHRpb25zLnN0cmVhbVxuXG4gICAgdGhpcy5zZW1hbnRpY1R5cGVzID0gW1xuICAgICAgW1VSTCwgdGhpcy5fcHVzaFVybF0sXG4gICAgICBbQmlnbnVtYmVyLCB0aGlzLl9wdXNoQmlnTnVtYmVyXVxuICAgIF1cblxuICAgIGNvbnN0IGFkZFR5cGVzID0gb3B0aW9ucy5nZW5UeXBlcyB8fCBbXVxuICAgIGNvbnN0IGxlbiA9IGFkZFR5cGVzLmxlbmd0aFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuYWRkU2VtYW50aWNUeXBlKFxuICAgICAgICBhZGRUeXBlc1tpXVswXSxcbiAgICAgICAgYWRkVHlwZXNbaV1bMV1cbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNldCgpXG4gIH1cblxuICBhZGRTZW1hbnRpY1R5cGUgKHR5cGUsIGZ1bikge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuc2VtYW50aWNUeXBlcy5sZW5ndGhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB0eXAgPSB0aGlzLnNlbWFudGljVHlwZXNbaV1bMF1cbiAgICAgIGlmICh0eXAgPT09IHR5cGUpIHtcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5zZW1hbnRpY1R5cGVzW2ldWzFdXG4gICAgICAgIHRoaXMuc2VtYW50aWNUeXBlc1tpXVsxXSA9IGZ1blxuICAgICAgICByZXR1cm4gb2xkXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2VtYW50aWNUeXBlcy5wdXNoKFt0eXBlLCBmdW5dKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBwdXNoICh2YWwpIHtcbiAgICBpZiAoIXZhbCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0aGlzLnJlc3VsdFt0aGlzLm9mZnNldF0gPSB2YWxcbiAgICB0aGlzLnJlc3VsdE1ldGhvZFt0aGlzLm9mZnNldF0gPSAwXG4gICAgdGhpcy5yZXN1bHRMZW5ndGhbdGhpcy5vZmZzZXRdID0gdmFsLmxlbmd0aFxuICAgIHRoaXMub2Zmc2V0KytcblxuICAgIGlmICh0aGlzLnN0cmVhbWluZykge1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy5maW5hbGl6ZSgpKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBwdXNoV3JpdGUgKHZhbCwgbWV0aG9kLCBsZW4pIHtcbiAgICB0aGlzLnJlc3VsdFt0aGlzLm9mZnNldF0gPSB2YWxcbiAgICB0aGlzLnJlc3VsdE1ldGhvZFt0aGlzLm9mZnNldF0gPSBtZXRob2RcbiAgICB0aGlzLnJlc3VsdExlbmd0aFt0aGlzLm9mZnNldF0gPSBsZW5cbiAgICB0aGlzLm9mZnNldCsrXG5cbiAgICBpZiAodGhpcy5zdHJlYW1pbmcpIHtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMuZmluYWxpemUoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX3B1c2hVSW50OCAodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFdyaXRlKHZhbCwgMSwgMSlcbiAgfVxuXG4gIF9wdXNoVUludDE2QkUgKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnB1c2hXcml0ZSh2YWwsIDIsIDIpXG4gIH1cblxuICBfcHVzaFVJbnQzMkJFICh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoV3JpdGUodmFsLCAzLCA0KVxuICB9XG5cbiAgX3B1c2hEb3VibGVCRSAodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFdyaXRlKHZhbCwgNCwgOClcbiAgfVxuXG4gIF9wdXNoTmFOICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoKEJVRl9OQU4pXG4gIH1cblxuICBfcHVzaEluZmluaXR5IChvYmopIHtcbiAgICBjb25zdCBoYWxmID0gKG9iaiA8IDApID8gQlVGX0lORl9ORUcgOiBCVUZfSU5GX1BPU1xuICAgIHJldHVybiB0aGlzLnB1c2goaGFsZilcbiAgfVxuXG4gIF9wdXNoRmxvYXQgKG9iaikge1xuICAgIGNvbnN0IGIyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG5cbiAgICBpZiAodXRpbHMud3JpdGVIYWxmKGIyLCBvYmopKSB7XG4gICAgICBpZiAodXRpbHMucGFyc2VIYWxmKGIyKSA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoSEFMRikgJiYgdGhpcy5wdXNoKGIyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGI0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpXG4gICAgYjQud3JpdGVGbG9hdEJFKG9iaiwgMClcbiAgICBpZiAoYjQucmVhZEZsb2F0QkUoMCkgPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChGTE9BVCkgJiYgdGhpcy5wdXNoKGI0KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoRE9VQkxFKSAmJiB0aGlzLl9wdXNoRG91YmxlQkUob2JqKVxuICB9XG5cbiAgX3B1c2hJbnQgKG9iaiwgbXQsIG9yaWcpIHtcbiAgICBjb25zdCBtID0gbXQgPDwgNVxuICAgIGlmIChvYmogPCAyNCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmogPD0gMHhmZikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgTlVNQllURVMuT05FKSAmJiB0aGlzLl9wdXNoVUludDgob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmogPD0gMHhmZmZmKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG0gfCBOVU1CWVRFUy5UV08pICYmIHRoaXMuX3B1c2hVSW50MTZCRShvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iaiA8PSAweGZmZmZmZmZmKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG0gfCBOVU1CWVRFUy5GT1VSKSAmJiB0aGlzLl9wdXNoVUludDMyQkUob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmogPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgobSB8IE5VTUJZVEVTLkVJR0hUKSAmJlxuICAgICAgICB0aGlzLl9wdXNoVUludDMyQkUoTWF0aC5mbG9vcihvYmogLyBTSElGVDMyKSkgJiZcbiAgICAgICAgdGhpcy5fcHVzaFVJbnQzMkJFKG9iaiAlIFNISUZUMzIpXG4gICAgfVxuXG4gICAgaWYgKG10ID09PSBNVC5ORUdfSU5UKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaEZsb2F0KG9yaWcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hGbG9hdChvYmopXG4gIH1cblxuICBfcHVzaEludE51bSAob2JqKSB7XG4gICAgaWYgKG9iaiA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoSW50KC1vYmogLSAxLCBNVC5ORUdfSU5ULCBvYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoSW50KG9iaiwgTVQuUE9TX0lOVClcbiAgICB9XG4gIH1cblxuICBfcHVzaE51bWJlciAob2JqKSB7XG4gICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgY2FzZSAob2JqID09PSBvYmopOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoTmFOKG9iailcbiAgICAgIGNhc2UgaXNGaW5pdGUob2JqKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hJbmZpbml0eShvYmopXG4gICAgICBjYXNlICgob2JqICUgMSkgIT09IDApOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEludE51bShvYmopXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEZsb2F0KG9iailcbiAgICB9XG4gIH1cblxuICBfcHVzaFN0cmluZyAob2JqKSB7XG4gICAgY29uc3QgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgob2JqLCAndXRmOCcpXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hJbnQobGVuLCBNVC5VVEY4X1NUUklORykgJiYgdGhpcy5wdXNoV3JpdGUob2JqLCA1LCBsZW4pXG4gIH1cblxuICBfcHVzaEJvb2xlYW4gKG9iaikge1xuICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgob2JqID8gVFJVRSA6IEZBTFNFKVxuICB9XG5cbiAgX3B1c2hVbmRlZmluZWQgKG9iaikge1xuICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoVU5ERUZJTkVEKVxuICB9XG5cbiAgX3B1c2hBcnJheSAoZ2VuLCBvYmopIHtcbiAgICBjb25zdCBsZW4gPSBvYmoubGVuZ3RoXG4gICAgaWYgKCFnZW4uX3B1c2hJbnQobGVuLCBNVC5BUlJBWSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBpZiAoIWdlbi5wdXNoQW55KG9ialtqXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBfcHVzaFRhZyAodGFnKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hJbnQodGFnLCBNVC5UQUcpXG4gIH1cblxuICBfcHVzaERhdGUgKGdlbiwgb2JqKSB7XG4gICAgLy8gUm91bmQgZGF0ZSwgdG8gZ2V0IHNlY29uZHMgc2luY2UgMTk3MC0wMS0wMSAwMDowMDowMCBhcyBkZWZpbmVkIGluXG4gICAgLy8gU2VjLiAyLjQuMSBhbmQgZ2V0IGEgcG9zc2libHkgbW9yZSBjb21wYWN0IGVuY29kaW5nLiBOb3RlIHRoYXQgaXQgaXNcbiAgICAvLyBzdGlsbCBhbGxvd2VkIHRvIGVuY29kZSBmcmFjdGlvbnMgb2Ygc2Vjb25kcyB3aGljaCBjYW4gYmUgYWNoaWV2ZWQgYnlcbiAgICAvLyBjaGFuZ2luZyBvdmVyd3JpdGluZyB0aGUgZW5jb2RlIGZ1bmN0aW9uIGZvciBEYXRlIG9iamVjdHMuXG4gICAgcmV0dXJuIGdlbi5fcHVzaFRhZyhUQUcuREFURV9FUE9DSCkgJiYgZ2VuLnB1c2hBbnkoTWF0aC5yb3VuZChvYmogLyAxMDAwKSlcbiAgfVxuXG4gIF9wdXNoQnVmZmVyIChnZW4sIG9iaikge1xuICAgIHJldHVybiBnZW4uX3B1c2hJbnQob2JqLmxlbmd0aCwgTVQuQllURV9TVFJJTkcpICYmIGdlbi5wdXNoKG9iailcbiAgfVxuXG4gIF9wdXNoTm9GaWx0ZXIgKGdlbiwgb2JqKSB7XG4gICAgcmV0dXJuIGdlbi5fcHVzaEJ1ZmZlcihnZW4sIG9iai5zbGljZSgpKVxuICB9XG5cbiAgX3B1c2hSZWdleHAgKGdlbiwgb2JqKSB7XG4gICAgcmV0dXJuIGdlbi5fcHVzaFRhZyhUQUcuUkVHRVhQKSAmJiBnZW4ucHVzaEFueShvYmouc291cmNlKVxuICB9XG5cbiAgX3B1c2hTZXQgKGdlbiwgb2JqKSB7XG4gICAgaWYgKCFnZW4uX3B1c2hJbnQob2JqLnNpemUsIE1ULkFSUkFZKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGZvciAoY29uc3QgeCBvZiBvYmopIHtcbiAgICAgIGlmICghZ2VuLnB1c2hBbnkoeCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBfcHVzaFVybCAoZ2VuLCBvYmopIHtcbiAgICByZXR1cm4gZ2VuLl9wdXNoVGFnKFRBRy5VUkkpICYmIGdlbi5wdXNoQW55KG9iai5mb3JtYXQoKSlcbiAgfVxuXG4gIF9wdXNoQmlnaW50IChvYmopIHtcbiAgICBsZXQgdGFnID0gVEFHLlBPU19CSUdJTlRcbiAgICBpZiAob2JqLmlzTmVnYXRpdmUoKSkge1xuICAgICAgb2JqID0gb2JqLm5lZ2F0ZWQoKS5taW51cygxKVxuICAgICAgdGFnID0gVEFHLk5FR19CSUdJTlRcbiAgICB9XG4gICAgbGV0IHN0ciA9IG9iai50b1N0cmluZygxNilcbiAgICBpZiAoc3RyLmxlbmd0aCAlIDIpIHtcbiAgICAgIHN0ciA9ICcwJyArIHN0clxuICAgIH1cbiAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShzdHIsICdoZXgnKVxuICAgIHJldHVybiB0aGlzLl9wdXNoVGFnKHRhZykgJiYgdGhpcy5fcHVzaEJ1ZmZlcih0aGlzLCBidWYpXG4gIH1cblxuICBfcHVzaEJpZ051bWJlciAoZ2VuLCBvYmopIHtcbiAgICBpZiAob2JqLmlzTmFOKCkpIHtcbiAgICAgIHJldHVybiBnZW4uX3B1c2hOYU4oKVxuICAgIH1cbiAgICBpZiAoIW9iai5pc0Zpbml0ZSgpKSB7XG4gICAgICByZXR1cm4gZ2VuLl9wdXNoSW5maW5pdHkob2JqLmlzTmVnYXRpdmUoKSA/IC1JbmZpbml0eSA6IEluZmluaXR5KVxuICAgIH1cbiAgICBpZiAob2JqLmlzSW50ZWdlcigpKSB7XG4gICAgICByZXR1cm4gZ2VuLl9wdXNoQmlnaW50KG9iailcbiAgICB9XG4gICAgaWYgKCEoZ2VuLl9wdXNoVGFnKFRBRy5ERUNJTUFMX0ZSQUMpICYmXG4gICAgICBnZW4uX3B1c2hJbnQoMiwgTVQuQVJSQVkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVjID0gb2JqLmRlY2ltYWxQbGFjZXMoKVxuICAgIGNvbnN0IHNsaWRlID0gb2JqLm11bHRpcGxpZWRCeShuZXcgQmlnbnVtYmVyKDEwKS5wb3coZGVjKSlcbiAgICBpZiAoIWdlbi5fcHVzaEludE51bSgtZGVjKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChzbGlkZS5hYnMoKS5pc0xlc3NUaGFuKE1BWElOVF9CTikpIHtcbiAgICAgIHJldHVybiBnZW4uX3B1c2hJbnROdW0oc2xpZGUudG9OdW1iZXIoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdlbi5fcHVzaEJpZ2ludChzbGlkZSlcbiAgICB9XG4gIH1cblxuICBfcHVzaE1hcCAoZ2VuLCBvYmopIHtcbiAgICBpZiAoIWdlbi5fcHVzaEludChvYmouc2l6ZSwgTVQuTUFQKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hSYXdNYXAoXG4gICAgICBvYmouc2l6ZSxcbiAgICAgIEFycmF5LmZyb20ob2JqKVxuICAgIClcbiAgfVxuXG4gIF9wdXNoT2JqZWN0IChvYmopIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChOVUxMKVxuICAgIH1cblxuICAgIHZhciBsZW4gPSB0aGlzLnNlbWFudGljVHlwZXMubGVuZ3RoXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIHRoaXMuc2VtYW50aWNUeXBlc1tpXVswXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW1hbnRpY1R5cGVzW2ldWzFdLmNhbGwob2JqLCB0aGlzLCBvYmopXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGYgPSBvYmouZW5jb2RlQ0JPUlxuICAgIGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGYuY2FsbChvYmosIHRoaXMpXG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgdmFyIGtleUxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgaWYgKCF0aGlzLl9wdXNoSW50KGtleUxlbmd0aCwgTVQuTUFQKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hSYXdNYXAoXG4gICAgICBrZXlMZW5ndGgsXG4gICAgICBrZXlzLm1hcCgoaykgPT4gW2ssIG9ialtrXV0pXG4gICAgKVxuICB9XG5cbiAgX3B1c2hSYXdNYXAgKGxlbiwgbWFwKSB7XG4gICAgLy8gU29ydCBrZXlzIGZvciBjYW5vbmNpYWxpemF0aW9uXG4gICAgLy8gMS4gZW5jb2RlIGtleVxuICAgIC8vIDIuIHNob3J0ZXIga2V5IGNvbWVzIGJlZm9yZSBsb25nZXIga2V5XG4gICAgLy8gMy4gc2FtZSBsZW5ndGgga2V5cyBhcmUgc29ydGVkIHdpdGggbG93ZXJcbiAgICAvLyAgICBieXRlIHZhbHVlIGJlZm9yZSBoaWdoZXJcblxuICAgIG1hcCA9IG1hcC5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIGFbMF0gPSBFbmNvZGVyLmVuY29kZShhWzBdKVxuICAgICAgcmV0dXJuIGFcbiAgICB9KS5zb3J0KHV0aWxzLmtleVNvcnRlcilcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGlmICghdGhpcy5wdXNoKG1hcFtqXVswXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5wdXNoQW55KG1hcFtqXVsxXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYC5wdXNoQW55YFxuICAgKlxuICAgKiBAcGFyYW0geyp9IG9ialxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZSAob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaEFueShvYmopXG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhbnkgc3VwcG9ydGVkIHR5cGUgb250byB0aGUgZW5jb2RlZCBzdHJlYW1cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG9ialxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICBwdXNoQW55IChvYmopIHtcbiAgICB2YXIgdHlwID0gdG9UeXBlKG9iailcblxuICAgIHN3aXRjaCAodHlwKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE51bWJlcihvYmopXG4gICAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFN0cmluZyhvYmopXG4gICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hCb29sZWFuKG9iailcbiAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoT2JqZWN0KG9iailcbiAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hBcnJheSh0aGlzLCBvYmopXG4gICAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hCdWZmZXIodGhpcywgQnVmZmVyLmlzQnVmZmVyKG9iaikgPyBvYmogOiBCdWZmZXIuZnJvbShvYmopKVxuICAgICAgY2FzZSAnTnVsbCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoTlVMTClcbiAgICAgIGNhc2UgJ1VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoVW5kZWZpbmVkKG9iailcbiAgICAgIGNhc2UgJ01hcCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoTWFwKHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ1NldCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoU2V0KHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ1VSTCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoVXJsKHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ0JpZ051bWJlcic6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoQmlnTnVtYmVyKHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaERhdGUodGhpcywgb2JqKVxuICAgICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hSZWdleHAodGhpcywgb2JqKVxuICAgICAgY2FzZSAnU3ltYm9sJzpcbiAgICAgICAgc3dpdGNoIChvYmopIHtcbiAgICAgICAgICBjYXNlIFNZTVMuTlVMTDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXNoT2JqZWN0KG51bGwpXG4gICAgICAgICAgY2FzZSBTWU1TLlVOREVGSU5FRDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXNoVW5kZWZpbmVkKHVuZGVmaW5lZClcbiAgICAgICAgICAvLyBUT0RPOiBBZGQgcGx1Z2dhYmxlIHN1cHBvcnQgZm9yIG90aGVyIHN5bWJvbHNcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHN5bWJvbDogJyArIG9iai50b1N0cmluZygpKVxuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIHR5cGVvZiBvYmogKyAnLCAnICsgKG9iaiA/IG9iai50b1N0cmluZygpIDogJycpKVxuICAgIH1cbiAgfVxuXG4gIGZpbmFsaXplICgpIHtcbiAgICBpZiAodGhpcy5vZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0XG4gICAgdmFyIHJlc3VsdExlbmd0aCA9IHRoaXMucmVzdWx0TGVuZ3RoXG4gICAgdmFyIHJlc3VsdE1ldGhvZCA9IHRoaXMucmVzdWx0TWV0aG9kXG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlclxuICAgIHZhciBzaXplID0gMFxuICAgIHZhciBpID0gMFxuXG4gICAgZm9yICg7IGkgPCBvZmZzZXQ7IGkrKykge1xuICAgICAgc2l6ZSArPSByZXN1bHRMZW5ndGhbaV1cbiAgICB9XG5cbiAgICB2YXIgcmVzID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG4gICAgdmFyIGluZGV4ID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICAvLyBXcml0ZSB0aGUgY29udGVudCBpbnRvIHRoZSByZXN1bHQgYnVmZmVyXG4gICAgZm9yIChpID0gMDsgaSA8IG9mZnNldDsgaSsrKSB7XG4gICAgICBsZW5ndGggPSByZXN1bHRMZW5ndGhbaV1cblxuICAgICAgc3dpdGNoIChyZXN1bHRNZXRob2RbaV0pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJlc3VsdFtpXS5jb3B5KHJlcywgaW5kZXgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlcy53cml0ZVVJbnQ4KHJlc3VsdFtpXSwgaW5kZXgsIHRydWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJlcy53cml0ZVVJbnQxNkJFKHJlc3VsdFtpXSwgaW5kZXgsIHRydWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJlcy53cml0ZVVJbnQzMkJFKHJlc3VsdFtpXSwgaW5kZXgsIHRydWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJlcy53cml0ZURvdWJsZUJFKHJlc3VsdFtpXSwgaW5kZXgsIHRydWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlcy53cml0ZShyZXN1bHRbaV0sIGluZGV4LCBsZW5ndGgsICd1dGY4JylcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rb3duIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IGxlbmd0aFxuICAgIH1cblxuICAgIHZhciB0bXAgPSByZXNcblxuICAgIHRoaXMuX3Jlc2V0KClcblxuICAgIHJldHVybiB0bXBcbiAgfVxuXG4gIF9yZXNldCAoKSB7XG4gICAgdGhpcy5yZXN1bHQgPSBbXVxuICAgIHRoaXMucmVzdWx0TWV0aG9kID0gW11cbiAgICB0aGlzLnJlc3VsdExlbmd0aCA9IFtdXG4gICAgdGhpcy5vZmZzZXQgPSAwXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IG9cbiAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICovXG4gIHN0YXRpYyBlbmNvZGUgKG8pIHtcbiAgICBjb25zdCBlbmMgPSBuZXcgRW5jb2RlcigpXG4gICAgY29uc3QgcmV0ID0gZW5jLnB1c2hBbnkobylcbiAgICBpZiAoIXJldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZW5jb2RlIGlucHV0JylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jLmZpbmFsaXplKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVuY29kZXJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/encoder.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\n// exports.Commented = require('./commented')\nexports.Diagnose = __webpack_require__(/*! ./diagnose */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/diagnose.js\")\nexports.Decoder = __webpack_require__(/*! ./decoder */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/decoder.js\")\nexports.Encoder = __webpack_require__(/*! ./encoder */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/encoder.js\")\nexports.Simple = __webpack_require__(/*! ./simple */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/simple.js\")\nexports.Tagged = __webpack_require__(/*! ./tagged */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/tagged.js\")\n\n// exports.comment = exports.Commented.comment\nexports.decodeAll = exports.Decoder.decodeAll\nexports.decodeFirst = exports.Decoder.decodeFirst\nexports.diagnose = exports.Diagnose.diagnose\nexports.encode = exports.Encoder.encode\nexports.decode = exports.Decoder.decode\n\nexports.leveldb = {\n  decode: exports.Decoder.decodeAll,\n  encode: exports.Encoder.encode,\n  buffer: true,\n  name: 'cbor'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yY0AyLjEuMi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSw2SEFBd0M7QUFDeEMsMEhBQXNDO0FBQ3RDLDBIQUFzQztBQUN0Qyx1SEFBb0M7QUFDcEMsdUhBQW9DOztBQUVwQztBQUNBLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxjQUFjOztBQUVkLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL2JvcmNAMi4xLjIvbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBleHBvcnRzLkNvbW1lbnRlZCA9IHJlcXVpcmUoJy4vY29tbWVudGVkJylcbmV4cG9ydHMuRGlhZ25vc2UgPSByZXF1aXJlKCcuL2RpYWdub3NlJylcbmV4cG9ydHMuRGVjb2RlciA9IHJlcXVpcmUoJy4vZGVjb2RlcicpXG5leHBvcnRzLkVuY29kZXIgPSByZXF1aXJlKCcuL2VuY29kZXInKVxuZXhwb3J0cy5TaW1wbGUgPSByZXF1aXJlKCcuL3NpbXBsZScpXG5leHBvcnRzLlRhZ2dlZCA9IHJlcXVpcmUoJy4vdGFnZ2VkJylcblxuLy8gZXhwb3J0cy5jb21tZW50ID0gZXhwb3J0cy5Db21tZW50ZWQuY29tbWVudFxuZXhwb3J0cy5kZWNvZGVBbGwgPSBleHBvcnRzLkRlY29kZXIuZGVjb2RlQWxsXG5leHBvcnRzLmRlY29kZUZpcnN0ID0gZXhwb3J0cy5EZWNvZGVyLmRlY29kZUZpcnN0XG5leHBvcnRzLmRpYWdub3NlID0gZXhwb3J0cy5EaWFnbm9zZS5kaWFnbm9zZVxuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLkVuY29kZXIuZW5jb2RlXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuRGVjb2Rlci5kZWNvZGVcblxuZXhwb3J0cy5sZXZlbGRiID0ge1xuICBkZWNvZGU6IGV4cG9ydHMuRGVjb2Rlci5kZWNvZGVBbGwsXG4gIGVuY29kZTogZXhwb3J0cy5FbmNvZGVyLmVuY29kZSxcbiAgYnVmZmVyOiB0cnVlLFxuICBuYW1lOiAnY2Jvcidcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/simple.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/simple.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/constants.js\")\nconst MT = constants.MT\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {integer} value - the simple value's integer value\n   */\n  constructor (value) {\n    if (typeof value !== 'number') {\n      throw new Error('Invalid Simple type: ' + (typeof value))\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error('value must be a small positive integer: ' + value)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  toString () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  inspect () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj - object to test\n   * @returns {bool} - is it Simple?\n   */\n  static isSimple (obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {Number} val - the CBOR additional info to convert\n   * @param {bool} hasParent - Does the CBOR item have a parent?\n   * @returns {(null|undefined|Boolean|Symbol)} - the decoded value\n   */\n  static decode (val, hasParent) {\n    if (hasParent == null) {\n      hasParent = true\n    }\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (hasParent) {\n          return null\n        } else {\n          return SYMS.NULL\n        }\n      case SIMPLE.UNDEFINED:\n        if (hasParent) {\n          return undefined\n        } else {\n          return SYMS.UNDEFINED\n        }\n      case -1:\n        if (!hasParent) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yY0AyLjEuMi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvc2ltcGxlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFhO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxNQUFNO0FBQ25CLGVBQWUsaUNBQWlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL2JvcmNAMi4xLjIvbm9kZV9tb2R1bGVzL2JvcmMvc3JjL3NpbXBsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgTVQgPSBjb25zdGFudHMuTVRcbmNvbnN0IFNJTVBMRSA9IGNvbnN0YW50cy5TSU1QTEVcbmNvbnN0IFNZTVMgPSBjb25zdGFudHMuU1lNU1xuXG4vKipcbiAqIEEgQ0JPUiBTaW1wbGUgVmFsdWUgdGhhdCBkb2VzIG5vdCBtYXAgb250byBhIGtub3duIGNvbnN0YW50LlxuICovXG5jbGFzcyBTaW1wbGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBTaW1wbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgLSB0aGUgc2ltcGxlIHZhbHVlJ3MgaW50ZWdlciB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTaW1wbGUgdHlwZTogJyArICh0eXBlb2YgdmFsdWUpKVxuICAgIH1cbiAgICBpZiAoKHZhbHVlIDwgMCkgfHwgKHZhbHVlID4gMjU1KSB8fCAoKHZhbHVlIHwgMCkgIT09IHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIGEgc21hbGwgcG9zaXRpdmUgaW50ZWdlcjogJyArIHZhbHVlKVxuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWJ1ZyBzdHJpbmcgZm9yIHNpbXBsZSB2YWx1ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzaW1wbGUodmFsdWUpXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdzaW1wbGUoJyArIHRoaXMudmFsdWUgKyAnKSdcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWJ1ZyBzdHJpbmcgZm9yIHNpbXBsZSB2YWx1ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzaW1wbGUodmFsdWUpXG4gICAqL1xuICBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gJ3NpbXBsZSgnICsgdGhpcy52YWx1ZSArICcpJ1xuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggdGhlIHNpbXBsZSB2YWx1ZSBvbnRvIHRoZSBDQk9SIHN0cmVhbVxuICAgKlxuICAgKiBAcGFyYW0ge2Nib3IuRW5jb2Rlcn0gZ2VuIFRoZSBnZW5lcmF0b3IgdG8gcHVzaCBvbnRvXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBlbmNvZGVDQk9SIChnZW4pIHtcbiAgICByZXR1cm4gZ2VuLl9wdXNoSW50KHRoaXMudmFsdWUsIE1ULlNJTVBMRV9GTE9BVClcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgZ2l2ZW4gb2JqZWN0IGEgU2ltcGxlP1xuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gb2JqIC0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2x9IC0gaXMgaXQgU2ltcGxlP1xuICAgKi9cbiAgc3RhdGljIGlzU2ltcGxlIChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgU2ltcGxlXG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGZyb20gdGhlIENCT1IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpbnRvIGEgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgICogSWYgdGhlIENCT1IgaXRlbSBoYXMgbm8gcGFyZW50LCByZXR1cm4gYSBcInNhZmVcIiBzeW1ib2wgaW5zdGVhZCBvZlxuICAgKiBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIHNvIHRoYXQgdGhlIHZhbHVlIGNhbiBiZSBwYXNzZWQgdGhyb3VnaCBhXG4gICAqIHN0cmVhbSBpbiBvYmplY3QgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIHRoZSBDQk9SIGFkZGl0aW9uYWwgaW5mbyB0byBjb252ZXJ0XG4gICAqIEBwYXJhbSB7Ym9vbH0gaGFzUGFyZW50IC0gRG9lcyB0aGUgQ0JPUiBpdGVtIGhhdmUgYSBwYXJlbnQ/XG4gICAqIEByZXR1cm5zIHsobnVsbHx1bmRlZmluZWR8Qm9vbGVhbnxTeW1ib2wpfSAtIHRoZSBkZWNvZGVkIHZhbHVlXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlICh2YWwsIGhhc1BhcmVudCkge1xuICAgIGlmIChoYXNQYXJlbnQgPT0gbnVsbCkge1xuICAgICAgaGFzUGFyZW50ID0gdHJ1ZVxuICAgIH1cbiAgICBzd2l0Y2ggKHZhbCkge1xuICAgICAgY2FzZSBTSU1QTEUuRkFMU0U6XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgY2FzZSBTSU1QTEUuVFJVRTpcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGNhc2UgU0lNUExFLk5VTEw6XG4gICAgICAgIGlmIChoYXNQYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBTWU1TLk5VTExcbiAgICAgICAgfVxuICAgICAgY2FzZSBTSU1QTEUuVU5ERUZJTkVEOlxuICAgICAgICBpZiAoaGFzUGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBTWU1TLlVOREVGSU5FRFxuICAgICAgICB9XG4gICAgICBjYXNlIC0xOlxuICAgICAgICBpZiAoIWhhc1BhcmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBCUkVBSycpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNZTVMuQlJFQUtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlKHZhbClcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/simple.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/tagged.js":
/*!***********************************************************************!*\
  !*** ./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/tagged.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {Number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} err - the error that was thrown parsing the tag, or null\n   */\n  constructor (tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error('Tag must be a positive integer: ' + this.tag)\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {String} string of the form '1(2)'\n   */\n  toString () {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert (converters) {\n    var er, f\n    f = converters != null ? converters[this.tag] : undefined\n    if (typeof f !== 'function') {\n      f = Tagged['_tag' + this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(Tagged, this.value)\n    } catch (error) {\n      er = error\n      this.err = er\n      return this\n    }\n  }\n}\n\nmodule.exports = Tagged\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yY0AyLjEuMi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvdGFnZ2VkLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGNBQWMsU0FBUyxHQUFHLDJCQUEyQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9ib3JjQDIuMS4yL25vZGVfbW9kdWxlcy9ib3JjL3NyYy90YWdnZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQSBDQk9SIHRhZ2dlZCBpdGVtLCB3aGVyZSB0aGUgdGFnIGRvZXMgbm90IGhhdmUgc2VtYW50aWNzIHNwZWNpZmllZCBhdCB0aGVcbiAqIG1vbWVudCwgb3IgdGhvc2Ugc2VtYW50aWNzIHRocmV3IGFuIGVycm9yIGR1cmluZyBwYXJzaW5nLiBUeXBpY2FsbHkgdGhpcyB3aWxsXG4gKiBiZSBhbiBleHRlbnNpb24gcG9pbnQgeW91J3JlIG5vdCB5ZXQgZXhwZWN0aW5nLlxuICovXG5jbGFzcyBUYWdnZWQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBUYWdnZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0YWcgLSB0aGUgbnVtYmVyIG9mIHRoZSB0YWdcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gdGhlIHZhbHVlIGluc2lkZSB0aGUgdGFnXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIHRoZSBlcnJvciB0aGF0IHdhcyB0aHJvd24gcGFyc2luZyB0aGUgdGFnLCBvciBudWxsXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodGFnLCB2YWx1ZSwgZXJyKSB7XG4gICAgdGhpcy50YWcgPSB0YWdcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLmVyciA9IGVyclxuICAgIGlmICh0eXBlb2YgdGhpcy50YWcgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFnIHR5cGUgKCcgKyAodHlwZW9mIHRoaXMudGFnKSArICcpJylcbiAgICB9XG4gICAgaWYgKCh0aGlzLnRhZyA8IDApIHx8ICgodGhpcy50YWcgfCAwKSAhPT0gdGhpcy50YWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhZyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcjogJyArIHRoaXMudGFnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgU3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyBvZiB0aGUgZm9ybSAnMSgyKSdcbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy50YWd9KCR7SlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSl9KWBcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIHRoZSBzaW1wbGUgdmFsdWUgb250byB0aGUgQ0JPUiBzdHJlYW1cbiAgICpcbiAgICogQHBhcmFtIHtjYm9yLkVuY29kZXJ9IGdlbiBUaGUgZ2VuZXJhdG9yIHRvIHB1c2ggb250b1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZW5jb2RlQ0JPUiAoZ2VuKSB7XG4gICAgZ2VuLl9wdXNoVGFnKHRoaXMudGFnKVxuICAgIHJldHVybiBnZW4ucHVzaEFueSh0aGlzLnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlIGhhdmUgYSBjb252ZXJ0ZXIgZm9yIHRoaXMgdHlwZSwgZG8gdGhlIGNvbnZlcnNpb24uICBTb21lIGNvbnZlcnRlcnNcbiAgICogYXJlIGJ1aWx0LWluLiAgQWRkaXRpb25hbCBvbmVzIGNhbiBiZSBwYXNzZWQgaW4uICBJZiB5b3Ugd2FudCB0byByZW1vdmVcbiAgICogYSBidWlsdC1pbiBjb252ZXJ0ZXIsIHBhc3MgYSBjb252ZXJ0ZXIgaW4gd2hvc2UgdmFsdWUgaXMgJ251bGwnIGluc3RlYWRcbiAgICogb2YgYSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnZlcnRlcnMgLSBrZXlzIGluIHRoZSBvYmplY3QgYXJlIGEgdGFnIG51bWJlciwgdGhlIHZhbHVlXG4gICAqICAgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBkZWNvZGVkIENCT1IgYW5kIHJldHVybnMgYSBKYXZhU2NyaXB0IHZhbHVlXG4gICAqICAgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGUuICBUaHJvdyBhbiBleGNlcHRpb24gaW4gdGhlIGZ1bmN0aW9uIG9uIGVycm9ycy5cbiAgICogQHJldHVybnMge2FueX0gLSB0aGUgY29udmVydGVkIGl0ZW1cbiAgICovXG4gIGNvbnZlcnQgKGNvbnZlcnRlcnMpIHtcbiAgICB2YXIgZXIsIGZcbiAgICBmID0gY29udmVydGVycyAhPSBudWxsID8gY29udmVydGVyc1t0aGlzLnRhZ10gOiB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGYgPSBUYWdnZWRbJ190YWcnICsgdGhpcy50YWddXG4gICAgICBpZiAodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmLmNhbGwoVGFnZ2VkLCB0aGlzLnZhbHVlKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBlciA9IGVycm9yXG4gICAgICB0aGlzLmVyciA9IGVyXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRhZ2dlZFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/tagged.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/utils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"./node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"./node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/constants.js\")\nconst SHIFT32 = constants.SHIFT32\nconst SHIFT16 = constants.SHIFT16\nconst MAX_SAFE_HIGH = 0x1fffff\n\nexports.parseHalf = function parseHalf (buf) {\n  var exp, mant, sign\n  sign = buf[0] & 0x80 ? -1 : 1\n  exp = (buf[0] & 0x7C) >> 2\n  mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308)\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant)\n  }\n}\n\nfunction toHex (n) {\n  if (n < 16) {\n    return '0' + n.toString(16)\n  }\n\n  return n.toString(16)\n}\n\nexports.arrayBufferToBignumber = function (buf) {\n  const len = buf.byteLength\n  let res = ''\n  for (let i = 0; i < len; i++) {\n    res += toHex(buf[i])\n  }\n\n  return new Bignumber(res, 16)\n}\n\n// convert an Object into a Map\nexports.buildMap = (obj) => {\n  const res = new Map()\n  const keys = Object.keys(obj)\n  const length = keys.length\n  for (let i = 0; i < length; i++) {\n    res.set(keys[i], obj[keys[i]])\n  }\n  return res\n}\n\nexports.buildInt32 = (f, g) => {\n  return f * SHIFT16 + g\n}\n\nexports.buildInt64 = (f1, f2, g1, g2) => {\n  const f = exports.buildInt32(f1, f2)\n  const g = exports.buildInt32(g1, g2)\n\n  if (f > MAX_SAFE_HIGH) {\n    return new Bignumber(f).times(SHIFT32).plus(g)\n  } else {\n    return (f * SHIFT32) + g\n  }\n}\n\nexports.writeHalf = function writeHalf (buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits are 0, we won't lose anything in the conversion\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  var s16 = (u >> 16) & 0x8000 // top bit is sign\n  const exp = (u >> 23) & 0xff // then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n\n  //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n  //     if (mant & ((1 << (126 - exp)) - 1))\n  //       goto float32;         /* loss of precision */\n  //     s16 += ((mant + 0x800000) >> (126 - exp));\n  } else if ((exp >= 103) && (exp < 113)) {\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n\n    //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n  //   } else\n  //     goto float32;           /* loss of range */\n  } else {\n    return false\n  }\n\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16, 0)\n  return true\n}\n\nexports.keySorter = function (a, b) {\n  var lenA = a[0].byteLength\n  var lenB = b[0].byteLength\n\n  if (lenA > lenB) {\n    return 1\n  }\n\n  if (lenB > lenA) {\n    return -1\n  }\n\n  return a[0].compare(b[0])\n}\n\n// Adapted from http://www.2ality.com/2012/03/signedzero.html\nexports.isNegativeZero = (x) => {\n  return x === 0 && (1 / x < 0)\n}\n\nexports.nextPowerOf2 = (n) => {\n  let count = 0\n  // First n in the below condition is for\n  // the case where n is 0\n  if (n && !(n & (n - 1))) {\n    return n\n  }\n\n  while (n !== 0) {\n    n >>= 1\n    count += 1\n  }\n\n  return 1 << count\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yY0AyLjEuMi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw4RUFBUTtBQUNuQyxrQkFBa0IscUlBQWlDOztBQUVuRCxrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBLGlDQUFpQztBQUNqQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG9DQUFvQztBQUMvQzs7QUFFQTs7QUFFQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vYm9yY0AyLjEuMi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgQmlnbnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJykuQmlnTnVtYmVyXG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IFNISUZUMzIgPSBjb25zdGFudHMuU0hJRlQzMlxuY29uc3QgU0hJRlQxNiA9IGNvbnN0YW50cy5TSElGVDE2XG5jb25zdCBNQVhfU0FGRV9ISUdIID0gMHgxZmZmZmZcblxuZXhwb3J0cy5wYXJzZUhhbGYgPSBmdW5jdGlvbiBwYXJzZUhhbGYgKGJ1Zikge1xuICB2YXIgZXhwLCBtYW50LCBzaWduXG4gIHNpZ24gPSBidWZbMF0gJiAweDgwID8gLTEgOiAxXG4gIGV4cCA9IChidWZbMF0gJiAweDdDKSA+PiAyXG4gIG1hbnQgPSAoKGJ1ZlswXSAmIDB4MDMpIDw8IDgpIHwgYnVmWzFdXG4gIGlmICghZXhwKSB7XG4gICAgcmV0dXJuIHNpZ24gKiA1Ljk2MDQ2NDQ3NzUzOTA2MjVlLTggKiBtYW50XG4gIH0gZWxzZSBpZiAoZXhwID09PSAweDFmKSB7XG4gICAgcmV0dXJuIHNpZ24gKiAobWFudCA/IDAgLyAwIDogMmUzMDgpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNpZ24gKiBNYXRoLnBvdygyLCBleHAgLSAyNSkgKiAoMTAyNCArIG1hbnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikge1xuICAgIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICB9XG5cbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmV4cG9ydHMuYXJyYXlCdWZmZXJUb0JpZ251bWJlciA9IGZ1bmN0aW9uIChidWYpIHtcbiAgY29uc3QgbGVuID0gYnVmLmJ5dGVMZW5ndGhcbiAgbGV0IHJlcyA9ICcnXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXMgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBCaWdudW1iZXIocmVzLCAxNilcbn1cblxuLy8gY29udmVydCBhbiBPYmplY3QgaW50byBhIE1hcFxuZXhwb3J0cy5idWlsZE1hcCA9IChvYmopID0+IHtcbiAgY29uc3QgcmVzID0gbmV3IE1hcCgpXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXMuc2V0KGtleXNbaV0sIG9ialtrZXlzW2ldXSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmV4cG9ydHMuYnVpbGRJbnQzMiA9IChmLCBnKSA9PiB7XG4gIHJldHVybiBmICogU0hJRlQxNiArIGdcbn1cblxuZXhwb3J0cy5idWlsZEludDY0ID0gKGYxLCBmMiwgZzEsIGcyKSA9PiB7XG4gIGNvbnN0IGYgPSBleHBvcnRzLmJ1aWxkSW50MzIoZjEsIGYyKVxuICBjb25zdCBnID0gZXhwb3J0cy5idWlsZEludDMyKGcxLCBnMilcblxuICBpZiAoZiA+IE1BWF9TQUZFX0hJR0gpIHtcbiAgICByZXR1cm4gbmV3IEJpZ251bWJlcihmKS50aW1lcyhTSElGVDMyKS5wbHVzKGcpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmICogU0hJRlQzMikgKyBnXG4gIH1cbn1cblxuZXhwb3J0cy53cml0ZUhhbGYgPSBmdW5jdGlvbiB3cml0ZUhhbGYgKGJ1ZiwgaGFsZikge1xuICAvLyBhc3N1bWUgMCwgLTAsIE5hTiwgSW5maW5pdHksIGFuZCAtSW5maW5pdHkgaGF2ZSBhbHJlYWR5IGJlZW4gY2F1Z2h0XG5cbiAgLy8gSEFDSzogZXZlcnlvbmUgc2V0dGxlIGluLiAgVGhpcyBpc24ndCBnb2luZyB0byBiZSBwcmV0dHkuXG4gIC8vIFRyYW5zbGF0ZSBjbi1jYm9yJ3MgQyBjb2RlIChmcm9tIENhcnN0ZW4gQm9ybWFuKTpcblxuICAvLyB1aW50MzJfdCBiZTMyO1xuICAvLyB1aW50MTZfdCBiZTE2LCB1MTY7XG4gIC8vIHVuaW9uIHtcbiAgLy8gICBmbG9hdCBmO1xuICAvLyAgIHVpbnQzMl90IHU7XG4gIC8vIH0gdTMyO1xuICAvLyB1MzIuZiA9IGZsb2F0X3ZhbDtcblxuICBjb25zdCB1MzIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNClcbiAgdTMyLndyaXRlRmxvYXRCRShoYWxmLCAwKVxuICBjb25zdCB1ID0gdTMyLnJlYWRVSW50MzJCRSgwKVxuXG4gIC8vIGlmICgodTMyLnUgJiAweDFGRkYpID09IDApIHsgLyogd29ydGggdHJ5aW5nIGhhbGYgKi9cblxuICAvLyBoaWxkamo6IElmIHRoZSBsb3dlciAxMyBiaXRzIGFyZSAwLCB3ZSB3b24ndCBsb3NlIGFueXRoaW5nIGluIHRoZSBjb252ZXJzaW9uXG4gIGlmICgodSAmIDB4MUZGRikgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vICAgaW50IHMxNiA9ICh1MzIudSA+PiAxNikgJiAweDgwMDA7XG4gIC8vICAgaW50IGV4cCA9ICh1MzIudSA+PiAyMykgJiAweGZmO1xuICAvLyAgIGludCBtYW50ID0gdTMyLnUgJiAweDdmZmZmZjtcblxuICB2YXIgczE2ID0gKHUgPj4gMTYpICYgMHg4MDAwIC8vIHRvcCBiaXQgaXMgc2lnblxuICBjb25zdCBleHAgPSAodSA+PiAyMykgJiAweGZmIC8vIHRoZW4gNSBiaXRzIG9mIGV4cG9uZW50XG4gIGNvbnN0IG1hbnQgPSB1ICYgMHg3ZmZmZmZcblxuICAvLyAgIGlmIChleHAgPT0gMCAmJiBtYW50ID09IDApXG4gIC8vICAgICA7ICAgICAgICAgICAgICAvKiAwLjAsIC0wLjAgKi9cblxuICAvLyBoaWxkamo6IHplcm9zIGFscmVhZHkgaGFuZGxlZC4gIEFzc2VydCBpZiB5b3UgZG9uJ3QgYmVsaWV2ZSBtZS5cblxuICAvLyAgIGVsc2UgaWYgKGV4cCA+PSAxMTMgJiYgZXhwIDw9IDE0MikgLyogbm9ybWFsaXplZCAqL1xuICAvLyAgICAgczE2ICs9ICgoZXhwIC0gMTEyKSA8PCAxMCkgKyAobWFudCA+PiAxMyk7XG4gIGlmICgoZXhwID49IDExMykgJiYgKGV4cCA8PSAxNDIpKSB7XG4gICAgczE2ICs9ICgoZXhwIC0gMTEyKSA8PCAxMCkgKyAobWFudCA+PiAxMylcblxuICAvLyAgIGVsc2UgaWYgKGV4cCA+PSAxMDMgJiYgZXhwIDwgMTEzKSB7IC8qIGRlbm9ybSwgZXhwMTYgPSAwICovXG4gIC8vICAgICBpZiAobWFudCAmICgoMSA8PCAoMTI2IC0gZXhwKSkgLSAxKSlcbiAgLy8gICAgICAgZ290byBmbG9hdDMyOyAgICAgICAgIC8qIGxvc3Mgb2YgcHJlY2lzaW9uICovXG4gIC8vICAgICBzMTYgKz0gKChtYW50ICsgMHg4MDAwMDApID4+ICgxMjYgLSBleHApKTtcbiAgfSBlbHNlIGlmICgoZXhwID49IDEwMykgJiYgKGV4cCA8IDExMykpIHtcbiAgICBpZiAobWFudCAmICgoMSA8PCAoMTI2IC0gZXhwKSkgLSAxKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHMxNiArPSAoKG1hbnQgKyAweDgwMDAwMCkgPj4gKDEyNiAtIGV4cCkpXG5cbiAgICAvLyAgIH0gZWxzZSBpZiAoZXhwID09IDI1NSAmJiBtYW50ID09IDApIHsgLyogSW5mICovXG4gICAgLy8gICAgIHMxNiArPSAweDdjMDA7XG5cbiAgICAvLyBoaWxkamo6IEluZmluaXR5IGFscmVhZHkgaGFuZGxlZFxuXG4gIC8vICAgfSBlbHNlXG4gIC8vICAgICBnb3RvIGZsb2F0MzI7ICAgICAgICAgICAvKiBsb3NzIG9mIHJhbmdlICovXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAgIGVuc3VyZV93cml0YWJsZSgzKTtcbiAgLy8gICB1MTYgPSBzMTY7XG4gIC8vICAgYmUxNiA9IGh0b24xNnAoKGNvbnN0IHVpbnQ4X3QqKSZ1MTYpO1xuICBidWYud3JpdGVVSW50MTZCRShzMTYsIDApXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydHMua2V5U29ydGVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGxlbkEgPSBhWzBdLmJ5dGVMZW5ndGhcbiAgdmFyIGxlbkIgPSBiWzBdLmJ5dGVMZW5ndGhcblxuICBpZiAobGVuQSA+IGxlbkIpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgaWYgKGxlbkIgPiBsZW5BKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICByZXR1cm4gYVswXS5jb21wYXJlKGJbMF0pXG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwOi8vd3d3LjJhbGl0eS5jb20vMjAxMi8wMy9zaWduZWR6ZXJvLmh0bWxcbmV4cG9ydHMuaXNOZWdhdGl2ZVplcm8gPSAoeCkgPT4ge1xuICByZXR1cm4geCA9PT0gMCAmJiAoMSAvIHggPCAwKVxufVxuXG5leHBvcnRzLm5leHRQb3dlck9mMiA9IChuKSA9PiB7XG4gIGxldCBjb3VudCA9IDBcbiAgLy8gRmlyc3QgbiBpbiB0aGUgYmVsb3cgY29uZGl0aW9uIGlzIGZvclxuICAvLyB0aGUgY2FzZSB3aGVyZSBuIGlzIDBcbiAgaWYgKG4gJiYgIShuICYgKG4gLSAxKSkpIHtcbiAgICByZXR1cm4gblxuICB9XG5cbiAgd2hpbGUgKG4gIT09IDApIHtcbiAgICBuID4+PSAxXG4gICAgY291bnQgKz0gMVxuICB9XG5cbiAgcmV0dXJuIDEgPDwgY291bnRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/borc@2.1.2/node_modules/borc/src/utils.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\")\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYnVmZmVyQDUuNy4xL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLHVGQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxpRkFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vYnVmZmVyQDUuNy4xL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBCdWZmZXIuZnJvbShidWYpLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxudmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgdmFyIHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgdmFyIGkxNiA9IGkgKiAxNlxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vYnVmZmVyQDYuMC4zL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHVGQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLGlGQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxxQkFBcUIsV0FBVyxHQUFHLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxnQkFBZ0IsV0FBVyxHQUFHLElBQUksS0FBSyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0Qjs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLEtBQUssbURBQW1ELGNBQWM7QUFDekYsR0FBRztBQUNIO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU0sYUFBYSxTQUFTO0FBQ3REO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCLGNBQWMsb0JBQW9CLEVBQUUsSUFBSTtBQUN4QztBQUNBLFlBQVksZ0JBQWdCLEVBQUUsSUFBSTtBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRyxTQUFTLEdBQUcsS0FBSyxxQkFBcUIsRUFBRSxFQUFFO0FBQ3BFLFFBQVE7QUFDUix5QkFBeUIsR0FBRyxLQUFLLHlCQUF5QixFQUFFLEVBQUU7QUFDOUQsbUJBQW1CLHlCQUF5QixFQUFFLEVBQUU7QUFDaEQ7QUFDQSxNQUFNO0FBQ04sb0JBQW9CLElBQUksRUFBRSxHQUFHLFNBQVMsSUFBSSxFQUFFLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGNBQWMsU0FBUyxPQUFPO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vYnVmZmVyQDYuMC4zL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vaWVlZTc1NEAxLjIuMS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vaWVlZTc1NEAxLjIuMS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nconst {\n    URLWithLegacySupport,\n    format,\n    URLSearchParams,\n    defaultBase\n} = __webpack_require__(/*! ./src/url */ \"./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/src/url-browser.js\");\nconst relative = __webpack_require__(/*! ./src/relative */ \"./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/src/relative.js\");\n\nmodule.exports = {\n    URL: URLWithLegacySupport,\n    URLSearchParams,\n    format,\n    relative,\n    defaultBase\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vaXNvLXVybEAwLjQuNy9ub2RlX21vZHVsZXMvaXNvLXVybC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNkZBQVc7QUFDdkIsaUJBQWlCLG1CQUFPLENBQUMsK0ZBQWdCOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9pc28tdXJsQDAuNC43L25vZGVfbW9kdWxlcy9pc28tdXJsL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qge1xuICAgIFVSTFdpdGhMZWdhY3lTdXBwb3J0LFxuICAgIGZvcm1hdCxcbiAgICBVUkxTZWFyY2hQYXJhbXMsXG4gICAgZGVmYXVsdEJhc2Vcbn0gPSByZXF1aXJlKCcuL3NyYy91cmwnKTtcbmNvbnN0IHJlbGF0aXZlID0gcmVxdWlyZSgnLi9zcmMvcmVsYXRpdmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgVVJMOiBVUkxXaXRoTGVnYWN5U3VwcG9ydCxcbiAgICBVUkxTZWFyY2hQYXJhbXMsXG4gICAgZm9ybWF0LFxuICAgIHJlbGF0aXZlLFxuICAgIGRlZmF1bHRCYXNlXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/src/relative.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/src/relative.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nconst { URLWithLegacySupport, format } = __webpack_require__(/*! ./url */ \"./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/src/url-browser.js\");\n\nmodule.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {\n    let protocol = location.protocol ?\n        location.protocol.replace(':', '') :\n        'http';\n\n    // Check protocol map\n    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':';\n    let urlParsed;\n\n    try {\n        urlParsed = new URLWithLegacySupport(url);\n    } catch (err) {\n        urlParsed = {};\n    }\n\n    const base = Object.assign({}, location, {\n        protocol: protocol || urlParsed.protocol,\n        host: location.host || urlParsed.host\n    });\n\n    return new URLWithLegacySupport(url, format(base)).toString();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vaXNvLXVybEAwLjQuNy9ub2RlX21vZHVsZXMvaXNvLXVybC9zcmMvcmVsYXRpdmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLHlGQUFPOztBQUV4RCxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL2lzby11cmxAMC40Ljcvbm9kZV9tb2R1bGVzL2lzby11cmwvc3JjL3JlbGF0aXZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBVUkxXaXRoTGVnYWN5U3VwcG9ydCwgZm9ybWF0IH0gPSByZXF1aXJlKCcuL3VybCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICh1cmwsIGxvY2F0aW9uID0ge30sIHByb3RvY29sTWFwID0ge30sIGRlZmF1bHRQcm90b2NvbCkgPT4ge1xuICAgIGxldCBwcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sID9cbiAgICAgICAgbG9jYXRpb24ucHJvdG9jb2wucmVwbGFjZSgnOicsICcnKSA6XG4gICAgICAgICdodHRwJztcblxuICAgIC8vIENoZWNrIHByb3RvY29sIG1hcFxuICAgIHByb3RvY29sID0gKHByb3RvY29sTWFwW3Byb3RvY29sXSB8fCBkZWZhdWx0UHJvdG9jb2wgfHwgcHJvdG9jb2wpICsgJzonO1xuICAgIGxldCB1cmxQYXJzZWQ7XG5cbiAgICB0cnkge1xuICAgICAgICB1cmxQYXJzZWQgPSBuZXcgVVJMV2l0aExlZ2FjeVN1cHBvcnQodXJsKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdXJsUGFyc2VkID0ge307XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZSA9IE9iamVjdC5hc3NpZ24oe30sIGxvY2F0aW9uLCB7XG4gICAgICAgIHByb3RvY29sOiBwcm90b2NvbCB8fCB1cmxQYXJzZWQucHJvdG9jb2wsXG4gICAgICAgIGhvc3Q6IGxvY2F0aW9uLmhvc3QgfHwgdXJsUGFyc2VkLmhvc3RcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgVVJMV2l0aExlZ2FjeVN1cHBvcnQodXJsLCBmb3JtYXQoYmFzZSkpLnRvU3RyaW5nKCk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/src/relative.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/src/url-browser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/src/url-browser.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nconst defaultBase = self.location ?\n    self.location.protocol + '//' + self.location.host :\n    '';\nconst URL = self.URL;\n\nclass URLWithLegacySupport {\n    constructor(url = '', base = defaultBase) {\n        this.super = new URL(url, base);\n        this.path = this.pathname + this.search;\n        this.auth =\n            this.username && this.password ?\n                this.username + ':' + this.password :\n                null;\n\n        this.query =\n            this.search && this.search.startsWith('?') ?\n                this.search.slice(1) :\n                null;\n    }\n\n    get hash() {\n        return this.super.hash;\n    }\n    get host() {\n        return this.super.host;\n    }\n    get hostname() {\n        return this.super.hostname;\n    }\n    get href() {\n        return this.super.href;\n    }\n    get origin() {\n        return this.super.origin;\n    }\n    get password() {\n        return this.super.password;\n    }\n    get pathname() {\n        return this.super.pathname;\n    }\n    get port() {\n        return this.super.port;\n    }\n    get protocol() {\n        return this.super.protocol;\n    }\n    get search() {\n        return this.super.search;\n    }\n    get searchParams() {\n        return this.super.searchParams;\n    }\n    get username() {\n        return this.super.username;\n    }\n\n    set hash(hash) {\n        this.super.hash = hash;\n    }\n    set host(host) {\n        this.super.host = host;\n    }\n    set hostname(hostname) {\n        this.super.hostname = hostname;\n    }\n    set href(href) {\n        this.super.href = href;\n    }\n    set origin(origin) {\n        this.super.origin = origin;\n    }\n    set password(password) {\n        this.super.password = password;\n    }\n    set pathname(pathname) {\n        this.super.pathname = pathname;\n    }\n    set port(port) {\n        this.super.port = port;\n    }\n    set protocol(protocol) {\n        this.super.protocol = protocol;\n    }\n    set search(search) {\n        this.super.search = search;\n    }\n    set searchParams(searchParams) {\n        this.super.searchParams = searchParams;\n    }\n    set username(username) {\n        this.super.username = username;\n    }\n\n    createObjectURL(o) {\n        return this.super.createObjectURL(o);\n    }\n    revokeObjectURL(o) {\n        this.super.revokeObjectURL(o);\n    }\n    toJSON() {\n        return this.super.toJSON();\n    }\n    toString() {\n        return this.super.toString();\n    }\n    format() {\n        return this.toString();\n    }\n}\n\nfunction format(obj) {\n    if (typeof obj === 'string') {\n        const url = new URL(obj);\n\n        return url.toString();\n    }\n\n    if (!(obj instanceof URL)) {\n        const userPass =\n            obj.username && obj.password ?\n                `${obj.username}:${obj.password}@` :\n                '';\n        const auth = obj.auth ? obj.auth + '@' : '';\n        const port = obj.port ? ':' + obj.port : '';\n        const protocol = obj.protocol ? obj.protocol + '//' : '';\n        const host = obj.host || '';\n        const hostname = obj.hostname || '';\n        const search = obj.search || (obj.query ? '?' + obj.query : '');\n        const hash = obj.hash || '';\n        const pathname = obj.pathname || '';\n        const path = obj.path || pathname + search;\n\n        return `${protocol}${userPass || auth}${host ||\n            hostname + port}${path}${hash}`;\n    }\n}\n\nmodule.exports = {\n    URLWithLegacySupport,\n    URLSearchParams: self.URLSearchParams,\n    defaultBase,\n    format\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vaXNvLXVybEAwLjQuNy9ub2RlX21vZHVsZXMvaXNvLXVybC9zcmMvdXJsLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsR0FBRyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTLEVBQUUsaUJBQWlCLEVBQUU7QUFDaEQsNEJBQTRCLEVBQUUsS0FBSyxFQUFFLEtBQUs7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vaXNvLXVybEAwLjQuNy9ub2RlX21vZHVsZXMvaXNvLXVybC9zcmMvdXJsLWJyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZWZhdWx0QmFzZSA9IHNlbGYubG9jYXRpb24gP1xuICAgIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgc2VsZi5sb2NhdGlvbi5ob3N0IDpcbiAgICAnJztcbmNvbnN0IFVSTCA9IHNlbGYuVVJMO1xuXG5jbGFzcyBVUkxXaXRoTGVnYWN5U3VwcG9ydCB7XG4gICAgY29uc3RydWN0b3IodXJsID0gJycsIGJhc2UgPSBkZWZhdWx0QmFzZSkge1xuICAgICAgICB0aGlzLnN1cGVyID0gbmV3IFVSTCh1cmwsIGJhc2UpO1xuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLnBhdGhuYW1lICsgdGhpcy5zZWFyY2g7XG4gICAgICAgIHRoaXMuYXV0aCA9XG4gICAgICAgICAgICB0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQgP1xuICAgICAgICAgICAgICAgIHRoaXMudXNlcm5hbWUgKyAnOicgKyB0aGlzLnBhc3N3b3JkIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuXG4gICAgICAgIHRoaXMucXVlcnkgPVxuICAgICAgICAgICAgdGhpcy5zZWFyY2ggJiYgdGhpcy5zZWFyY2guc3RhcnRzV2l0aCgnPycpID9cbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC5zbGljZSgxKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuaGFzaDtcbiAgICB9XG4gICAgZ2V0IGhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLmhvc3Q7XG4gICAgfVxuICAgIGdldCBob3N0bmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuaG9zdG5hbWU7XG4gICAgfVxuICAgIGdldCBocmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5ocmVmO1xuICAgIH1cbiAgICBnZXQgb3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5vcmlnaW47XG4gICAgfVxuICAgIGdldCBwYXNzd29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIucGFzc3dvcmQ7XG4gICAgfVxuICAgIGdldCBwYXRobmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIucGF0aG5hbWU7XG4gICAgfVxuICAgIGdldCBwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5wb3J0O1xuICAgIH1cbiAgICBnZXQgcHJvdG9jb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnByb3RvY29sO1xuICAgIH1cbiAgICBnZXQgc2VhcmNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5zZWFyY2g7XG4gICAgfVxuICAgIGdldCBzZWFyY2hQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgZ2V0IHVzZXJuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci51c2VybmFtZTtcbiAgICB9XG5cbiAgICBzZXQgaGFzaChoYXNoKSB7XG4gICAgICAgIHRoaXMuc3VwZXIuaGFzaCA9IGhhc2g7XG4gICAgfVxuICAgIHNldCBob3N0KGhvc3QpIHtcbiAgICAgICAgdGhpcy5zdXBlci5ob3N0ID0gaG9zdDtcbiAgICB9XG4gICAgc2V0IGhvc3RuYW1lKGhvc3RuYW1lKSB7XG4gICAgICAgIHRoaXMuc3VwZXIuaG9zdG5hbWUgPSBob3N0bmFtZTtcbiAgICB9XG4gICAgc2V0IGhyZWYoaHJlZikge1xuICAgICAgICB0aGlzLnN1cGVyLmhyZWYgPSBocmVmO1xuICAgIH1cbiAgICBzZXQgb3JpZ2luKG9yaWdpbikge1xuICAgICAgICB0aGlzLnN1cGVyLm9yaWdpbiA9IG9yaWdpbjtcbiAgICB9XG4gICAgc2V0IHBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgICAgIHRoaXMuc3VwZXIucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICB9XG4gICAgc2V0IHBhdGhuYW1lKHBhdGhuYW1lKSB7XG4gICAgICAgIHRoaXMuc3VwZXIucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICB9XG4gICAgc2V0IHBvcnQocG9ydCkge1xuICAgICAgICB0aGlzLnN1cGVyLnBvcnQgPSBwb3J0O1xuICAgIH1cbiAgICBzZXQgcHJvdG9jb2wocHJvdG9jb2wpIHtcbiAgICAgICAgdGhpcy5zdXBlci5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgIH1cbiAgICBzZXQgc2VhcmNoKHNlYXJjaCkge1xuICAgICAgICB0aGlzLnN1cGVyLnNlYXJjaCA9IHNlYXJjaDtcbiAgICB9XG4gICAgc2V0IHNlYXJjaFBhcmFtcyhzZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5zdXBlci5zZWFyY2hQYXJhbXMgPSBzZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIHNldCB1c2VybmFtZSh1c2VybmFtZSkge1xuICAgICAgICB0aGlzLnN1cGVyLnVzZXJuYW1lID0gdXNlcm5hbWU7XG4gICAgfVxuXG4gICAgY3JlYXRlT2JqZWN0VVJMKG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuY3JlYXRlT2JqZWN0VVJMKG8pO1xuICAgIH1cbiAgICByZXZva2VPYmplY3RVUkwobykge1xuICAgICAgICB0aGlzLnN1cGVyLnJldm9rZU9iamVjdFVSTChvKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci50b0pTT04oKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChvYmopO1xuXG4gICAgICAgIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICAgIGNvbnN0IHVzZXJQYXNzID1cbiAgICAgICAgICAgIG9iai51c2VybmFtZSAmJiBvYmoucGFzc3dvcmQgP1xuICAgICAgICAgICAgICAgIGAke29iai51c2VybmFtZX06JHtvYmoucGFzc3dvcmR9QGAgOlxuICAgICAgICAgICAgICAgICcnO1xuICAgICAgICBjb25zdCBhdXRoID0gb2JqLmF1dGggPyBvYmouYXV0aCArICdAJyA6ICcnO1xuICAgICAgICBjb25zdCBwb3J0ID0gb2JqLnBvcnQgPyAnOicgKyBvYmoucG9ydCA6ICcnO1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IG9iai5wcm90b2NvbCA/IG9iai5wcm90b2NvbCArICcvLycgOiAnJztcbiAgICAgICAgY29uc3QgaG9zdCA9IG9iai5ob3N0IHx8ICcnO1xuICAgICAgICBjb25zdCBob3N0bmFtZSA9IG9iai5ob3N0bmFtZSB8fCAnJztcbiAgICAgICAgY29uc3Qgc2VhcmNoID0gb2JqLnNlYXJjaCB8fCAob2JqLnF1ZXJ5ID8gJz8nICsgb2JqLnF1ZXJ5IDogJycpO1xuICAgICAgICBjb25zdCBoYXNoID0gb2JqLmhhc2ggfHwgJyc7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gb2JqLnBhdGhuYW1lIHx8ICcnO1xuICAgICAgICBjb25zdCBwYXRoID0gb2JqLnBhdGggfHwgcGF0aG5hbWUgKyBzZWFyY2g7XG5cbiAgICAgICAgcmV0dXJuIGAke3Byb3RvY29sfSR7dXNlclBhc3MgfHwgYXV0aH0ke2hvc3QgfHxcbiAgICAgICAgICAgIGhvc3RuYW1lICsgcG9ydH0ke3BhdGh9JHtoYXNofWA7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBVUkxXaXRoTGVnYWN5U3VwcG9ydCxcbiAgICBVUkxTZWFyY2hQYXJhbXM6IHNlbGYuVVJMU2VhcmNoUGFyYW1zLFxuICAgIGRlZmF1bHRCYXNlLFxuICAgIGZvcm1hdFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/iso-url@0.4.7/node_modules/iso-url/src/url-browser.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/next@15.0.3_react-dom@19.0.0-rc-66855b96-20241106_react@19.0.0-rc-66855b96-20241106__react@19.0.0-rc-66855b96-20241106/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fmeow%2FICP-Hackathon-2024%2Fpages%2Ftest.tsx&page=%2Ftest!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.0.3_react-dom@19.0.0-rc-66855b96-20241106_react@19.0.0-rc-66855b96-20241106__react@19.0.0-rc-66855b96-20241106/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fmeow%2FICP-Hackathon-2024%2Fpages%2Ftest.tsx&page=%2Ftest! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/test\",\n      function () {\n        return __webpack_require__(/*! ./pages/test.tsx */ \"./pages/test.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/test\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4wLjNfcmVhY3QtZG9tQDE5LjAuMC1yYy02Njg1NWI5Ni0yMDI0MTEwNl9yZWFjdEAxOS4wLjAtcmMtNjY4NTViOTYtMjAyNDExMDZfX3JlYWN0QDE5LjAuMC1yYy02Njg1NWI5Ni0yMDI0MTEwNi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRm1lb3clMkZJQ1AtSGFja2F0aG9uLTIwMjQlMkZwYWdlcyUyRnRlc3QudHN4JnBhZ2U9JTJGdGVzdCEiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDekM7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvdGVzdFwiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vcGFnZXMvdGVzdC50c3hcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL3Rlc3RcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/next@15.0.3_react-dom@19.0.0-rc-66855b96-20241106_react@19.0.0-rc-66855b96-20241106__react@19.0.0-rc-66855b96-20241106/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fmeow%2FICP-Hackathon-2024%2Fpages%2Ftest.tsx&page=%2Ftest!\n"));

/***/ }),

/***/ "./declarations/backend/bank-sim-backend.did.js":
/*!******************************************************!*\
  !*** ./declarations/backend/bank-sim-backend.did.js ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   idlFactory: () => (/* binding */ idlFactory),\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\nconst idlFactory = (param)=>{\n    let { IDL } = param;\n    const Iden = IDL.Text;\n    const AccountData = IDL.Record({\n        'firstname': IDL.Text,\n        'balance': IDL.Float64,\n        'password': IDL.Text,\n        'isSuspended': IDL.Bool,\n        'lastname': IDL.Text\n    });\n    return IDL.Service({\n        'createAccount': IDL.Func([\n            IDL.Text,\n            IDL.Text,\n            IDL.Text,\n            IDL.Text\n        ], [\n            IDL.Vec(Iden)\n        ], []),\n        'getAccount': IDL.Func([\n            IDL.Text\n        ], [\n            AccountData\n        ], []),\n        'getAllData': IDL.Func([], [\n            IDL.Vec(AccountData)\n        ], [\n            'query'\n        ]),\n        'getAllIden': IDL.Func([], [\n            IDL.Vec(Iden)\n        ], [\n            'query'\n        ]),\n        'hashPassword': IDL.Func([\n            IDL.Text\n        ], [\n            IDL.Text\n        ], [\n            'query'\n        ]),\n        'replaceNullNat': IDL.Func([\n            IDL.Opt(IDL.Nat),\n            IDL.Nat\n        ], [\n            IDL.Nat\n        ], [\n            'query'\n        ]),\n        'validateLogin': IDL.Func([\n            IDL.Text,\n            IDL.Text\n        ], [\n            IDL.Bool\n        ], [])\n    });\n};\nconst init = (param)=>{\n    let { IDL } = param;\n    return [];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9kZWNsYXJhdGlvbnMvYmFja2VuZC9iYW5rLXNpbS1iYWNrZW5kLmRpZC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLE1BQU1BLGFBQWE7UUFBQyxFQUFFQyxHQUFHLEVBQUU7SUFDaEMsTUFBTUMsT0FBT0QsSUFBSUUsSUFBSTtJQUNyQixNQUFNQyxjQUFjSCxJQUFJSSxNQUFNLENBQUM7UUFDN0IsYUFBY0osSUFBSUUsSUFBSTtRQUN0QixXQUFZRixJQUFJSyxPQUFPO1FBQ3ZCLFlBQWFMLElBQUlFLElBQUk7UUFDckIsZUFBZ0JGLElBQUlNLElBQUk7UUFDeEIsWUFBYU4sSUFBSUUsSUFBSTtJQUN2QjtJQUNBLE9BQU9GLElBQUlPLE9BQU8sQ0FBQztRQUNqQixpQkFBa0JQLElBQUlRLElBQUksQ0FDdEI7WUFBQ1IsSUFBSUUsSUFBSTtZQUFFRixJQUFJRSxJQUFJO1lBQUVGLElBQUlFLElBQUk7WUFBRUYsSUFBSUUsSUFBSTtTQUFDLEVBQ3hDO1lBQUNGLElBQUlTLEdBQUcsQ0FBQ1I7U0FBTSxFQUNmLEVBQUU7UUFFTixjQUFlRCxJQUFJUSxJQUFJLENBQUM7WUFBQ1IsSUFBSUUsSUFBSTtTQUFDLEVBQUU7WUFBQ0M7U0FBWSxFQUFFLEVBQUU7UUFDckQsY0FBZUgsSUFBSVEsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUFDUixJQUFJUyxHQUFHLENBQUNOO1NBQWEsRUFBRTtZQUFDO1NBQVE7UUFDN0QsY0FBZUgsSUFBSVEsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUFDUixJQUFJUyxHQUFHLENBQUNSO1NBQU0sRUFBRTtZQUFDO1NBQVE7UUFDdEQsZ0JBQWlCRCxJQUFJUSxJQUFJLENBQUM7WUFBQ1IsSUFBSUUsSUFBSTtTQUFDLEVBQUU7WUFBQ0YsSUFBSUUsSUFBSTtTQUFDLEVBQUU7WUFBQztTQUFRO1FBQzNELGtCQUFtQkYsSUFBSVEsSUFBSSxDQUN2QjtZQUFDUixJQUFJVSxHQUFHLENBQUNWLElBQUlXLEdBQUc7WUFBR1gsSUFBSVcsR0FBRztTQUFDLEVBQzNCO1lBQUNYLElBQUlXLEdBQUc7U0FBQyxFQUNUO1lBQUM7U0FBUTtRQUViLGlCQUFrQlgsSUFBSVEsSUFBSSxDQUFDO1lBQUNSLElBQUlFLElBQUk7WUFBRUYsSUFBSUUsSUFBSTtTQUFDLEVBQUU7WUFBQ0YsSUFBSU0sSUFBSTtTQUFDLEVBQUUsRUFBRTtJQUNqRTtBQUNGLEVBQUU7QUFDSyxNQUFNTSxPQUFPO1FBQUMsRUFBRVosR0FBRyxFQUFFO0lBQU8sT0FBTyxFQUFFO0FBQUUsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L2RlY2xhcmF0aW9ucy9iYWNrZW5kL2Jhbmstc2ltLWJhY2tlbmQuZGlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBpZGxGYWN0b3J5ID0gKHsgSURMIH0pID0+IHtcbiAgY29uc3QgSWRlbiA9IElETC5UZXh0O1xuICBjb25zdCBBY2NvdW50RGF0YSA9IElETC5SZWNvcmQoe1xuICAgICdmaXJzdG5hbWUnIDogSURMLlRleHQsXG4gICAgJ2JhbGFuY2UnIDogSURMLkZsb2F0NjQsXG4gICAgJ3Bhc3N3b3JkJyA6IElETC5UZXh0LFxuICAgICdpc1N1c3BlbmRlZCcgOiBJREwuQm9vbCxcbiAgICAnbGFzdG5hbWUnIDogSURMLlRleHQsXG4gIH0pO1xuICByZXR1cm4gSURMLlNlcnZpY2Uoe1xuICAgICdjcmVhdGVBY2NvdW50JyA6IElETC5GdW5jKFxuICAgICAgICBbSURMLlRleHQsIElETC5UZXh0LCBJREwuVGV4dCwgSURMLlRleHRdLFxuICAgICAgICBbSURMLlZlYyhJZGVuKV0sXG4gICAgICAgIFtdLFxuICAgICAgKSxcbiAgICAnZ2V0QWNjb3VudCcgOiBJREwuRnVuYyhbSURMLlRleHRdLCBbQWNjb3VudERhdGFdLCBbXSksXG4gICAgJ2dldEFsbERhdGEnIDogSURMLkZ1bmMoW10sIFtJREwuVmVjKEFjY291bnREYXRhKV0sIFsncXVlcnknXSksXG4gICAgJ2dldEFsbElkZW4nIDogSURMLkZ1bmMoW10sIFtJREwuVmVjKElkZW4pXSwgWydxdWVyeSddKSxcbiAgICAnaGFzaFBhc3N3b3JkJyA6IElETC5GdW5jKFtJREwuVGV4dF0sIFtJREwuVGV4dF0sIFsncXVlcnknXSksXG4gICAgJ3JlcGxhY2VOdWxsTmF0JyA6IElETC5GdW5jKFxuICAgICAgICBbSURMLk9wdChJREwuTmF0KSwgSURMLk5hdF0sXG4gICAgICAgIFtJREwuTmF0XSxcbiAgICAgICAgWydxdWVyeSddLFxuICAgICAgKSxcbiAgICAndmFsaWRhdGVMb2dpbicgOiBJREwuRnVuYyhbSURMLlRleHQsIElETC5UZXh0XSwgW0lETC5Cb29sXSwgW10pLFxuICB9KTtcbn07XG5leHBvcnQgY29uc3QgaW5pdCA9ICh7IElETCB9KSA9PiB7IHJldHVybiBbXTsgfTtcbiJdLCJuYW1lcyI6WyJpZGxGYWN0b3J5IiwiSURMIiwiSWRlbiIsIlRleHQiLCJBY2NvdW50RGF0YSIsIlJlY29yZCIsIkZsb2F0NjQiLCJCb29sIiwiU2VydmljZSIsIkZ1bmMiLCJWZWMiLCJPcHQiLCJOYXQiLCJpbml0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./declarations/backend/bank-sim-backend.did.js\n"));

/***/ }),

/***/ "./declarations/backend/index.js":
/*!***************************************!*\
  !*** ./declarations/backend/index.js ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canisterId: () => (/* binding */ canisterId),\n/* harmony export */   createActor: () => (/* binding */ createActor),\n/* harmony export */   idlFactory: () => (/* reexport safe */ _bank_sim_backend_did_js__WEBPACK_IMPORTED_MODULE_1__.idlFactory)\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"./node_modules/.pnpm/@dfinity+agent@2.1.3_@dfinity+candid@2.1.3_@dfinity+principal@2.1.3__@dfinity+principal@2.1.3/node_modules/@dfinity/agent/lib/esm/index.js\");\n/* harmony import */ var _bank_sim_backend_did_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bank-sim-backend.did.js */ \"./declarations/backend/bank-sim-backend.did.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/.pnpm/next@15.0.3_react-dom@19.0.0-rc-66855b96-20241106_react@19.0.0-rc-66855b96-20241106__react@19.0.0-rc-66855b96-20241106/node_modules/next/dist/build/polyfills/process.js\");\n\n// Imports and re-exports candid interface\n\n\n/* CANISTER_ID is replaced by webpack based on node environment\n * Note: canister environment variable will be standardized as\n * process.env.CANISTER_ID_<CANISTER_NAME_UPPERCASE>\n * beginning in dfx 0.15.0\n */ const canisterId = process.env.CANISTER_ID_BANK_SIM_BACKEND;\nconst createActor = function(canisterId) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const agent = options.agent || new _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.HttpAgent({\n        ...options.agentOptions\n    });\n    if (options.agent && options.agentOptions) {\n        console.warn(\"Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.\");\n    }\n    // Fetch root key for certificate validation during development\n    if (process.env.DFX_NETWORK !== \"ic\") {\n        agent.fetchRootKey().catch((err)=>{\n            console.warn(\"Unable to fetch root key. Check to ensure that your local replica is running\");\n            console.error(err);\n        });\n    }\n    // Creates an actor with using the candid interface and the HttpAgent\n    return _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_bank_sim_backend_did_js__WEBPACK_IMPORTED_MODULE_1__.idlFactory, {\n        agent,\n        canisterId,\n        ...options.actorOptions\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9kZWNsYXJhdGlvbnMvYmFja2VuZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0Q7QUFFbEQsMENBQTBDO0FBQ2E7QUFDQTtBQUV2RDs7OztDQUlDLEdBQ00sTUFBTUcsYUFDWEMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyw0QkFBNEIsQ0FBQztBQUVwQyxNQUFNQyxjQUFjLFNBQUNKO1FBQVlLLDJFQUFVLENBQUM7SUFDakQsTUFBTUMsUUFBUUQsUUFBUUMsS0FBSyxJQUFJLElBQUlSLHFEQUFTQSxDQUFDO1FBQUUsR0FBR08sUUFBUUUsWUFBWTtJQUFDO0lBRXZFLElBQUlGLFFBQVFDLEtBQUssSUFBSUQsUUFBUUUsWUFBWSxFQUFFO1FBQ3pDQyxRQUFRQyxJQUFJLENBQ1Y7SUFFSjtJQUVBLCtEQUErRDtJQUMvRCxJQUFJUixPQUFPQSxDQUFDQyxHQUFHLENBQUNRLFdBQVcsS0FBSyxNQUFNO1FBQ3BDSixNQUFNSyxZQUFZLEdBQUdDLEtBQUssQ0FBQyxDQUFDQztZQUMxQkwsUUFBUUMsSUFBSSxDQUNWO1lBRUZELFFBQVFNLEtBQUssQ0FBQ0Q7UUFDaEI7SUFDRjtJQUVBLHFFQUFxRTtJQUNyRSxPQUFPaEIsaURBQUtBLENBQUNPLFdBQVcsQ0FBQ0wsZ0VBQVVBLEVBQUU7UUFDbkNPO1FBQ0FOO1FBQ0EsR0FBR0ssUUFBUVUsWUFBWTtJQUN6QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9kZWNsYXJhdGlvbnMvYmFja2VuZC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBY3RvciwgSHR0cEFnZW50IH0gZnJvbSBcIkBkZmluaXR5L2FnZW50XCI7XG5cbi8vIEltcG9ydHMgYW5kIHJlLWV4cG9ydHMgY2FuZGlkIGludGVyZmFjZVxuaW1wb3J0IHsgaWRsRmFjdG9yeSB9IGZyb20gXCIuL2Jhbmstc2ltLWJhY2tlbmQuZGlkLmpzXCI7XG5leHBvcnQgeyBpZGxGYWN0b3J5IH0gZnJvbSBcIi4vYmFuay1zaW0tYmFja2VuZC5kaWQuanNcIjtcblxuLyogQ0FOSVNURVJfSUQgaXMgcmVwbGFjZWQgYnkgd2VicGFjayBiYXNlZCBvbiBub2RlIGVudmlyb25tZW50XG4gKiBOb3RlOiBjYW5pc3RlciBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aWxsIGJlIHN0YW5kYXJkaXplZCBhc1xuICogcHJvY2Vzcy5lbnYuQ0FOSVNURVJfSURfPENBTklTVEVSX05BTUVfVVBQRVJDQVNFPlxuICogYmVnaW5uaW5nIGluIGRmeCAwLjE1LjBcbiAqL1xuZXhwb3J0IGNvbnN0IGNhbmlzdGVySWQgPVxuICBwcm9jZXNzLmVudi5DQU5JU1RFUl9JRF9CQU5LX1NJTV9CQUNLRU5EO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQWN0b3IgPSAoY2FuaXN0ZXJJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGFnZW50ID0gb3B0aW9ucy5hZ2VudCB8fCBuZXcgSHR0cEFnZW50KHsgLi4ub3B0aW9ucy5hZ2VudE9wdGlvbnMgfSk7XG5cbiAgaWYgKG9wdGlvbnMuYWdlbnQgJiYgb3B0aW9ucy5hZ2VudE9wdGlvbnMpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkRldGVjdGVkIGJvdGggYWdlbnQgYW5kIGFnZW50T3B0aW9ucyBwYXNzZWQgdG8gY3JlYXRlQWN0b3IuIElnbm9yaW5nIGFnZW50T3B0aW9ucyBhbmQgcHJvY2VlZGluZyB3aXRoIHRoZSBwcm92aWRlZCBhZ2VudC5cIlxuICAgICk7XG4gIH1cblxuICAvLyBGZXRjaCByb290IGtleSBmb3IgY2VydGlmaWNhdGUgdmFsaWRhdGlvbiBkdXJpbmcgZGV2ZWxvcG1lbnRcbiAgaWYgKHByb2Nlc3MuZW52LkRGWF9ORVRXT1JLICE9PSBcImljXCIpIHtcbiAgICBhZ2VudC5mZXRjaFJvb3RLZXkoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVW5hYmxlIHRvIGZldGNoIHJvb3Qga2V5LiBDaGVjayB0byBlbnN1cmUgdGhhdCB5b3VyIGxvY2FsIHJlcGxpY2EgaXMgcnVubmluZ1wiXG4gICAgICApO1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhbiBhY3RvciB3aXRoIHVzaW5nIHRoZSBjYW5kaWQgaW50ZXJmYWNlIGFuZCB0aGUgSHR0cEFnZW50XG4gIHJldHVybiBBY3Rvci5jcmVhdGVBY3RvcihpZGxGYWN0b3J5LCB7XG4gICAgYWdlbnQsXG4gICAgY2FuaXN0ZXJJZCxcbiAgICAuLi5vcHRpb25zLmFjdG9yT3B0aW9ucyxcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbIkFjdG9yIiwiSHR0cEFnZW50IiwiaWRsRmFjdG9yeSIsImNhbmlzdGVySWQiLCJwcm9jZXNzIiwiZW52IiwiQ0FOSVNURVJfSURfQkFOS19TSU1fQkFDS0VORCIsImNyZWF0ZUFjdG9yIiwib3B0aW9ucyIsImFnZW50IiwiYWdlbnRPcHRpb25zIiwiY29uc29sZSIsIndhcm4iLCJERlhfTkVUV09SSyIsImZldGNoUm9vdEtleSIsImNhdGNoIiwiZXJyIiwiZXJyb3IiLCJhY3Rvck9wdGlvbnMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./declarations/backend/index.js\n"));

/***/ }),

/***/ "./pages/test.tsx":
/*!************************!*\
  !*** ./pages/test.tsx ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ page)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/.pnpm/react@19.0.0-rc-66855b96-20241106/node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _declarations_backend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/declarations/backend */ \"./declarations/backend/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/.pnpm/react@19.0.0-rc-66855b96-20241106/node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$();\n\n\nfunction page() {\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"page.useEffect\": ()=>{\n            console.log(_declarations_backend__WEBPACK_IMPORTED_MODULE_1__.bank_sim_backend);\n        }\n    }[\"page.useEffect\"], [\n        _declarations_backend__WEBPACK_IMPORTED_MODULE_1__.bank_sim_backend\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: \"Hello, \".concat(_declarations_backend__WEBPACK_IMPORTED_MODULE_1__.bank_sim_backend)\n    }, void 0, false);\n} // export default function page() {\n // \treturn <></>;\n // }\n_s(page, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy90ZXN0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwRDtBQUN4QjtBQUNuQixTQUFTRTs7SUFDdkJELGdEQUFTQTswQkFBQztZQUNURSxRQUFRQyxHQUFHLENBQUNKLG1FQUFnQkE7UUFDN0I7eUJBQUc7UUFBQ0EsbUVBQWdCQTtLQUFDO0lBQ3JCLHFCQUFPO2tCQUFHLFVBQTJCLE9BQWpCQSxtRUFBZ0JBOztBQUNyQyxFQUVBLG1DQUFtQztDQUNuQyxpQkFBaUI7Q0FDakIsSUFBSTtHQVRvQkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9wYWdlcy90ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBiYW5rX3NpbV9iYWNrZW5kIH0gZnJvbSBcIkAvZGVjbGFyYXRpb25zL2JhY2tlbmRcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFnZSgpIHtcblx0dXNlRWZmZWN0KCgpID0+IHtcblx0XHRjb25zb2xlLmxvZyhiYW5rX3NpbV9iYWNrZW5kKTtcblx0fSwgW2Jhbmtfc2ltX2JhY2tlbmRdKTtcblx0cmV0dXJuIDw+e2BIZWxsbywgJHtiYW5rX3NpbV9iYWNrZW5kfWB9PC8+O1xufVxuXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYWdlKCkge1xuLy8gXHRyZXR1cm4gPD48Lz47XG4vLyB9XG4iXSwibmFtZXMiOlsiYmFua19zaW1fYmFja2VuZCIsInVzZUVmZmVjdCIsInBhZ2UiLCJjb25zb2xlIiwibG9nIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/test.tsx\n"));

/***/ }),

/***/ "./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/index.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__export(__webpack_require__(/*! ./serializer */ \"./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/serializer.js\"));\nconst value = __importStar(__webpack_require__(/*! ./value */ \"./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/value.js\"));\nexports.value = value;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc2ltcGxlLWNib3JAMC40LjEvbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFNBQVMsbUJBQU8sQ0FBQyx1R0FBYztBQUMvQiwyQkFBMkIsbUJBQU8sQ0FBQyw2RkFBUztBQUM1QyxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vc2ltcGxlLWNib3JAMC40LjEvbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zZXJpYWxpemVyXCIpKTtcbmNvbnN0IHZhbHVlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbHVlXCIpKTtcbmV4cG9ydHMudmFsdWUgPSB2YWx1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/serializer.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/serializer.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst cbor = __importStar(__webpack_require__(/*! ./value */ \"./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/value.js\"));\nconst BufferClasses = [\n    ArrayBuffer,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Float32Array,\n    Float64Array,\n];\nclass JsonDefaultCborEncoder {\n    // @param _serializer The CBOR Serializer to use.\n    // @param _stable Whether or not keys from objects should be sorted (stable). This is\n    //     particularly useful when testing encodings between JSON objects.\n    constructor(_serializer, _stable = false) {\n        this._serializer = _serializer;\n        this._stable = _stable;\n        this.name = \"jsonDefault\";\n        this.priority = -100;\n    }\n    match(value) {\n        return [\"undefined\", \"boolean\", \"number\", \"string\", \"object\"].indexOf(typeof value) != -1;\n    }\n    encode(value) {\n        switch (typeof value) {\n            case \"undefined\":\n                return cbor.undefined_();\n            case \"boolean\":\n                return cbor.bool(value);\n            case \"number\":\n                if (Math.floor(value) === value) {\n                    return cbor.number(value);\n                }\n                else {\n                    return cbor.doubleFloat(value);\n                }\n            case \"string\":\n                return cbor.string(value);\n            case \"object\":\n                if (value === null) {\n                    return cbor.null_();\n                }\n                else if (Array.isArray(value)) {\n                    return cbor.array(value.map((x) => this._serializer.serializeValue(x)));\n                }\n                else if (BufferClasses.find((x) => value instanceof x)) {\n                    return cbor.bytes(value.buffer);\n                }\n                else if (Object.getOwnPropertyNames(value).indexOf(\"toJSON\") !== -1) {\n                    return this.encode(value.toJSON());\n                }\n                else if (value instanceof Map) {\n                    const m = new Map();\n                    for (const [key, item] of value.entries()) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n                else {\n                    const m = new Map();\n                    for (const [key, item] of Object.entries(value)) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n            default:\n                throw new Error(\"Invalid value.\");\n        }\n    }\n}\nexports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;\nclass ToCborEncoder {\n    constructor() {\n        this.name = \"cborEncoder\";\n        this.priority = -90;\n    }\n    match(value) {\n        return typeof value == \"object\" && typeof value[\"toCBOR\"] == \"function\";\n    }\n    encode(value) {\n        return value.toCBOR();\n    }\n}\nexports.ToCborEncoder = ToCborEncoder;\nclass CborSerializer {\n    constructor() {\n        this._encoders = new Set();\n    }\n    static withDefaultEncoders(stable = false) {\n        const s = new this();\n        s.addEncoder(new JsonDefaultCborEncoder(s, stable));\n        s.addEncoder(new ToCborEncoder());\n        return s;\n    }\n    removeEncoder(name) {\n        // Has to make an extra call to values() to ensure it doesn't break on iteration.\n        for (const encoder of this._encoders.values()) {\n            if (encoder.name == name) {\n                this._encoders.delete(encoder);\n            }\n        }\n    }\n    addEncoder(encoder) {\n        this._encoders.add(encoder);\n    }\n    getEncoderFor(value) {\n        let chosenEncoder = null;\n        for (const encoder of this._encoders) {\n            if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {\n                if (encoder.match(value)) {\n                    chosenEncoder = encoder;\n                }\n            }\n        }\n        if (chosenEncoder === null) {\n            throw new Error(\"Could not find an encoder for value.\");\n        }\n        return chosenEncoder;\n    }\n    serializeValue(value) {\n        return this.getEncoderFor(value).encode(value);\n    }\n    serialize(value) {\n        return this.serializeValue(value);\n    }\n}\nexports.CborSerializer = CborSerializer;\nclass SelfDescribeCborSerializer extends CborSerializer {\n    serialize(value) {\n        return cbor.raw(new Uint8Array([\n            // Self describe CBOR.\n            ...new Uint8Array([0xd9, 0xd9, 0xf7]),\n            ...new Uint8Array(super.serializeValue(value)),\n        ]));\n    }\n}\nexports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;\n//# sourceMappingURL=serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc2ltcGxlLWNib3JAMC40LjEvbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsNkZBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9zaW1wbGUtY2JvckAwLjQuMS9ub2RlX21vZHVsZXMvc2ltcGxlLWNib3Ivc3JjL3NlcmlhbGl6ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjYm9yID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbHVlXCIpKTtcbmNvbnN0IEJ1ZmZlckNsYXNzZXMgPSBbXG4gICAgQXJyYXlCdWZmZXIsXG4gICAgVWludDhBcnJheSxcbiAgICBVaW50MTZBcnJheSxcbiAgICBVaW50MzJBcnJheSxcbiAgICBJbnQ4QXJyYXksXG4gICAgSW50MTZBcnJheSxcbiAgICBJbnQzMkFycmF5LFxuICAgIEZsb2F0MzJBcnJheSxcbiAgICBGbG9hdDY0QXJyYXksXG5dO1xuY2xhc3MgSnNvbkRlZmF1bHRDYm9yRW5jb2RlciB7XG4gICAgLy8gQHBhcmFtIF9zZXJpYWxpemVyIFRoZSBDQk9SIFNlcmlhbGl6ZXIgdG8gdXNlLlxuICAgIC8vIEBwYXJhbSBfc3RhYmxlIFdoZXRoZXIgb3Igbm90IGtleXMgZnJvbSBvYmplY3RzIHNob3VsZCBiZSBzb3J0ZWQgKHN0YWJsZSkuIFRoaXMgaXNcbiAgICAvLyAgICAgcGFydGljdWxhcmx5IHVzZWZ1bCB3aGVuIHRlc3RpbmcgZW5jb2RpbmdzIGJldHdlZW4gSlNPTiBvYmplY3RzLlxuICAgIGNvbnN0cnVjdG9yKF9zZXJpYWxpemVyLCBfc3RhYmxlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fc2VyaWFsaXplciA9IF9zZXJpYWxpemVyO1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBfc3RhYmxlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcImpzb25EZWZhdWx0XCI7XG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAtMTAwO1xuICAgIH1cbiAgICBtYXRjaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW1widW5kZWZpbmVkXCIsIFwiYm9vbGVhblwiLCBcIm51bWJlclwiLCBcInN0cmluZ1wiLCBcIm9iamVjdFwiXS5pbmRleE9mKHR5cGVvZiB2YWx1ZSkgIT0gLTE7XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLnVuZGVmaW5lZF8oKTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNib3IuYm9vbCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5udW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IuZG91YmxlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5zdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5udWxsXygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5hcnJheSh2YWx1ZS5tYXAoKHgpID0+IHRoaXMuX3NlcmlhbGl6ZXIuc2VyaWFsaXplVmFsdWUoeCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQnVmZmVyQ2xhc3Nlcy5maW5kKCh4KSA9PiB2YWx1ZSBpbnN0YW5jZW9mIHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLmJ5dGVzKHZhbHVlLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5pbmRleE9mKFwidG9KU09OXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUodmFsdWUudG9KU09OKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGl0ZW1dIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5zZXQoa2V5LCB0aGlzLl9zZXJpYWxpemVyLnNlcmlhbGl6ZVZhbHVlKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5tYXAobSwgdGhpcy5fc3RhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNldChrZXksIHRoaXMuX3NlcmlhbGl6ZXIuc2VyaWFsaXplVmFsdWUoaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLm1hcChtLCB0aGlzLl9zdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkpzb25EZWZhdWx0Q2JvckVuY29kZXIgPSBKc29uRGVmYXVsdENib3JFbmNvZGVyO1xuY2xhc3MgVG9DYm9yRW5jb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiY2JvckVuY29kZXJcIjtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC05MDtcbiAgICB9XG4gICAgbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZVtcInRvQ0JPUlwiXSA9PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9DQk9SKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub0Nib3JFbmNvZGVyID0gVG9DYm9yRW5jb2RlcjtcbmNsYXNzIENib3JTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZW5jb2RlcnMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHN0YXRpYyB3aXRoRGVmYXVsdEVuY29kZXJzKHN0YWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHMgPSBuZXcgdGhpcygpO1xuICAgICAgICBzLmFkZEVuY29kZXIobmV3IEpzb25EZWZhdWx0Q2JvckVuY29kZXIocywgc3RhYmxlKSk7XG4gICAgICAgIHMuYWRkRW5jb2RlcihuZXcgVG9DYm9yRW5jb2RlcigpKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHJlbW92ZUVuY29kZXIobmFtZSkge1xuICAgICAgICAvLyBIYXMgdG8gbWFrZSBhbiBleHRyYSBjYWxsIHRvIHZhbHVlcygpIHRvIGVuc3VyZSBpdCBkb2Vzbid0IGJyZWFrIG9uIGl0ZXJhdGlvbi5cbiAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIHRoaXMuX2VuY29kZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlci5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVycy5kZWxldGUoZW5jb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRW5jb2RlcihlbmNvZGVyKSB7XG4gICAgICAgIHRoaXMuX2VuY29kZXJzLmFkZChlbmNvZGVyKTtcbiAgICB9XG4gICAgZ2V0RW5jb2RlckZvcih2YWx1ZSkge1xuICAgICAgICBsZXQgY2hvc2VuRW5jb2RlciA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgZW5jb2RlciBvZiB0aGlzLl9lbmNvZGVycykge1xuICAgICAgICAgICAgaWYgKCFjaG9zZW5FbmNvZGVyIHx8IGVuY29kZXIucHJpb3JpdHkgPiBjaG9zZW5FbmNvZGVyLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIubWF0Y2godmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNob3NlbkVuY29kZXIgPSBlbmNvZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvc2VuRW5jb2RlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYW4gZW5jb2RlciBmb3IgdmFsdWUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaG9zZW5FbmNvZGVyO1xuICAgIH1cbiAgICBzZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVyRm9yKHZhbHVlKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2JvclNlcmlhbGl6ZXIgPSBDYm9yU2VyaWFsaXplcjtcbmNsYXNzIFNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyIGV4dGVuZHMgQ2JvclNlcmlhbGl6ZXIge1xuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Jvci5yYXcobmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgLy8gU2VsZiBkZXNjcmliZSBDQk9SLlxuICAgICAgICAgICAgLi4ubmV3IFVpbnQ4QXJyYXkoWzB4ZDksIDB4ZDksIDB4ZjddKSxcbiAgICAgICAgICAgIC4uLm5ldyBVaW50OEFycmF5KHN1cGVyLnNlcmlhbGl6ZVZhbHVlKHZhbHVlKSksXG4gICAgICAgIF0pKTtcbiAgICB9XG59XG5leHBvcnRzLlNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyID0gU2VsZkRlc2NyaWJlQ2JvclNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/serializer.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/value.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/value.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst MAX_U64_NUMBER = 0x20000000000000;\nfunction _concat(a, ...args) {\n    const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));\n    newBuffer.set(new Uint8Array(a), 0);\n    let i = a.byteLength;\n    for (const b of args) {\n        newBuffer.set(new Uint8Array(b), i);\n        i += b.byteLength;\n    }\n    return newBuffer.buffer;\n}\nfunction _serializeValue(major, minor, value) {\n    // Remove everything that's not an hexadecimal character. These are not\n    // considered errors since the value was already validated and they might\n    // be number decimals or sign.\n    value = value.replace(/[^0-9a-fA-F]/g, \"\");\n    // Create the buffer from the value with left padding with 0.\n    const length = 2 ** (minor - 24 /* Int8 */);\n    value = value.slice(-length * 2).padStart(length * 2, \"0\");\n    const bytes = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n    return new Uint8Array(bytes).buffer;\n}\nfunction _serializeNumber(major, value) {\n    if (value < 24) {\n        return new Uint8Array([(major << 5) + value]).buffer;\n    }\n    else {\n        const minor = value <= 0xff\n            ? 24 /* Int8 */\n            : value <= 0xffff\n                ? 25 /* Int16 */\n                : value <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        return _serializeValue(major, minor, value.toString(16));\n    }\n}\nfunction _serializeString(str) {\n    const utf8 = [];\n    for (let i = 0; i < str.length; i++) {\n        let charcode = str.charCodeAt(i);\n        if (charcode < 0x80) {\n            utf8.push(charcode);\n        }\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n        else {\n            // Surrogate pair\n            i++;\n            charcode = ((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff);\n            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n    }\n    return _concat(new Uint8Array(_serializeNumber(3 /* TextString */, str.length)), new Uint8Array(utf8));\n}\n/**\n * Tag a value.\n */\nfunction tagged(tag, value) {\n    if (tag == 0xd9d9f7) {\n        return _concat(new Uint8Array([0xd9, 0xd9, 0xf7]), value);\n    }\n    if (tag < 24) {\n        return _concat(new Uint8Array([(6 /* Tag */ << 5) + tag]), value);\n    }\n    else {\n        const minor = tag <= 0xff\n            ? 24 /* Int8 */\n            : tag <= 0xffff\n                ? 25 /* Int16 */\n                : tag <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        const length = 2 ** (minor - 24 /* Int8 */);\n        const value = tag\n            .toString(16)\n            .slice(-length * 2)\n            .padStart(length * 2, \"0\");\n        const bytes = [(6 /* Tag */ << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n        return new Uint8Array(bytes).buffer;\n    }\n}\nexports.tagged = tagged;\n/**\n * Set the raw bytes contained by this value. This should only be used with another\n * CborValue, or if you are implementing extensions to CBOR.\n * @param bytes A buffer containing the value.\n */\nfunction raw(bytes) {\n    return new Uint8Array(bytes).buffer;\n}\nexports.raw = raw;\n/**\n * Encode a number that is between [0, 23].\n * @param n\n */\nfunction uSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    n = Math.min(Math.max(0, n), 23); // Clamp it.\n    const bytes = [(0 /* UnsignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.uSmall = uSmall;\nfunction u8(u8, radix) {\n    // Force u8 into a number, and validate it.\n    u8 = parseInt(\"\" + u8, radix);\n    if (isNaN(u8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u8 = Math.min(Math.max(0, u8), 0xff); // Clamp it.\n    u8 = u8.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 24 /* Int8 */, u8);\n}\nexports.u8 = u8;\nfunction u16(u16, radix) {\n    // Force u16 into a number, and validate it.\n    u16 = parseInt(\"\" + u16, radix);\n    if (isNaN(u16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u16 = Math.min(Math.max(0, u16), 0xffff); // Clamp it.\n    u16 = u16.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 25 /* Int16 */, u16);\n}\nexports.u16 = u16;\nfunction u32(u32, radix) {\n    // Force u32 into a number, and validate it.\n    u32 = parseInt(\"\" + u32, radix);\n    if (isNaN(u32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u32 = Math.min(Math.max(0, u32), 0xffffffff); // Clamp it.\n    u32 = u32.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 26 /* Int32 */, u32);\n}\nexports.u32 = u32;\nfunction u64(u64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof u64 == \"string\" && radix == 16) {\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (u64.match(/[^0-9a-fA-F]/)) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n    }\n    // Force u64 into a number, and validate it.\n    u64 = parseInt(\"\" + u64, radix);\n    if (isNaN(u64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u64 = Math.min(Math.max(0, u64), MAX_U64_NUMBER); // Clamp it to actual limit.\n    u64 = u64.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n}\nexports.u64 = u64;\n/**\n * Encode a negative number that is between [-24, -1].\n */\nfunction iSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    if (n === 0) {\n        return uSmall(0);\n    }\n    // Negative n, clamped to [1, 24], minus 1 (there's no negative 0).\n    n = Math.min(Math.max(0, -n), 24) - 1;\n    const bytes = [(1 /* SignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.iSmall = iSmall;\nfunction i8(i8, radix) {\n    // Force i8 into a number, and validate it.\n    i8 = parseInt(\"\" + i8, radix);\n    if (isNaN(i8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i8 = Math.min(Math.max(0, -i8 - 1), 0xff);\n    i8 = i8.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 24 /* Int8 */, i8);\n}\nexports.i8 = i8;\nfunction i16(i16, radix) {\n    // Force i16 into a number, and validate it.\n    i16 = parseInt(\"\" + i16, radix);\n    if (isNaN(i16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i16 = Math.min(Math.max(0, -i16 - 1), 0xffff);\n    i16 = i16.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 25 /* Int16 */, i16);\n}\nexports.i16 = i16;\nfunction i32(i32, radix) {\n    // Force i32 into a number, and validate it.\n    i32 = parseInt(\"\" + i32, radix);\n    if (isNaN(i32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i32 = Math.min(Math.max(0, -i32 - 1), 0xffffffff);\n    i32 = i32.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 26 /* Int32 */, i32);\n}\nexports.i32 = i32;\nfunction i64(i64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof i64 == \"string\" && radix == 16) {\n        if (i64.startsWith(\"-\")) {\n            i64 = i64.slice(1);\n        }\n        else {\n            // Clamp it.\n            i64 = \"0\";\n        }\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (i64.match(/[^0-9a-fA-F]/) || i64.length > 16) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        // We need to do -1 to the number.\n        let done = false;\n        let newI64 = i64.split(\"\").reduceRight((acc, x) => {\n            if (done) {\n                return x + acc;\n            }\n            let n = parseInt(x, 16) - 1;\n            if (n >= 0) {\n                done = true;\n                return n.toString(16) + acc;\n            }\n            else {\n                return \"f\" + acc;\n            }\n        }, \"\");\n        if (!done) {\n            // This number was 0.\n            return u64(0);\n        }\n        return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, newI64);\n    }\n    // Force i64 into a number, and validate it.\n    i64 = parseInt(\"\" + i64, radix);\n    if (isNaN(i64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    i64 = Math.min(Math.max(0, -i64 - 1), 0x20000000000000); // Clamp it to actual.\n    i64 = i64.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, i64);\n}\nexports.i64 = i64;\n/**\n * Encode a number using the smallest amount of bytes, by calling the methods\n * above. e.g. If the number fits in a u8, it will use that.\n */\nfunction number(n) {\n    if (n >= 0) {\n        if (n < 24) {\n            return uSmall(n);\n        }\n        else if (n <= 0xff) {\n            return u8(n);\n        }\n        else if (n <= 0xffff) {\n            return u16(n);\n        }\n        else if (n <= 0xffffffff) {\n            return u32(n);\n        }\n        else {\n            return u64(n);\n        }\n    }\n    else {\n        if (n >= -24) {\n            return iSmall(n);\n        }\n        else if (n >= -0xff) {\n            return i8(n);\n        }\n        else if (n >= -0xffff) {\n            return i16(n);\n        }\n        else if (n >= -0xffffffff) {\n            return i32(n);\n        }\n        else {\n            return i64(n);\n        }\n    }\n}\nexports.number = number;\n/**\n * Encode a byte array. This is different than the `raw()` method.\n */\nfunction bytes(bytes) {\n    return _concat(_serializeNumber(2 /* ByteString */, bytes.byteLength), bytes);\n}\nexports.bytes = bytes;\n/**\n * Encode a JavaScript string.\n */\nfunction string(str) {\n    return _serializeString(str);\n}\nexports.string = string;\n/**\n * Encode an array of cbor values.\n */\nfunction array(items) {\n    return _concat(_serializeNumber(4 /* Array */, items.length), ...items);\n}\nexports.array = array;\n/**\n * Encode a map of key-value pairs. The keys are string, and the values are CBOR\n * encoded.\n */\nfunction map(items, stable = false) {\n    if (!(items instanceof Map)) {\n        items = new Map(Object.entries(items));\n    }\n    let entries = Array.from(items.entries());\n    if (stable) {\n        entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n    }\n    return _concat(_serializeNumber(5 /* Map */, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));\n}\nexports.map = map;\n/**\n * Encode a single (32 bits) precision floating point number.\n */\nfunction singleFloat(f) {\n    const single = new Float32Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 26]), new Uint8Array(single.buffer));\n}\nexports.singleFloat = singleFloat;\n/**\n * Encode a double (64 bits) precision floating point number.\n */\nfunction doubleFloat(f) {\n    const single = new Float64Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 27]), new Uint8Array(single.buffer));\n}\nexports.doubleFloat = doubleFloat;\nfunction bool(v) {\n    return v ? true_() : false_();\n}\nexports.bool = bool;\n/**\n * Encode the boolean true.\n */\nfunction true_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 21]));\n}\nexports.true_ = true_;\n/**\n * Encode the boolean false.\n */\nfunction false_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 20]));\n}\nexports.false_ = false_;\n/**\n * Encode the constant null.\n */\nfunction null_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 22]));\n}\nexports.null_ = null_;\n/**\n * Encode the constant undefined.\n */\nfunction undefined_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 23]));\n}\nexports.undefined_ = undefined_;\n//# sourceMappingURL=value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc2ltcGxlLWNib3JAMC40LjEvbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy92YWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vc2ltcGxlLWNib3JAMC40LjEvbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy92YWx1ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1BWF9VNjRfTlVNQkVSID0gMHgyMDAwMDAwMDAwMDAwMDtcbmZ1bmN0aW9uIF9jb25jYXQoYSwgLi4uYXJncykge1xuICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGEuYnl0ZUxlbmd0aCArIGFyZ3MucmVkdWNlKChhY2MsIGIpID0+IGFjYyArIGIuYnl0ZUxlbmd0aCwgMCkpO1xuICAgIG5ld0J1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYSksIDApO1xuICAgIGxldCBpID0gYS5ieXRlTGVuZ3RoO1xuICAgIGZvciAoY29uc3QgYiBvZiBhcmdzKSB7XG4gICAgICAgIG5ld0J1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYiksIGkpO1xuICAgICAgICBpICs9IGIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZmZlci5idWZmZXI7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplVmFsdWUobWFqb3IsIG1pbm9yLCB2YWx1ZSkge1xuICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIHRoYXQncyBub3QgYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLiBUaGVzZSBhcmUgbm90XG4gICAgLy8gY29uc2lkZXJlZCBlcnJvcnMgc2luY2UgdGhlIHZhbHVlIHdhcyBhbHJlYWR5IHZhbGlkYXRlZCBhbmQgdGhleSBtaWdodFxuICAgIC8vIGJlIG51bWJlciBkZWNpbWFscyBvciBzaWduLlxuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW14wLTlhLWZBLUZdL2csIFwiXCIpO1xuICAgIC8vIENyZWF0ZSB0aGUgYnVmZmVyIGZyb20gdGhlIHZhbHVlIHdpdGggbGVmdCBwYWRkaW5nIHdpdGggMC5cbiAgICBjb25zdCBsZW5ndGggPSAyICoqIChtaW5vciAtIDI0IC8qIEludDggKi8pO1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoLWxlbmd0aCAqIDIpLnBhZFN0YXJ0KGxlbmd0aCAqIDIsIFwiMFwiKTtcbiAgICBjb25zdCBieXRlcyA9IFsobWFqb3IgPDwgNSkgKyBtaW5vcl0uY29uY2F0KHZhbHVlLm1hdGNoKC8uLi9nKS5tYXAoKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyO1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZU51bWJlcihtYWpvciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAyNCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWyhtYWpvciA8PCA1KSArIHZhbHVlXSkuYnVmZmVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlub3IgPSB2YWx1ZSA8PSAweGZmXG4gICAgICAgICAgICA/IDI0IC8qIEludDggKi9cbiAgICAgICAgICAgIDogdmFsdWUgPD0gMHhmZmZmXG4gICAgICAgICAgICAgICAgPyAyNSAvKiBJbnQxNiAqL1xuICAgICAgICAgICAgICAgIDogdmFsdWUgPD0gMHhmZmZmZmZmZlxuICAgICAgICAgICAgICAgICAgICA/IDI2IC8qIEludDMyICovXG4gICAgICAgICAgICAgICAgICAgIDogMjcgLyogSW50NjQgKi87XG4gICAgICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUobWFqb3IsIG1pbm9yLCB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgdXRmOCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGFyY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhcmNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goY2hhcmNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaCgweGMwIHwgKGNoYXJjb2RlID4+IDYpLCAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKDB4ZTAgfCAoY2hhcmNvZGUgPj4gMTIpLCAweDgwIHwgKChjaGFyY29kZSA+PiA2KSAmIDB4M2YpLCAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNoYXJjb2RlID0gKChjaGFyY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZik7XG4gICAgICAgICAgICB1dGY4LnB1c2goMHhmMCB8IChjaGFyY29kZSA+PiAxOCksIDB4ODAgfCAoKGNoYXJjb2RlID4+IDEyKSAmIDB4M2YpLCAweDgwIHwgKChjaGFyY29kZSA+PiA2KSAmIDB4M2YpLCAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KF9zZXJpYWxpemVOdW1iZXIoMyAvKiBUZXh0U3RyaW5nICovLCBzdHIubGVuZ3RoKSksIG5ldyBVaW50OEFycmF5KHV0ZjgpKTtcbn1cbi8qKlxuICogVGFnIGEgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHRhZ2dlZCh0YWcsIHZhbHVlKSB7XG4gICAgaWYgKHRhZyA9PSAweGQ5ZDlmNykge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChuZXcgVWludDhBcnJheShbMHhkOSwgMHhkOSwgMHhmN10pLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0YWcgPCAyNCkge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChuZXcgVWludDhBcnJheShbKDYgLyogVGFnICovIDw8IDUpICsgdGFnXSksIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pbm9yID0gdGFnIDw9IDB4ZmZcbiAgICAgICAgICAgID8gMjQgLyogSW50OCAqL1xuICAgICAgICAgICAgOiB0YWcgPD0gMHhmZmZmXG4gICAgICAgICAgICAgICAgPyAyNSAvKiBJbnQxNiAqL1xuICAgICAgICAgICAgICAgIDogdGFnIDw9IDB4ZmZmZmZmZmZcbiAgICAgICAgICAgICAgICAgICAgPyAyNiAvKiBJbnQzMiAqL1xuICAgICAgICAgICAgICAgICAgICA6IDI3IC8qIEludDY0ICovO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAyICoqIChtaW5vciAtIDI0IC8qIEludDggKi8pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRhZ1xuICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgLnNsaWNlKC1sZW5ndGggKiAyKVxuICAgICAgICAgICAgLnBhZFN0YXJ0KGxlbmd0aCAqIDIsIFwiMFwiKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBbKDYgLyogVGFnICovIDw8IDUpICsgbWlub3JdLmNvbmNhdCh2YWx1ZS5tYXRjaCgvLi4vZykubWFwKChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG4gICAgfVxufVxuZXhwb3J0cy50YWdnZWQgPSB0YWdnZWQ7XG4vKipcbiAqIFNldCB0aGUgcmF3IGJ5dGVzIGNvbnRhaW5lZCBieSB0aGlzIHZhbHVlLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgd2l0aCBhbm90aGVyXG4gKiBDYm9yVmFsdWUsIG9yIGlmIHlvdSBhcmUgaW1wbGVtZW50aW5nIGV4dGVuc2lvbnMgdG8gQ0JPUi5cbiAqIEBwYXJhbSBieXRlcyBBIGJ1ZmZlciBjb250YWluaW5nIHRoZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcmF3KGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG59XG5leHBvcnRzLnJhdyA9IHJhdztcbi8qKlxuICogRW5jb2RlIGEgbnVtYmVyIHRoYXQgaXMgYmV0d2VlbiBbMCwgMjNdLlxuICogQHBhcmFtIG5cbiAqL1xuZnVuY3Rpb24gdVNtYWxsKG4pIHtcbiAgICBpZiAoaXNOYU4obikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIG4gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBuKSwgMjMpOyAvLyBDbGFtcCBpdC5cbiAgICBjb25zdCBieXRlcyA9IFsoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8gPDwgNSkgKyBuXTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlcjtcbn1cbmV4cG9ydHMudVNtYWxsID0gdVNtYWxsO1xuZnVuY3Rpb24gdTgodTgsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgdTggaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIHU4ID0gcGFyc2VJbnQoXCJcIiArIHU4LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKHU4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgdTggPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1OCksIDB4ZmYpOyAvLyBDbGFtcCBpdC5cbiAgICB1OCA9IHU4LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDAgLyogVW5zaWduZWRJbnRlZ2VyICovLCAyNCAvKiBJbnQ4ICovLCB1OCk7XG59XG5leHBvcnRzLnU4ID0gdTg7XG5mdW5jdGlvbiB1MTYodTE2LCByYWRpeCkge1xuICAgIC8vIEZvcmNlIHUxNiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTE2ID0gcGFyc2VJbnQoXCJcIiArIHUxNiwgcmFkaXgpO1xuICAgIGlmIChpc05hTih1MTYpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1MTYgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1MTYpLCAweGZmZmYpOyAvLyBDbGFtcCBpdC5cbiAgICB1MTYgPSB1MTYudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI1IC8qIEludDE2ICovLCB1MTYpO1xufVxuZXhwb3J0cy51MTYgPSB1MTY7XG5mdW5jdGlvbiB1MzIodTMyLCByYWRpeCkge1xuICAgIC8vIEZvcmNlIHUzMiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTMyID0gcGFyc2VJbnQoXCJcIiArIHUzMiwgcmFkaXgpO1xuICAgIGlmIChpc05hTih1MzIpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1MzIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1MzIpLCAweGZmZmZmZmZmKTsgLy8gQ2xhbXAgaXQuXG4gICAgdTMyID0gdTMyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDAgLyogVW5zaWduZWRJbnRlZ2VyICovLCAyNiAvKiBJbnQzMiAqLywgdTMyKTtcbn1cbmV4cG9ydHMudTMyID0gdTMyO1xuZnVuY3Rpb24gdTY0KHU2NCwgcmFkaXgpIHtcbiAgICAvLyBTcGVjaWFsIGNvbnNpZGVyYXRpb24gZm9yIG51bWJlcnMgdGhhdCBtaWdodCBiZSBsYXJnZXIgdGhhbiBleHBlY3RlZC5cbiAgICBpZiAodHlwZW9mIHU2NCA9PSBcInN0cmluZ1wiICYmIHJhZGl4ID09IDE2KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgY2FzZSB3aGVyZSB3ZSBndWFyYW50ZWUgd2UnbGwgZW5jb2RlIHRoZSBudW1iZXIgZGlyZWN0bHkuXG4gICAgICAgIC8vIFZhbGlkYXRlIGl0J3MgYWxsIGhleGFkZWNpbWFsIGZpcnN0LlxuICAgICAgICBpZiAodTY0Lm1hdGNoKC9bXjAtOWEtZkEtRl0vKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgwIC8qIFVuc2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIHU2NCk7XG4gICAgfVxuICAgIC8vIEZvcmNlIHU2NCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTY0ID0gcGFyc2VJbnQoXCJcIiArIHU2NCwgcmFkaXgpO1xuICAgIGlmIChpc05hTih1NjQpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1NjQgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1NjQpLCBNQVhfVTY0X05VTUJFUik7IC8vIENsYW1wIGl0IHRvIGFjdHVhbCBsaW1pdC5cbiAgICB1NjQgPSB1NjQudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI3IC8qIEludDY0ICovLCB1NjQpO1xufVxuZXhwb3J0cy51NjQgPSB1NjQ7XG4vKipcbiAqIEVuY29kZSBhIG5lZ2F0aXZlIG51bWJlciB0aGF0IGlzIGJldHdlZW4gWy0yNCwgLTFdLlxuICovXG5mdW5jdGlvbiBpU21hbGwobikge1xuICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVTbWFsbCgwKTtcbiAgICB9XG4gICAgLy8gTmVnYXRpdmUgbiwgY2xhbXBlZCB0byBbMSwgMjRdLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIG4gPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtbiksIDI0KSAtIDE7XG4gICAgY29uc3QgYnl0ZXMgPSBbKDEgLyogU2lnbmVkSW50ZWdlciAqLyA8PCA1KSArIG5dO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyO1xufVxuZXhwb3J0cy5pU21hbGwgPSBpU21hbGw7XG5mdW5jdGlvbiBpOChpOCwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSBpOCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTggPSBwYXJzZUludChcIlwiICsgaTgsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4oaTgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSBuLCBjbGFtcGVkLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIGk4ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgLWk4IC0gMSksIDB4ZmYpO1xuICAgIGk4ID0gaTgudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNCAvKiBJbnQ4ICovLCBpOCk7XG59XG5leHBvcnRzLmk4ID0gaTg7XG5mdW5jdGlvbiBpMTYoaTE2LCByYWRpeCkge1xuICAgIC8vIEZvcmNlIGkxNiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTE2ID0gcGFyc2VJbnQoXCJcIiArIGkxNiwgcmFkaXgpO1xuICAgIGlmIChpc05hTihpMTYpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSBuLCBjbGFtcGVkLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIGkxNiA9IE1hdGgubWluKE1hdGgubWF4KDAsIC1pMTYgLSAxKSwgMHhmZmZmKTtcbiAgICBpMTYgPSBpMTYudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNSAvKiBJbnQxNiAqLywgaTE2KTtcbn1cbmV4cG9ydHMuaTE2ID0gaTE2O1xuZnVuY3Rpb24gaTMyKGkzMiwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSBpMzIgaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIGkzMiA9IHBhcnNlSW50KFwiXCIgKyBpMzIsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4oaTMyKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgLy8gTmVnYXRpdmUgbiwgY2xhbXBlZCwgbWludXMgMSAodGhlcmUncyBubyBuZWdhdGl2ZSAwKS5cbiAgICBpMzIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtaTMyIC0gMSksIDB4ZmZmZmZmZmYpO1xuICAgIGkzMiA9IGkzMi50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgxIC8qIFNpZ25lZEludGVnZXIgKi8sIDI2IC8qIEludDMyICovLCBpMzIpO1xufVxuZXhwb3J0cy5pMzIgPSBpMzI7XG5mdW5jdGlvbiBpNjQoaTY0LCByYWRpeCkge1xuICAgIC8vIFNwZWNpYWwgY29uc2lkZXJhdGlvbiBmb3IgbnVtYmVycyB0aGF0IG1pZ2h0IGJlIGxhcmdlciB0aGFuIGV4cGVjdGVkLlxuICAgIGlmICh0eXBlb2YgaTY0ID09IFwic3RyaW5nXCIgJiYgcmFkaXggPT0gMTYpIHtcbiAgICAgICAgaWYgKGk2NC5zdGFydHNXaXRoKFwiLVwiKSkge1xuICAgICAgICAgICAgaTY0ID0gaTY0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2xhbXAgaXQuXG4gICAgICAgICAgICBpNjQgPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgZ3VhcmFudGVlIHdlJ2xsIGVuY29kZSB0aGUgbnVtYmVyIGRpcmVjdGx5LlxuICAgICAgICAvLyBWYWxpZGF0ZSBpdCdzIGFsbCBoZXhhZGVjaW1hbCBmaXJzdC5cbiAgICAgICAgaWYgKGk2NC5tYXRjaCgvW14wLTlhLWZBLUZdLykgfHwgaTY0Lmxlbmd0aCA+IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIC0xIHRvIHRoZSBudW1iZXIuXG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGxldCBuZXdJNjQgPSBpNjQuc3BsaXQoXCJcIikucmVkdWNlUmlnaHQoKGFjYywgeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geCArIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuID0gcGFyc2VJbnQoeCwgMTYpIC0gMTtcbiAgICAgICAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi50b1N0cmluZygxNikgKyBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmXCIgKyBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFwiXCIpO1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbnVtYmVyIHdhcyAwLlxuICAgICAgICAgICAgcmV0dXJuIHU2NCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDEgLyogU2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIG5ld0k2NCk7XG4gICAgfVxuICAgIC8vIEZvcmNlIGk2NCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTY0ID0gcGFyc2VJbnQoXCJcIiArIGk2NCwgcmFkaXgpO1xuICAgIGlmIChpc05hTihpNjQpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICBpNjQgPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtaTY0IC0gMSksIDB4MjAwMDAwMDAwMDAwMDApOyAvLyBDbGFtcCBpdCB0byBhY3R1YWwuXG4gICAgaTY0ID0gaTY0LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDEgLyogU2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIGk2NCk7XG59XG5leHBvcnRzLmk2NCA9IGk2NDtcbi8qKlxuICogRW5jb2RlIGEgbnVtYmVyIHVzaW5nIHRoZSBzbWFsbGVzdCBhbW91bnQgb2YgYnl0ZXMsIGJ5IGNhbGxpbmcgdGhlIG1ldGhvZHNcbiAqIGFib3ZlLiBlLmcuIElmIHRoZSBudW1iZXIgZml0cyBpbiBhIHU4LCBpdCB3aWxsIHVzZSB0aGF0LlxuICovXG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmIChuID49IDApIHtcbiAgICAgICAgaWYgKG4gPCAyNCkge1xuICAgICAgICAgICAgcmV0dXJuIHVTbWFsbChuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDB4ZmYpIHtcbiAgICAgICAgICAgIHJldHVybiB1OChuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIHUxNihuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiB1MzIobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdTY0KG4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobiA+PSAtMjQpIHtcbiAgICAgICAgICAgIHJldHVybiBpU21hbGwobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA+PSAtMHhmZikge1xuICAgICAgICAgICAgcmV0dXJuIGk4KG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPj0gLTB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIGkxNihuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuID49IC0weGZmZmZmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gaTMyKG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGk2NChuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuLyoqXG4gKiBFbmNvZGUgYSBieXRlIGFycmF5LiBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBgcmF3KClgIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXMoYnl0ZXMpIHtcbiAgICByZXR1cm4gX2NvbmNhdChfc2VyaWFsaXplTnVtYmVyKDIgLyogQnl0ZVN0cmluZyAqLywgYnl0ZXMuYnl0ZUxlbmd0aCksIGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXMgPSBieXRlcztcbi8qKlxuICogRW5jb2RlIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVN0cmluZyhzdHIpO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vKipcbiAqIEVuY29kZSBhbiBhcnJheSBvZiBjYm9yIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXkoaXRlbXMpIHtcbiAgICByZXR1cm4gX2NvbmNhdChfc2VyaWFsaXplTnVtYmVyKDQgLyogQXJyYXkgKi8sIGl0ZW1zLmxlbmd0aCksIC4uLml0ZW1zKTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbi8qKlxuICogRW5jb2RlIGEgbWFwIG9mIGtleS12YWx1ZSBwYWlycy4gVGhlIGtleXMgYXJlIHN0cmluZywgYW5kIHRoZSB2YWx1ZXMgYXJlIENCT1JcbiAqIGVuY29kZWQuXG4gKi9cbmZ1bmN0aW9uIG1hcChpdGVtcywgc3RhYmxlID0gZmFsc2UpIHtcbiAgICBpZiAoIShpdGVtcyBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgICAgaXRlbXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGl0ZW1zKSk7XG4gICAgfVxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShpdGVtcy5lbnRyaWVzKCkpO1xuICAgIGlmIChzdGFibGUpIHtcbiAgICAgICAgZW50cmllcyA9IGVudHJpZXMuc29ydCgoW2tleUFdLCBba2V5Ql0pID0+IGtleUEubG9jYWxlQ29tcGFyZShrZXlCKSk7XG4gICAgfVxuICAgIHJldHVybiBfY29uY2F0KF9zZXJpYWxpemVOdW1iZXIoNSAvKiBNYXAgKi8sIGl0ZW1zLnNpemUpLCAuLi5lbnRyaWVzLm1hcCgoW2ssIHZdKSA9PiBfY29uY2F0KF9zZXJpYWxpemVTdHJpbmcoayksIHYpKSk7XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbi8qKlxuICogRW5jb2RlIGEgc2luZ2xlICgzMiBiaXRzKSBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBzaW5nbGVGbG9hdChmKSB7XG4gICAgY29uc3Qgc2luZ2xlID0gbmV3IEZsb2F0MzJBcnJheShbZl0pO1xuICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDI2XSksIG5ldyBVaW50OEFycmF5KHNpbmdsZS5idWZmZXIpKTtcbn1cbmV4cG9ydHMuc2luZ2xlRmxvYXQgPSBzaW5nbGVGbG9hdDtcbi8qKlxuICogRW5jb2RlIGEgZG91YmxlICg2NCBiaXRzKSBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBkb3VibGVGbG9hdChmKSB7XG4gICAgY29uc3Qgc2luZ2xlID0gbmV3IEZsb2F0NjRBcnJheShbZl0pO1xuICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDI3XSksIG5ldyBVaW50OEFycmF5KHNpbmdsZS5idWZmZXIpKTtcbn1cbmV4cG9ydHMuZG91YmxlRmxvYXQgPSBkb3VibGVGbG9hdDtcbmZ1bmN0aW9uIGJvb2wodikge1xuICAgIHJldHVybiB2ID8gdHJ1ZV8oKSA6IGZhbHNlXygpO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbi8qKlxuICogRW5jb2RlIHRoZSBib29sZWFuIHRydWUuXG4gKi9cbmZ1bmN0aW9uIHRydWVfKCkge1xuICAgIHJldHVybiByYXcobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjFdKSk7XG59XG5leHBvcnRzLnRydWVfID0gdHJ1ZV87XG4vKipcbiAqIEVuY29kZSB0aGUgYm9vbGVhbiBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gZmFsc2VfKCkge1xuICAgIHJldHVybiByYXcobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjBdKSk7XG59XG5leHBvcnRzLmZhbHNlXyA9IGZhbHNlXztcbi8qKlxuICogRW5jb2RlIHRoZSBjb25zdGFudCBudWxsLlxuICovXG5mdW5jdGlvbiBudWxsXygpIHtcbiAgICByZXR1cm4gcmF3KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDIyXSkpO1xufVxuZXhwb3J0cy5udWxsXyA9IG51bGxfO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGNvbnN0YW50IHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gdW5kZWZpbmVkXygpIHtcbiAgICByZXR1cm4gcmF3KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDIzXSkpO1xufVxuZXhwb3J0cy51bmRlZmluZWRfID0gdW5kZWZpbmVkXztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/simple-cbor@0.4.1/node_modules/simple-cbor/src/value.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/bls.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/bls.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls: () => (/* binding */ bls)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _hash_to_curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hash-to-curve.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _weierstrass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./weierstrass.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// BLS (Barreto-Lynn-Scott) family of pairing-friendly curves.\n// TODO: import { AffinePoint } from './curve.js';\n\n\n// prettier-ignore\n\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a) {\n    const res = [];\n    // a>1 because of marker bit\n    for (; a > _1n; a >>= _1n) {\n        if ((a & _1n) === _0n)\n            res.unshift(0);\n        else if ((a & _3n) === _3n) {\n            res.unshift(-1);\n            a += _1n;\n        }\n        else\n            res.unshift(1);\n    }\n    return res;\n}\nfunction bls(CURVE) {\n    // Fields are specific for curve, so for now we'll need to pass them with opts\n    const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n    const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;\n    const TWIST = CURVE.params.twistType;\n    // Point on G1 curve: (x, y)\n    const G1_ = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_0__.weierstrassPoints)({ n: Fr.ORDER, ...CURVE.G1 });\n    const G1 = Object.assign(G1_, (0,_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\n        ...CURVE.htfDefaults,\n        ...CURVE.G1.htfDefaults,\n    }));\n    // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n    const G2_ = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_0__.weierstrassPoints)({ n: Fr.ORDER, ...CURVE.G2 });\n    const G2 = Object.assign(G2_, (0,_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(G2_.ProjectivePoint, CURVE.G2.mapToCurve, {\n        ...CURVE.htfDefaults,\n        ...CURVE.G2.htfDefaults,\n    }));\n    // Applies sparse multiplication as line function\n    let lineFunction;\n    if (TWIST === 'multiplicative') {\n        lineFunction = (c0, c1, c2, f, Px, Py) => Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n    }\n    else if (TWIST === 'divisive') {\n        // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n        // precompute calculations.\n        lineFunction = (c0, c1, c2, f, Px, Py) => Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n    }\n    else\n        throw new Error('bls: unknown twist type');\n    const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n    function pointDouble(ell, Rx, Ry, Rz) {\n        const t0 = Fp2.sqr(Ry); // Ry²\n        const t1 = Fp2.sqr(Rz); // Rz²\n        const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n        const t3 = Fp2.mul(t2, _3n); // 3 * T2\n        const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n        const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n        const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n        const c2 = Fp2.neg(t4); // -T4 (-h)\n        ell.push([c0, c1, c2]);\n        Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n        Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n        Rz = Fp2.mul(t0, t4); // T0 * T4\n        return { Rx, Ry, Rz };\n    }\n    function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {\n        // Addition\n        const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n        const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n        const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n        const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n        const c2 = t1; // == Rx - Qx * Rz\n        ell.push([c0, c1, c2]);\n        const t2 = Fp2.sqr(t1); // T1²\n        const t3 = Fp2.mul(t2, t1); // T2 * T1\n        const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n        const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n        Rx = Fp2.mul(t1, t5); // T1 * T5\n        Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n        Rz = Fp2.mul(Rz, t3); // Rz * T3\n        return { Rx, Ry, Rz };\n    }\n    // Pre-compute coefficients for sparse multiplication\n    // Point addition and point double calculations is reused for coefficients\n    // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n    // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n    const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);\n    const calcPairingPrecomputes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.memoized)((point) => {\n        const p = point;\n        const { x, y } = p.toAffine();\n        // prettier-ignore\n        const Qx = x, Qy = y, negQy = Fp2.neg(y);\n        // prettier-ignore\n        let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\n        const ell = [];\n        for (const bit of ATE_NAF) {\n            const cur = [];\n            ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\n            if (bit)\n                ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n            ell.push(cur);\n        }\n        if (CURVE.postPrecompute) {\n            const last = ell[ell.length - 1];\n            CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n        }\n        return ell;\n    });\n    function millerLoopBatch(pairs, withFinalExponent = false) {\n        let f12 = Fp12.ONE;\n        if (pairs.length) {\n            const ellLen = pairs[0][0].length;\n            for (let i = 0; i < ellLen; i++) {\n                f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n                // NOTE: we apply multiple pairings in parallel here\n                for (const [ell, Px, Py] of pairs) {\n                    for (const [c0, c1, c2] of ell[i])\n                        f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n                }\n            }\n        }\n        if (BLS_X_IS_NEGATIVE)\n            f12 = Fp12.conjugate(f12);\n        return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n    }\n    // Calculates product of multiple pairings\n    // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n    function pairingBatch(pairs, withFinalExponent = true) {\n        const res = [];\n        // This cache precomputed toAffine for all points\n        G1.ProjectivePoint.normalizeZ(pairs.map(({ g1 }) => g1));\n        G2.ProjectivePoint.normalizeZ(pairs.map(({ g2 }) => g2));\n        for (const { g1, g2 } of pairs) {\n            if (g1.equals(G1.ProjectivePoint.ZERO) || g2.equals(G2.ProjectivePoint.ZERO))\n                throw new Error('pairing is not available for ZERO point');\n            // This uses toAffine inside\n            g1.assertValidity();\n            g2.assertValidity();\n            const Qa = g1.toAffine();\n            res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n        }\n        return millerLoopBatch(res, withFinalExponent);\n    }\n    // Calculates bilinear pairing\n    function pairing(Q, P, withFinalExponent = true) {\n        return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);\n    }\n    const utils = {\n        randomPrivateKey: () => {\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.getMinHashLength)(Fr.ORDER);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.mapHashToField)(CURVE.randomBytes(length), Fr.ORDER);\n        },\n        calcPairingPrecomputes,\n    };\n    const { ShortSignature } = CURVE.G1;\n    const { Signature } = CURVE.G2;\n    function normP1(point) {\n        return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);\n    }\n    function normP1Hash(point, htfOpts) {\n        return point instanceof G1.ProjectivePoint\n            ? point\n            : G1.hashToCurve((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.ensureBytes)('point', point), htfOpts);\n    }\n    function normP2(point) {\n        return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\n    }\n    function normP2Hash(point, htfOpts) {\n        return point instanceof G2.ProjectivePoint\n            ? point\n            : G2.hashToCurve((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.ensureBytes)('point', point), htfOpts);\n    }\n    // Multiplies generator (G1) by private key.\n    // P = pk x G\n    function getPublicKey(privateKey) {\n        return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n    }\n    // Multiplies generator (G2) by private key.\n    // P = pk x G\n    function getPublicKeyForShortSignatures(privateKey) {\n        return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n    }\n    function sign(message, privateKey, htfOpts) {\n        const msgPoint = normP2Hash(message, htfOpts);\n        msgPoint.assertValidity();\n        const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n        if (message instanceof G2.ProjectivePoint)\n            return sigPoint;\n        return Signature.toRawBytes(sigPoint);\n    }\n    function signShortSignature(message, privateKey, htfOpts) {\n        const msgPoint = normP1Hash(message, htfOpts);\n        msgPoint.assertValidity();\n        const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n        if (message instanceof G1.ProjectivePoint)\n            return sigPoint;\n        return ShortSignature.toRawBytes(sigPoint);\n    }\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(P, H(m)) == e(G, S)\n    function verify(signature, message, publicKey, htfOpts) {\n        const P = normP1(publicKey);\n        const Hm = normP2Hash(message, htfOpts);\n        const G = G1.ProjectivePoint.BASE;\n        const S = normP2(signature);\n        const exp = pairingBatch([\n            { g1: P.negate(), g2: Hm }, // ePHM = pairing(P.negate(), Hm, false);\n            { g1: G, g2: S }, // eGS = pairing(G, S, false);\n        ]);\n        return Fp12.eql(exp, Fp12.ONE);\n    }\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(S, G) == e(H(m), P)\n    function verifyShortSignature(signature, message, publicKey, htfOpts) {\n        const P = normP2(publicKey);\n        const Hm = normP1Hash(message, htfOpts);\n        const G = G2.ProjectivePoint.BASE;\n        const S = normP1(signature);\n        const exp = pairingBatch([\n            { g1: Hm, g2: P }, // eHmP = pairing(Hm, P, false);\n            { g1: S, g2: G.negate() }, // eSG = pairing(S, G.negate(), false);\n        ]);\n        return Fp12.eql(exp, Fp12.ONE);\n    }\n    function aggregatePublicKeys(publicKeys) {\n        if (!publicKeys.length)\n            throw new Error('Expected non-empty array');\n        const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (publicKeys[0] instanceof G1.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        // toRawBytes ensures point validity\n        return aggAffine.toRawBytes(true);\n    }\n    function aggregateSignatures(signatures) {\n        if (!signatures.length)\n            throw new Error('Expected non-empty array');\n        const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (signatures[0] instanceof G2.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        return Signature.toRawBytes(aggAffine);\n    }\n    function aggregateShortSignatures(signatures) {\n        if (!signatures.length)\n            throw new Error('Expected non-empty array');\n        const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (signatures[0] instanceof G1.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        return ShortSignature.toRawBytes(aggAffine);\n    }\n    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n    function verifyBatch(signature, \n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n    messages, publicKeys, htfOpts) {\n        if (!messages.length)\n            throw new Error('Expected non-empty messages array');\n        if (publicKeys.length !== messages.length)\n            throw new Error('Pubkey count should equal msg count');\n        const sig = normP2(signature);\n        const nMessages = messages.map((i) => normP2Hash(i, htfOpts));\n        const nPublicKeys = publicKeys.map(normP1);\n        // NOTE: this works only for exact same object\n        const messagePubKeyMap = new Map();\n        for (let i = 0; i < nPublicKeys.length; i++) {\n            const pub = nPublicKeys[i];\n            const msg = nMessages[i];\n            let keys = messagePubKeyMap.get(msg);\n            if (keys === undefined) {\n                keys = [];\n                messagePubKeyMap.set(msg, keys);\n            }\n            keys.push(pub);\n        }\n        const paired = [];\n        try {\n            for (const [msg, keys] of messagePubKeyMap) {\n                const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n                paired.push({ g1: groupPublicKey, g2: msg });\n            }\n            paired.push({ g1: G1.ProjectivePoint.BASE.negate(), g2: sig });\n            return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n        }\n        catch {\n            return false;\n        }\n    }\n    G1.ProjectivePoint.BASE._setWindowSize(4);\n    return {\n        getPublicKey,\n        getPublicKeyForShortSignatures,\n        sign,\n        signShortSignature,\n        verify,\n        verifyBatch,\n        verifyShortSignature,\n        aggregatePublicKeys,\n        aggregateSignatures,\n        aggregateShortSignatures,\n        millerLoopBatch,\n        pairing,\n        pairingBatch,\n        G1,\n        G2,\n        Signature,\n        ShortSignature,\n        fields: {\n            Fr,\n            Fp,\n            Fp2,\n            Fp6,\n            Fp12,\n        },\n        params: {\n            ateLoopSize: CURVE.params.ateLoopSize,\n            r: CURVE.params.r,\n            G1b: CURVE.G1.b,\n            G2b: CURVE.G2.b,\n        },\n        utils,\n    };\n}\n//# sourceMappingURL=bls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvYmxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2dDO0FBQ2I7QUFDbkQ7QUFDa0Q7QUFDSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWlCLEdBQUcsMEJBQTBCO0FBQzlELGtDQUFrQywrREFBWTtBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGtFQUFpQixHQUFHLDBCQUEwQjtBQUM5RCxrQ0FBa0MsK0RBQVk7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxpREFBaUQ7QUFDakQscUNBQXFDO0FBQ3JDLHVFQUF1RTtBQUN2RSxvQ0FBb0M7QUFDcEMsOENBQThDO0FBQzlDLGdDQUFnQztBQUNoQztBQUNBLDBFQUEwRTtBQUMxRSw2RkFBNkY7QUFDN0YsOEJBQThCO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pELDhEQUE4RDtBQUM5RCxnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCO0FBQ0EsZ0NBQWdDO0FBQ2hDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMscUZBQXFGO0FBQ3JGLDhCQUE4QjtBQUM5QixxRUFBcUU7QUFDckUsOEJBQThCO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbURBQVE7QUFDM0M7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLFlBQVksTUFBTTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RCxtREFBbUQsSUFBSTtBQUN2RCxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkRBQWdCO0FBQzNDLG1CQUFtQiwyREFBYztBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0EsMEJBQTBCLCtDQUErQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS42LjAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2Jscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBCTFMgKEJhcnJldG8tTHlubi1TY290dCkgZmFtaWx5IG9mIHBhaXJpbmctZnJpZW5kbHkgY3VydmVzLlxuLy8gVE9ETzogaW1wb3J0IHsgQWZmaW5lUG9pbnQgfSBmcm9tICcuL2N1cnZlLmpzJztcbmltcG9ydCB7IGdldE1pbkhhc2hMZW5ndGgsIG1hcEhhc2hUb0ZpZWxkIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzLCBtZW1vaXplZCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIgfSBmcm9tICcuL2hhc2gtdG8tY3VydmUuanMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3NQb2ludHMsIH0gZnJvbSAnLi93ZWllcnN0cmFzcy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIE5vdCB1c2VkIHdpdGggQkxTMTItMzgxIChubyBzZXF1ZW50aWFsIGAxMWAgaW4gWCkuIFVzZWZ1bCBmb3Igb3RoZXIgY3VydmVzLlxuZnVuY3Rpb24gTkFmRGVjb21wb3NpdGlvbihhKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgLy8gYT4xIGJlY2F1c2Ugb2YgbWFya2VyIGJpdFxuICAgIGZvciAoOyBhID4gXzFuOyBhID4+PSBfMW4pIHtcbiAgICAgICAgaWYgKChhICYgXzFuKSA9PT0gXzBuKVxuICAgICAgICAgICAgcmVzLnVuc2hpZnQoMCk7XG4gICAgICAgIGVsc2UgaWYgKChhICYgXzNuKSA9PT0gXzNuKSB7XG4gICAgICAgICAgICByZXMudW5zaGlmdCgtMSk7XG4gICAgICAgICAgICBhICs9IF8xbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXMudW5zaGlmdCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBibHMoQ1VSVkUpIHtcbiAgICAvLyBGaWVsZHMgYXJlIHNwZWNpZmljIGZvciBjdXJ2ZSwgc28gZm9yIG5vdyB3ZSdsbCBuZWVkIHRvIHBhc3MgdGhlbSB3aXRoIG9wdHNcbiAgICBjb25zdCB7IEZwLCBGciwgRnAyLCBGcDYsIEZwMTIgfSA9IENVUlZFLmZpZWxkcztcbiAgICBjb25zdCBCTFNfWF9JU19ORUdBVElWRSA9IENVUlZFLnBhcmFtcy54TmVnYXRpdmU7XG4gICAgY29uc3QgVFdJU1QgPSBDVVJWRS5wYXJhbXMudHdpc3RUeXBlO1xuICAgIC8vIFBvaW50IG9uIEcxIGN1cnZlOiAoeCwgeSlcbiAgICBjb25zdCBHMV8gPSB3ZWllcnN0cmFzc1BvaW50cyh7IG46IEZyLk9SREVSLCAuLi5DVVJWRS5HMSB9KTtcbiAgICBjb25zdCBHMSA9IE9iamVjdC5hc3NpZ24oRzFfLCBjcmVhdGVIYXNoZXIoRzFfLlByb2plY3RpdmVQb2ludCwgQ1VSVkUuRzEubWFwVG9DdXJ2ZSwge1xuICAgICAgICAuLi5DVVJWRS5odGZEZWZhdWx0cyxcbiAgICAgICAgLi4uQ1VSVkUuRzEuaHRmRGVmYXVsdHMsXG4gICAgfSkpO1xuICAgIC8vIFBvaW50IG9uIEcyIGN1cnZlIChjb21wbGV4IG51bWJlcnMpOiAoeOKCgSwgeOKCgitpKSwgKHnigoEsIHnigoIraSlcbiAgICBjb25zdCBHMl8gPSB3ZWllcnN0cmFzc1BvaW50cyh7IG46IEZyLk9SREVSLCAuLi5DVVJWRS5HMiB9KTtcbiAgICBjb25zdCBHMiA9IE9iamVjdC5hc3NpZ24oRzJfLCBjcmVhdGVIYXNoZXIoRzJfLlByb2plY3RpdmVQb2ludCwgQ1VSVkUuRzIubWFwVG9DdXJ2ZSwge1xuICAgICAgICAuLi5DVVJWRS5odGZEZWZhdWx0cyxcbiAgICAgICAgLi4uQ1VSVkUuRzIuaHRmRGVmYXVsdHMsXG4gICAgfSkpO1xuICAgIC8vIEFwcGxpZXMgc3BhcnNlIG11bHRpcGxpY2F0aW9uIGFzIGxpbmUgZnVuY3Rpb25cbiAgICBsZXQgbGluZUZ1bmN0aW9uO1xuICAgIGlmIChUV0lTVCA9PT0gJ211bHRpcGxpY2F0aXZlJykge1xuICAgICAgICBsaW5lRnVuY3Rpb24gPSAoYzAsIGMxLCBjMiwgZiwgUHgsIFB5KSA9PiBGcDEyLm11bDAxNChmLCBjMCwgRnAyLm11bChjMSwgUHgpLCBGcDIubXVsKGMyLCBQeSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChUV0lTVCA9PT0gJ2RpdmlzaXZlJykge1xuICAgICAgICAvLyBOT1RFOiBpdCBzaG91bGQgYmUgW2MwLCBjMSwgYzJdLCBidXQgd2UgdXNlIGRpZmZlcmVudCBvcmRlciBoZXJlIHRvIHJlZHVjZSBjb21wbGV4aXR5IG9mXG4gICAgICAgIC8vIHByZWNvbXB1dGUgY2FsY3VsYXRpb25zLlxuICAgICAgICBsaW5lRnVuY3Rpb24gPSAoYzAsIGMxLCBjMiwgZiwgUHgsIFB5KSA9PiBGcDEyLm11bDAzNChmLCBGcDIubXVsKGMyLCBQeSksIEZwMi5tdWwoYzEsIFB4KSwgYzApO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmxzOiB1bmtub3duIHR3aXN0IHR5cGUnKTtcbiAgICBjb25zdCBGcDJkaXYyID0gRnAyLmRpdihGcDIuT05FLCBGcDIubXVsKEZwMi5PTkUsIF8ybikpO1xuICAgIGZ1bmN0aW9uIHBvaW50RG91YmxlKGVsbCwgUngsIFJ5LCBSeikge1xuICAgICAgICBjb25zdCB0MCA9IEZwMi5zcXIoUnkpOyAvLyBSecKyXG4gICAgICAgIGNvbnN0IHQxID0gRnAyLnNxcihSeik7IC8vIFJ6wrJcbiAgICAgICAgY29uc3QgdDIgPSBGcDIubXVsQnlCKEZwMi5tdWwodDEsIF8zbikpOyAvLyAzICogVDEgKiBCXG4gICAgICAgIGNvbnN0IHQzID0gRnAyLm11bCh0MiwgXzNuKTsgLy8gMyAqIFQyXG4gICAgICAgIGNvbnN0IHQ0ID0gRnAyLnN1YihGcDIuc3ViKEZwMi5zcXIoRnAyLmFkZChSeSwgUnopKSwgdDEpLCB0MCk7IC8vIChSeSArIFJ6KcKyIC0gVDEgLSBUMFxuICAgICAgICBjb25zdCBjMCA9IEZwMi5zdWIodDIsIHQwKTsgLy8gVDIgLSBUMCAoaSlcbiAgICAgICAgY29uc3QgYzEgPSBGcDIubXVsKEZwMi5zcXIoUngpLCBfM24pOyAvLyAzICogUnjCslxuICAgICAgICBjb25zdCBjMiA9IEZwMi5uZWcodDQpOyAvLyAtVDQgKC1oKVxuICAgICAgICBlbGwucHVzaChbYzAsIGMxLCBjMl0pO1xuICAgICAgICBSeCA9IEZwMi5tdWwoRnAyLm11bChGcDIubXVsKEZwMi5zdWIodDAsIHQzKSwgUngpLCBSeSksIEZwMmRpdjIpOyAvLyAoKFQwIC0gVDMpICogUnggKiBSeSkgLyAyXG4gICAgICAgIFJ5ID0gRnAyLnN1YihGcDIuc3FyKEZwMi5tdWwoRnAyLmFkZCh0MCwgdDMpLCBGcDJkaXYyKSksIEZwMi5tdWwoRnAyLnNxcih0MiksIF8zbikpOyAvLyAoKFQwICsgVDMpIC8gMinCsiAtIDMgKiBUMsKyXG4gICAgICAgIFJ6ID0gRnAyLm11bCh0MCwgdDQpOyAvLyBUMCAqIFQ0XG4gICAgICAgIHJldHVybiB7IFJ4LCBSeSwgUnogfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRBZGQoZWxsLCBSeCwgUnksIFJ6LCBReCwgUXkpIHtcbiAgICAgICAgLy8gQWRkaXRpb25cbiAgICAgICAgY29uc3QgdDAgPSBGcDIuc3ViKFJ5LCBGcDIubXVsKFF5LCBSeikpOyAvLyBSeSAtIFF5ICogUnpcbiAgICAgICAgY29uc3QgdDEgPSBGcDIuc3ViKFJ4LCBGcDIubXVsKFF4LCBSeikpOyAvLyBSeCAtIFF4ICogUnpcbiAgICAgICAgY29uc3QgYzAgPSBGcDIuc3ViKEZwMi5tdWwodDAsIFF4KSwgRnAyLm11bCh0MSwgUXkpKTsgLy8gVDAgKiBReCAtIFQxICogUXkgPT0gUnkgKiBReCAgLSBSeCAqIFF5XG4gICAgICAgIGNvbnN0IGMxID0gRnAyLm5lZyh0MCk7IC8vIC1UMCA9PSBReSAqIFJ6IC0gUnlcbiAgICAgICAgY29uc3QgYzIgPSB0MTsgLy8gPT0gUnggLSBReCAqIFJ6XG4gICAgICAgIGVsbC5wdXNoKFtjMCwgYzEsIGMyXSk7XG4gICAgICAgIGNvbnN0IHQyID0gRnAyLnNxcih0MSk7IC8vIFQxwrJcbiAgICAgICAgY29uc3QgdDMgPSBGcDIubXVsKHQyLCB0MSk7IC8vIFQyICogVDFcbiAgICAgICAgY29uc3QgdDQgPSBGcDIubXVsKHQyLCBSeCk7IC8vIFQyICogUnhcbiAgICAgICAgY29uc3QgdDUgPSBGcDIuYWRkKEZwMi5zdWIodDMsIEZwMi5tdWwodDQsIF8ybikpLCBGcDIubXVsKEZwMi5zcXIodDApLCBSeikpOyAvLyBUMyAtIDIgKiBUNCArIFQwwrIgKiBSelxuICAgICAgICBSeCA9IEZwMi5tdWwodDEsIHQ1KTsgLy8gVDEgKiBUNVxuICAgICAgICBSeSA9IEZwMi5zdWIoRnAyLm11bChGcDIuc3ViKHQ0LCB0NSksIHQwKSwgRnAyLm11bCh0MywgUnkpKTsgLy8gKFQ0IC0gVDUpICogVDAgLSBUMyAqIFJ5XG4gICAgICAgIFJ6ID0gRnAyLm11bChSeiwgdDMpOyAvLyBSeiAqIFQzXG4gICAgICAgIHJldHVybiB7IFJ4LCBSeSwgUnogfTtcbiAgICB9XG4gICAgLy8gUHJlLWNvbXB1dGUgY29lZmZpY2llbnRzIGZvciBzcGFyc2UgbXVsdGlwbGljYXRpb25cbiAgICAvLyBQb2ludCBhZGRpdGlvbiBhbmQgcG9pbnQgZG91YmxlIGNhbGN1bGF0aW9ucyBpcyByZXVzZWQgZm9yIGNvZWZmaWNpZW50c1xuICAgIC8vIHBvaW50QWRkIGhhcHBlbnMgb25seSBpZiBiaXQgc2V0LCBzbyB3TkFGIGlzIHJlYXNvbmFibGUuIFVuZm9ydHVuYXRlbHkgd2UgY2Fubm90IGNvbWJpbmVcbiAgICAvLyBhZGQgKyBkb3VibGUgaW4gd2luZG93ZWQgcHJlY29tcHV0ZXMgaGVyZSwgb3RoZXJ3aXNlIGl0IHdvdWxkIGJlIHNpbmdsZSBvcCAoc2luY2UgWCBpcyBzdGF0aWMpXG4gICAgY29uc3QgQVRFX05BRiA9IE5BZkRlY29tcG9zaXRpb24oQ1VSVkUucGFyYW1zLmF0ZUxvb3BTaXplKTtcbiAgICBjb25zdCBjYWxjUGFpcmluZ1ByZWNvbXB1dGVzID0gbWVtb2l6ZWQoKHBvaW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBwb2ludDtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwLnRvQWZmaW5lKCk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBReCA9IHgsIFF5ID0geSwgbmVnUXkgPSBGcDIubmVnKHkpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IFJ4ID0gUXgsIFJ5ID0gUXksIFJ6ID0gRnAyLk9ORTtcbiAgICAgICAgY29uc3QgZWxsID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYml0IG9mIEFURV9OQUYpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1ciA9IFtdO1xuICAgICAgICAgICAgKHsgUngsIFJ5LCBSeiB9ID0gcG9pbnREb3VibGUoY3VyLCBSeCwgUnksIFJ6KSk7XG4gICAgICAgICAgICBpZiAoYml0KVxuICAgICAgICAgICAgICAgICh7IFJ4LCBSeSwgUnogfSA9IHBvaW50QWRkKGN1ciwgUngsIFJ5LCBSeiwgUXgsIGJpdCA9PT0gLTEgPyBuZWdReSA6IFF5KSk7XG4gICAgICAgICAgICBlbGwucHVzaChjdXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDVVJWRS5wb3N0UHJlY29tcHV0ZSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdCA9IGVsbFtlbGwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBDVVJWRS5wb3N0UHJlY29tcHV0ZShSeCwgUnksIFJ6LCBReCwgUXksIHBvaW50QWRkLmJpbmQobnVsbCwgbGFzdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGw7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gbWlsbGVyTG9vcEJhdGNoKHBhaXJzLCB3aXRoRmluYWxFeHBvbmVudCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBmMTIgPSBGcDEyLk9ORTtcbiAgICAgICAgaWYgKHBhaXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZWxsTGVuID0gcGFpcnNbMF1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGxMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGYxMiA9IEZwMTIuc3FyKGYxMik7IC8vIFRoaXMgYWxsb3dzIHVzIHRvIGRvIHNxciBvbmx5IG9uZSB0aW1lIGZvciBhbGwgcGFpcmluZ3NcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBhcHBseSBtdWx0aXBsZSBwYWlyaW5ncyBpbiBwYXJhbGxlbCBoZXJlXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZWxsLCBQeCwgUHldIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2MwLCBjMSwgYzJdIG9mIGVsbFtpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGYxMiA9IGxpbmVGdW5jdGlvbihjMCwgYzEsIGMyLCBmMTIsIFB4LCBQeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChCTFNfWF9JU19ORUdBVElWRSlcbiAgICAgICAgICAgIGYxMiA9IEZwMTIuY29uanVnYXRlKGYxMik7XG4gICAgICAgIHJldHVybiB3aXRoRmluYWxFeHBvbmVudCA/IEZwMTIuZmluYWxFeHBvbmVudGlhdGUoZjEyKSA6IGYxMjtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlcyBwcm9kdWN0IG9mIG11bHRpcGxlIHBhaXJpbmdzXG4gICAgLy8gVGhpcyB1cCB0byB4MiBmYXN0ZXIgdGhhbiBqdXN0IGBtYXAoKHtnMSwgZzJ9KT0+cGFpcmluZyh7ZzEsZzJ9KSlgXG4gICAgZnVuY3Rpb24gcGFpcmluZ0JhdGNoKHBhaXJzLCB3aXRoRmluYWxFeHBvbmVudCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIC8vIFRoaXMgY2FjaGUgcHJlY29tcHV0ZWQgdG9BZmZpbmUgZm9yIGFsbCBwb2ludHNcbiAgICAgICAgRzEuUHJvamVjdGl2ZVBvaW50Lm5vcm1hbGl6ZVoocGFpcnMubWFwKCh7IGcxIH0pID0+IGcxKSk7XG4gICAgICAgIEcyLlByb2plY3RpdmVQb2ludC5ub3JtYWxpemVaKHBhaXJzLm1hcCgoeyBnMiB9KSA9PiBnMikpO1xuICAgICAgICBmb3IgKGNvbnN0IHsgZzEsIGcyIH0gb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGlmIChnMS5lcXVhbHMoRzEuUHJvamVjdGl2ZVBvaW50LlpFUk8pIHx8IGcyLmVxdWFscyhHMi5Qcm9qZWN0aXZlUG9pbnQuWkVSTykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWlyaW5nIGlzIG5vdCBhdmFpbGFibGUgZm9yIFpFUk8gcG9pbnQnKTtcbiAgICAgICAgICAgIC8vIFRoaXMgdXNlcyB0b0FmZmluZSBpbnNpZGVcbiAgICAgICAgICAgIGcxLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICBnMi5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgY29uc3QgUWEgPSBnMS50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmVzLnB1c2goW2NhbGNQYWlyaW5nUHJlY29tcHV0ZXMoZzIpLCBRYS54LCBRYS55XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbGxlckxvb3BCYXRjaChyZXMsIHdpdGhGaW5hbEV4cG9uZW50KTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlcyBiaWxpbmVhciBwYWlyaW5nXG4gICAgZnVuY3Rpb24gcGFpcmluZyhRLCBQLCB3aXRoRmluYWxFeHBvbmVudCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHBhaXJpbmdCYXRjaChbeyBnMTogUSwgZzI6IFAgfV0sIHdpdGhGaW5hbEV4cG9uZW50KTtcbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE1pbkhhc2hMZW5ndGgoRnIuT1JERVIpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIEZyLk9SREVSKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY1BhaXJpbmdQcmVjb21wdXRlcyxcbiAgICB9O1xuICAgIGNvbnN0IHsgU2hvcnRTaWduYXR1cmUgfSA9IENVUlZFLkcxO1xuICAgIGNvbnN0IHsgU2lnbmF0dXJlIH0gPSBDVVJWRS5HMjtcbiAgICBmdW5jdGlvbiBub3JtUDEocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50IGluc3RhbmNlb2YgRzEuUHJvamVjdGl2ZVBvaW50ID8gcG9pbnQgOiBHMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChwb2ludCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1QMUhhc2gocG9pbnQsIGh0Zk9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50IGluc3RhbmNlb2YgRzEuUHJvamVjdGl2ZVBvaW50XG4gICAgICAgICAgICA/IHBvaW50XG4gICAgICAgICAgICA6IEcxLmhhc2hUb0N1cnZlKGVuc3VyZUJ5dGVzKCdwb2ludCcsIHBvaW50KSwgaHRmT3B0cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1QMihwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnQgaW5zdGFuY2VvZiBHMi5Qcm9qZWN0aXZlUG9pbnQgPyBwb2ludCA6IFNpZ25hdHVyZS5mcm9tSGV4KHBvaW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybVAySGFzaChwb2ludCwgaHRmT3B0cykge1xuICAgICAgICByZXR1cm4gcG9pbnQgaW5zdGFuY2VvZiBHMi5Qcm9qZWN0aXZlUG9pbnRcbiAgICAgICAgICAgID8gcG9pbnRcbiAgICAgICAgICAgIDogRzIuaGFzaFRvQ3VydmUoZW5zdXJlQnl0ZXMoJ3BvaW50JywgcG9pbnQpLCBodGZPcHRzKTtcbiAgICB9XG4gICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgKEcxKSBieSBwcml2YXRlIGtleS5cbiAgICAvLyBQID0gcGsgeCBHXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIEcxLlByb2plY3RpdmVQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKHRydWUpO1xuICAgIH1cbiAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciAoRzIpIGJ5IHByaXZhdGUga2V5LlxuICAgIC8vIFAgPSBwayB4IEdcbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXlGb3JTaG9ydFNpZ25hdHVyZXMocHJpdmF0ZUtleSkge1xuICAgICAgICByZXR1cm4gRzIuUHJvamVjdGl2ZVBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgaHRmT3B0cykge1xuICAgICAgICBjb25zdCBtc2dQb2ludCA9IG5vcm1QMkhhc2gobWVzc2FnZSwgaHRmT3B0cyk7XG4gICAgICAgIG1zZ1BvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIGNvbnN0IHNpZ1BvaW50ID0gbXNnUG9pbnQubXVsdGlwbHkoRzEubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRzIuUHJvamVjdGl2ZVBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHNpZ1BvaW50O1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnRvUmF3Qnl0ZXMoc2lnUG9pbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaWduU2hvcnRTaWduYXR1cmUobWVzc2FnZSwgcHJpdmF0ZUtleSwgaHRmT3B0cykge1xuICAgICAgICBjb25zdCBtc2dQb2ludCA9IG5vcm1QMUhhc2gobWVzc2FnZSwgaHRmT3B0cyk7XG4gICAgICAgIG1zZ1BvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIGNvbnN0IHNpZ1BvaW50ID0gbXNnUG9pbnQubXVsdGlwbHkoRzEubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRzEuUHJvamVjdGl2ZVBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHNpZ1BvaW50O1xuICAgICAgICByZXR1cm4gU2hvcnRTaWduYXR1cmUudG9SYXdCeXRlcyhzaWdQb2ludCk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBwYWlyaW5nIG9mIHB1YmxpYyBrZXkgJiBoYXNoIGlzIGVxdWFsIHRvIHBhaXJpbmcgb2YgZ2VuZXJhdG9yICYgc2lnbmF0dXJlLlxuICAgIC8vIGUoUCwgSChtKSkgPT0gZShHLCBTKVxuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSwgaHRmT3B0cykge1xuICAgICAgICBjb25zdCBQID0gbm9ybVAxKHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IEhtID0gbm9ybVAySGFzaChtZXNzYWdlLCBodGZPcHRzKTtcbiAgICAgICAgY29uc3QgRyA9IEcxLlByb2plY3RpdmVQb2ludC5CQVNFO1xuICAgICAgICBjb25zdCBTID0gbm9ybVAyKHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IGV4cCA9IHBhaXJpbmdCYXRjaChbXG4gICAgICAgICAgICB7IGcxOiBQLm5lZ2F0ZSgpLCBnMjogSG0gfSwgLy8gZVBITSA9IHBhaXJpbmcoUC5uZWdhdGUoKSwgSG0sIGZhbHNlKTtcbiAgICAgICAgICAgIHsgZzE6IEcsIGcyOiBTIH0sIC8vIGVHUyA9IHBhaXJpbmcoRywgUywgZmFsc2UpO1xuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIEZwMTIuZXFsKGV4cCwgRnAxMi5PTkUpO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgcGFpcmluZyBvZiBwdWJsaWMga2V5ICYgaGFzaCBpcyBlcXVhbCB0byBwYWlyaW5nIG9mIGdlbmVyYXRvciAmIHNpZ25hdHVyZS5cbiAgICAvLyBlKFMsIEcpID09IGUoSChtKSwgUClcbiAgICBmdW5jdGlvbiB2ZXJpZnlTaG9ydFNpZ25hdHVyZShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSwgaHRmT3B0cykge1xuICAgICAgICBjb25zdCBQID0gbm9ybVAyKHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IEhtID0gbm9ybVAxSGFzaChtZXNzYWdlLCBodGZPcHRzKTtcbiAgICAgICAgY29uc3QgRyA9IEcyLlByb2plY3RpdmVQb2ludC5CQVNFO1xuICAgICAgICBjb25zdCBTID0gbm9ybVAxKHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IGV4cCA9IHBhaXJpbmdCYXRjaChbXG4gICAgICAgICAgICB7IGcxOiBIbSwgZzI6IFAgfSwgLy8gZUhtUCA9IHBhaXJpbmcoSG0sIFAsIGZhbHNlKTtcbiAgICAgICAgICAgIHsgZzE6IFMsIGcyOiBHLm5lZ2F0ZSgpIH0sIC8vIGVTRyA9IHBhaXJpbmcoUywgRy5uZWdhdGUoKSwgZmFsc2UpO1xuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIEZwMTIuZXFsKGV4cCwgRnAxMi5PTkUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZ2dyZWdhdGVQdWJsaWNLZXlzKHB1YmxpY0tleXMpIHtcbiAgICAgICAgaWYgKCFwdWJsaWNLZXlzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm9uLWVtcHR5IGFycmF5Jyk7XG4gICAgICAgIGNvbnN0IGFnZyA9IHB1YmxpY0tleXMubWFwKG5vcm1QMSkucmVkdWNlKChzdW0sIHApID0+IHN1bS5hZGQocCksIEcxLlByb2plY3RpdmVQb2ludC5aRVJPKTtcbiAgICAgICAgY29uc3QgYWdnQWZmaW5lID0gYWdnOyAvLy50b0FmZmluZSgpO1xuICAgICAgICBpZiAocHVibGljS2V5c1swXSBpbnN0YW5jZW9mIEcxLlByb2plY3RpdmVQb2ludCkge1xuICAgICAgICAgICAgYWdnQWZmaW5lLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gYWdnQWZmaW5lO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvUmF3Qnl0ZXMgZW5zdXJlcyBwb2ludCB2YWxpZGl0eVxuICAgICAgICByZXR1cm4gYWdnQWZmaW5lLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZVNpZ25hdHVyZXMoc2lnbmF0dXJlcykge1xuICAgICAgICBpZiAoIXNpZ25hdHVyZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBub24tZW1wdHkgYXJyYXknKTtcbiAgICAgICAgY29uc3QgYWdnID0gc2lnbmF0dXJlcy5tYXAobm9ybVAyKS5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtLmFkZChzKSwgRzIuUHJvamVjdGl2ZVBvaW50LlpFUk8pO1xuICAgICAgICBjb25zdCBhZ2dBZmZpbmUgPSBhZ2c7IC8vLnRvQWZmaW5lKCk7XG4gICAgICAgIGlmIChzaWduYXR1cmVzWzBdIGluc3RhbmNlb2YgRzIuUHJvamVjdGl2ZVBvaW50KSB7XG4gICAgICAgICAgICBhZ2dBZmZpbmUuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBhZ2dBZmZpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS50b1Jhd0J5dGVzKGFnZ0FmZmluZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZVNob3J0U2lnbmF0dXJlcyhzaWduYXR1cmVzKSB7XG4gICAgICAgIGlmICghc2lnbmF0dXJlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vbi1lbXB0eSBhcnJheScpO1xuICAgICAgICBjb25zdCBhZ2cgPSBzaWduYXR1cmVzLm1hcChub3JtUDEpLnJlZHVjZSgoc3VtLCBzKSA9PiBzdW0uYWRkKHMpLCBHMS5Qcm9qZWN0aXZlUG9pbnQuWkVSTyk7XG4gICAgICAgIGNvbnN0IGFnZ0FmZmluZSA9IGFnZzsgLy8udG9BZmZpbmUoKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZXNbMF0gaW5zdGFuY2VvZiBHMS5Qcm9qZWN0aXZlUG9pbnQpIHtcbiAgICAgICAgICAgIGFnZ0FmZmluZS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGFnZ0FmZmluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2hvcnRTaWduYXR1cmUudG9SYXdCeXRlcyhhZ2dBZmZpbmUpO1xuICAgIH1cbiAgICAvLyBodHRwczovL2V0aHJlc2Vhci5jaC90L2Zhc3QtdmVyaWZpY2F0aW9uLW9mLW11bHRpcGxlLWJscy1zaWduYXR1cmVzLzU0MDdcbiAgICAvLyBlKEcsIFMpID0gZShHLCBTVU0obikoU2kpKSA9IE1VTChuKShlKEcsIFNpKSlcbiAgICBmdW5jdGlvbiB2ZXJpZnlCYXRjaChzaWduYXR1cmUsIFxuICAgIC8vIFRPRE86IG1heWJlIGB7bWVzc2FnZTogRzJIZXgsIHB1YmxpY0tleTogRzFIZXh9W11gIGluc3RlYWQ/XG4gICAgbWVzc2FnZXMsIHB1YmxpY0tleXMsIGh0Zk9wdHMpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vbi1lbXB0eSBtZXNzYWdlcyBhcnJheScpO1xuICAgICAgICBpZiAocHVibGljS2V5cy5sZW5ndGggIT09IG1lc3NhZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHVia2V5IGNvdW50IHNob3VsZCBlcXVhbCBtc2cgY291bnQnKTtcbiAgICAgICAgY29uc3Qgc2lnID0gbm9ybVAyKHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IG5NZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgoaSkgPT4gbm9ybVAySGFzaChpLCBodGZPcHRzKSk7XG4gICAgICAgIGNvbnN0IG5QdWJsaWNLZXlzID0gcHVibGljS2V5cy5tYXAobm9ybVAxKTtcbiAgICAgICAgLy8gTk9URTogdGhpcyB3b3JrcyBvbmx5IGZvciBleGFjdCBzYW1lIG9iamVjdFxuICAgICAgICBjb25zdCBtZXNzYWdlUHViS2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5QdWJsaWNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwdWIgPSBuUHVibGljS2V5c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IG5NZXNzYWdlc1tpXTtcbiAgICAgICAgICAgIGxldCBrZXlzID0gbWVzc2FnZVB1YktleU1hcC5nZXQobXNnKTtcbiAgICAgICAgICAgIGlmIChrZXlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrZXlzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZVB1YktleU1hcC5zZXQobXNnLCBrZXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleXMucHVzaChwdWIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJlZCA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbXNnLCBrZXlzXSBvZiBtZXNzYWdlUHViS2V5TWFwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBQdWJsaWNLZXkgPSBrZXlzLnJlZHVjZSgoYWNjLCBtc2cpID0+IGFjYy5hZGQobXNnKSk7XG4gICAgICAgICAgICAgICAgcGFpcmVkLnB1c2goeyBnMTogZ3JvdXBQdWJsaWNLZXksIGcyOiBtc2cgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWlyZWQucHVzaCh7IGcxOiBHMS5Qcm9qZWN0aXZlUG9pbnQuQkFTRS5uZWdhdGUoKSwgZzI6IHNpZyB9KTtcbiAgICAgICAgICAgIHJldHVybiBGcDEyLmVxbChwYWlyaW5nQmF0Y2gocGFpcmVkKSwgRnAxMi5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBHMS5Qcm9qZWN0aXZlUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFB1YmxpY0tleUZvclNob3J0U2lnbmF0dXJlcyxcbiAgICAgICAgc2lnbixcbiAgICAgICAgc2lnblNob3J0U2lnbmF0dXJlLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIHZlcmlmeUJhdGNoLFxuICAgICAgICB2ZXJpZnlTaG9ydFNpZ25hdHVyZSxcbiAgICAgICAgYWdncmVnYXRlUHVibGljS2V5cyxcbiAgICAgICAgYWdncmVnYXRlU2lnbmF0dXJlcyxcbiAgICAgICAgYWdncmVnYXRlU2hvcnRTaWduYXR1cmVzLFxuICAgICAgICBtaWxsZXJMb29wQmF0Y2gsXG4gICAgICAgIHBhaXJpbmcsXG4gICAgICAgIHBhaXJpbmdCYXRjaCxcbiAgICAgICAgRzEsXG4gICAgICAgIEcyLFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIFNob3J0U2lnbmF0dXJlLFxuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIEZyLFxuICAgICAgICAgICAgRnAsXG4gICAgICAgICAgICBGcDIsXG4gICAgICAgICAgICBGcDYsXG4gICAgICAgICAgICBGcDEyLFxuICAgICAgICB9LFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGF0ZUxvb3BTaXplOiBDVVJWRS5wYXJhbXMuYXRlTG9vcFNpemUsXG4gICAgICAgICAgICByOiBDVVJWRS5wYXJhbXMucixcbiAgICAgICAgICAgIEcxYjogQ1VSVkUuRzEuYixcbiAgICAgICAgICAgIEcyYjogQ1VSVkUuRzIuYixcbiAgICAgICAgfSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/bls.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/curve.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const validateW = (W) => {\n        if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n            throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);\n    };\n    const opts = (W) => {\n        validateW(W);\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, n, transform) {\n            const W = pointWindowSizes.get(P) || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return this.wNAF(W, comp, n);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM).\n * MSM is basically (Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param field field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nfunction pippenger(c, field, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length)\n        throw new Error('arrays of points and scalars must have equal length');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error(`wrong scalar at index ${i}`);\n    });\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error(`wrong point at index ${i}`);\n    });\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(c.ZERO); // +1 for zero array\n    const lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;\n    let sum = c.ZERO;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(c.ZERO);\n        for (let j = 0; j < scalars.length; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = c.ZERO; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = c.ZERO; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3NEO0FBQ0Y7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRSxrQkFBa0IsS0FBSztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseUNBQXlDO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsRUFBRTtBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3RELEtBQUs7QUFDTCxrQkFBa0IsaURBQU07QUFDeEIsdUZBQXVGO0FBQ3ZGO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYTtBQUNqQixJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsb0RBQU87QUFDbEI7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuNi4wL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCwgYml0TGVuIH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBTaW5jZSBwb2ludHMgaW4gZGlmZmVyZW50IGdyb3VwcyBjYW5ub3QgYmUgZXF1YWwgKGRpZmZlcmVudCBvYmplY3QgY29uc3RydWN0b3IpLFxuLy8gd2UgY2FuIGhhdmUgc2luZ2xlIHBsYWNlIHRvIHN0b3JlIHByZWNvbXB1dGVzXG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHBvaW50V2luZG93U2l6ZXMgPSBuZXcgV2Vha01hcCgpOyAvLyBUaGlzIGFsbG93cyB1c2UgbWFrZSBwb2ludHMgaW1tdXRhYmxlIChub3RoaW5nIGNoYW5nZXMgaW5zaWRlKVxuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IHZhbGlkYXRlVyA9IChXKSA9PiB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoVykgfHwgVyA8PSAwIHx8IFcgPiBiaXRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyB3aW5kb3cgc2l6ZT0ke1d9LCBzaG91bGQgYmUgWzEuLiR7Yml0c31dYCk7XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgdmFsaWRhdGVXKFcpO1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBXID0gcG9pbnRXaW5kb3dTaXplcy5nZXQoUCkgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwb2ludFByZWNvbXB1dGVzLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBXZSBjYWxjdWxhdGUgcHJlY29tcHV0ZXMgZm9yIGVsbGlwdGljIGN1cnZlIHBvaW50IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIC8vIHVzaW5nIHdpbmRvd2VkIG1ldGhvZC4gVGhpcyBzcGVjaWZpZXMgd2luZG93IHNpemUgYW5kXG4gICAgICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgICAgICBzZXRXaW5kb3dTaXplKFAsIFcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlVyhXKTtcbiAgICAgICAgICAgIHBvaW50V2luZG93U2l6ZXMuc2V0KFAsIFcpO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUoUCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGlwcGVuZ2VyIGFsZ29yaXRobSBmb3IgbXVsdGktc2NhbGFyIG11bHRpcGxpY2F0aW9uIChNU00pLlxuICogTVNNIGlzIGJhc2ljYWxseSAoUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIDMweCBmYXN0ZXIgdnMgbmFpdmUgYWRkaXRpb24gb24gTD00MDk2LCAxMHggZmFzdGVyIHdpdGggcHJlY29tcHV0ZXMuXG4gKiBGb3IgTj0yNTRiaXQsIEw9MSwgaXQgZG9lczogMTAyNCBBREQgKyAyNTQgREJMLiBGb3IgTD01OiAxNTM2IEFERCArIDI1NCBEQkwuXG4gKiBBbGdvcml0aG1pY2FsbHkgY29uc3RhbnQtdGltZSAoZm9yIHNhbWUgTCksIGV2ZW4gd2hlbiAxIHBvaW50ICsgc2NhbGFyLCBvciB3aGVuIHNjYWxhciA9IDAuXG4gKiBAcGFyYW0gYyBDdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZpZWxkIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHBhcmFtIHNjYWxhcnMgYXJyYXkgb2YgTCBzY2FsYXJzIChha2EgcHJpdmF0ZSBrZXlzIC8gYmlnaW50cylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpcHBlbmdlcihjLCBmaWVsZCwgcG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgLy8gSWYgd2Ugc3BsaXQgc2NhbGFycyBieSBzb21lIHdpbmRvdyAobGV0J3Mgc2F5IDggYml0cyksIGV2ZXJ5IGNodW5rIHdpbGwgb25seVxuICAgIC8vIHRha2UgMjU2IGJ1Y2tldHMgZXZlbiBpZiB0aGVyZSBhcmUgNDA5NiBzY2FsYXJzLCBhbHNvIHJlLXVzZXMgZG91YmxlLlxuICAgIC8vIFRPRE86XG4gICAgLy8gLSBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDI0Lzc1MC5wZGZcbiAgICAvLyAtIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy8xMDI4N1xuICAgIC8vIDAgaXMgYWNjZXB0ZWQgaW4gc2NhbGFyc1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpIHx8ICFBcnJheS5pc0FycmF5KHNjYWxhcnMpIHx8IHNjYWxhcnMubGVuZ3RoICE9PSBwb2ludHMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5cyBvZiBwb2ludHMgYW5kIHNjYWxhcnMgbXVzdCBoYXZlIGVxdWFsIGxlbmd0aCcpO1xuICAgIHNjYWxhcnMuZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgICBpZiAoIWZpZWxkLmlzVmFsaWQocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdyb25nIHNjYWxhciBhdCBpbmRleCAke2l9YCk7XG4gICAgfSk7XG4gICAgcG9pbnRzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3cm9uZyBwb2ludCBhdCBpbmRleCAke2l9YCk7XG4gICAgfSk7XG4gICAgY29uc3Qgd2JpdHMgPSBiaXRMZW4oQmlnSW50KHBvaW50cy5sZW5ndGgpKTtcbiAgICBjb25zdCB3aW5kb3dTaXplID0gd2JpdHMgPiAxMiA/IHdiaXRzIC0gMyA6IHdiaXRzID4gNCA/IHdiaXRzIC0gMiA6IHdiaXRzID8gMiA6IDE7IC8vIGluIGJpdHNcbiAgICBjb25zdCBNQVNLID0gKDEgPDwgd2luZG93U2l6ZSkgLSAxO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTUFTSyArIDEpLmZpbGwoYy5aRVJPKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcbiAgICBjb25zdCBsYXN0Qml0cyA9IE1hdGguZmxvb3IoKGZpZWxkLkJJVFMgLSAxKSAvIHdpbmRvd1NpemUpICogd2luZG93U2l6ZTtcbiAgICBsZXQgc3VtID0gYy5aRVJPO1xuICAgIGZvciAobGV0IGkgPSBsYXN0Qml0czsgaSA+PSAwOyBpIC09IHdpbmRvd1NpemUpIHtcbiAgICAgICAgYnVja2V0cy5maWxsKGMuWkVSTyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2NhbGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHdiaXRzID0gTnVtYmVyKChzY2FsYXIgPj4gQmlnSW50KGkpKSAmIEJpZ0ludChNQVNLKSk7XG4gICAgICAgICAgICBidWNrZXRzW3diaXRzXSA9IGJ1Y2tldHNbd2JpdHNdLmFkZChwb2ludHNbal0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNJID0gYy5aRVJPOyAvLyBub3QgdXNpbmcgdGhpcyB3aWxsIGRvIHNtYWxsIHNwZWVkLXVwLCBidXQgd2lsbCBsb3NlIGN0XG4gICAgICAgIC8vIFNraXAgZmlyc3QgYnVja2V0LCBiZWNhdXNlIGl0IGlzIHplcm9cbiAgICAgICAgZm9yIChsZXQgaiA9IGJ1Y2tldHMubGVuZ3RoIC0gMSwgc3VtSSA9IGMuWkVSTzsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xuICAgICAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHN1bS5hZGQocmVzSSk7XG4gICAgICAgIGlmIChpICE9PSAwKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgc3VtID0gc3VtLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/edwards.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twistedEdwards: () => (/* binding */ twistedEdwards)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²\n\n\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nfunction twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(CURVE.n, CURVE.nBitLength);\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abool)('phflag', phflag);\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    // 0 <= n < MASK\n    // Coordinates larger than Fp.ORDER are allowed for zip215\n    function aCoordinate(title, n) {\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange('coordinate ' + title, n, _0n, MASK);\n    }\n    function assertPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized)((p, iz) => {\n        const { ex: x, ey: y, ez: z } = p;\n        const is0 = p.is0();\n        if (iz == null)\n            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n        const ax = modP(x * iz);\n        const ay = modP(y * iz);\n        const zz = modP(z * iz);\n        if (is0)\n            return { x: _0n, y: _1n };\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized)((p) => {\n        const { a, d } = CURVE;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { ex: X, ey: Y, ez: Z, et: T } = p;\n        const X2 = modP(X * X); // X²\n        const Y2 = modP(Y * Y); // Y²\n        const Z2 = modP(Z * Z); // Z²\n        const Z4 = modP(Z2 * Z2); // Z⁴\n        const aX2 = modP(X2 * a); // aX²\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return true;\n    });\n    // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            aCoordinate('x', ex);\n            aCoordinate('y', ey);\n            aCoordinate('z', ez);\n            aCoordinate('t', et);\n            Object.freeze(this);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            aCoordinate('x', x);\n            aCoordinate('y', y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            assertPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            assertPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const n = scalar;\n            _utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n            const { p, f } = this.wNAF(n);\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            const n = scalar;\n            _utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n            if (n === _0n)\n                return I;\n            if (this.equals(I) || n === _1n)\n                return this;\n            if (this.equals(G))\n                return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex, len); // copy hex to a new array\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abool)('zip215', zip215);\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(normed);\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            _utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange('pointHex.y', y, _0n, max);\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, nByteLength * 8);\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n        const res = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(R, _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(s, Fp.BYTES));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('result', res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (zip215 !== undefined)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abool)('zip215', zip215);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvZWR3YXJkcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUM2RDtBQUNuQjtBQUNUO0FBQ3lCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxrQ0FBa0Msa0NBQWtDO0FBQ3BFO0FBQ087QUFDUDtBQUNBLFlBQVksNEZBQTRGO0FBQ3hHO0FBQ0EsNEJBQTRCO0FBQzVCLGVBQWUsa0RBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLFlBQVksZ0RBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBUTtBQUNqQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0wsNEJBQTRCLG1EQUFRO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsZ0RBQWdEO0FBQ2hELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0Msb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEIsb0JBQW9CLHlCQUF5QjtBQUM3QyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLGlEQUFpRDtBQUNqRCxtQ0FBbUM7QUFDbkM7QUFDQSx1REFBdUQ7QUFDdkQsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0Isb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLGlDQUFpQztBQUNyRCxvQkFBb0IsaUNBQWlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyx5Q0FBeUM7QUFDekMscUNBQXFDO0FBQ3JDLDJEQUEyRDtBQUMzRCw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLHVDQUF1QztBQUN2QyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQVcsaUNBQWlDO0FBQ3hELG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFXLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLGtCQUFrQixzREFBVyx3QkFBd0I7QUFDckQsWUFBWSxnREFBSztBQUNqQix3Q0FBd0M7QUFDeEMsMkNBQTJDO0FBQzNDLGdEQUFnRDtBQUNoRCxzQkFBc0Isc0RBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBVztBQUN2QjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0Qyx3Q0FBd0M7QUFDeEMsa0JBQWtCLG9CQUFvQixpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBLDhDQUE4QztBQUM5QywyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLDBCQUEwQixzREFBa0IsZUFBZTtBQUMzRCwyREFBMkQ7QUFDM0QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWEscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxZQUFZLG1CQUFtQjtBQUMvQixpQkFBaUIsK0NBQUk7QUFDckI7QUFDQSxlQUFlLGdEQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFXO0FBQ3pCO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQVc7QUFDbEMsOERBQThEO0FBQzlELG1EQUFtRDtBQUNuRCxzQ0FBc0M7QUFDdEMsMENBQTBDO0FBQzFDLCtDQUErQztBQUMvQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQWM7QUFDbEMseUNBQXlDLHNEQUFXO0FBQ3BEO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsY0FBYyxzREFBVztBQUN6QjtBQUNBLGdDQUFnQztBQUNoQyxnQkFBZ0IsNkJBQTZCO0FBQzdDLG9FQUFvRTtBQUNwRSw4Q0FBOEM7QUFDOUMsMkVBQTJFO0FBQzNFLHdDQUF3QztBQUN4QyxRQUFRLCtDQUFXLHNDQUFzQztBQUN6RCxvQkFBb0Isa0RBQWMsSUFBSSxzREFBa0I7QUFDeEQsZUFBZSxzREFBVyxrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyw4QkFBOEI7QUFDOUIsY0FBYyxzREFBVyw2QkFBNkI7QUFDdEQsY0FBYyxzREFBVztBQUN6QjtBQUNBLFlBQVksZ0RBQUs7QUFDakI7QUFDQSxnQ0FBZ0M7QUFDaEMsa0JBQWtCLHNEQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvZWR3YXJkcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBUd2lzdGVkIEVkd2FyZHMgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbmltcG9ydCB7IHZhbGlkYXRlQmFzaWMsIHdOQUYsIHBpcHBlbmdlciwgfSBmcm9tICcuL2N1cnZlLmpzJztcbmltcG9ydCB7IG1vZCwgRmllbGQgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcywgbWVtb2l6ZWQsIGFib29sIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzhuID0gQmlnSW50KDgpO1xuLy8gdmVyaWZpY2F0aW9uIHJ1bGUgaXMgZWl0aGVyIHppcDIxNSBvciByZmM4MDMyIC8gbmlzdDE4Ni01LiBDb25zdWx0IGZyb21IZXg6XG5jb25zdCBWRVJJRllfREVGQVVMVCA9IHsgemlwMjE1OiB0cnVlIH07XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgaGFzaDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYTogJ2JpZ2ludCcsXG4gICAgICAgIGQ6ICdiaWdpbnQnLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGFkanVzdFNjYWxhckJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICAgIHV2UmF0aW86ICdmdW5jdGlvbicsXG4gICAgICAgIG1hcFRvQ3VydmU6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIEVkRFNBIHNpZ25hdHVyZXMuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRmllbGQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuICogLy8gQmVmb3JlIHRoYXQsIGRlZmluZSBCaWdJbnQtczogYSwgZCwgcCwgbiwgR3gsIEd5LCBoXG4gKiBjb25zdCBjdXJ2ZSA9IHR3aXN0ZWRFZHdhcmRzKHsgYSwgZCwgRnA6IEZpZWxkKHApLCBuLCBHeCwgR3ksIGggfSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR3aXN0ZWRFZHdhcmRzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSLCBwcmVoYXNoOiBwcmVoYXNoLCBoYXNoOiBjSGFzaCwgcmFuZG9tQnl0ZXMsIG5CeXRlTGVuZ3RoLCBoOiBjb2ZhY3RvciwgfSA9IENVUlZFO1xuICAgIGNvbnN0IE1BU0sgPSBfMm4gPDwgKEJpZ0ludChuQnl0ZUxlbmd0aCAqIDgpIC0gXzFuKTtcbiAgICBjb25zdCBtb2RQID0gRnAuY3JlYXRlOyAvLyBGdW5jdGlvbiBvdmVycmlkZXNcbiAgICBjb25zdCBGbiA9IEZpZWxkKENVUlZFLm4sIENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIC8vIHNxcnQodS92KVxuICAgIGNvbnN0IHV2UmF0aW8gPSBDVVJWRS51dlJhdGlvIHx8XG4gICAgICAgICgodSwgdikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCB2YWx1ZTogRnAuc3FydCh1ICogRnAuaW52KHYpKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgdmFsdWU6IF8wbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBjb25zdCBhZGp1c3RTY2FsYXJCeXRlcyA9IENVUlZFLmFkanVzdFNjYWxhckJ5dGVzIHx8ICgoYnl0ZXMpID0+IGJ5dGVzKTsgLy8gTk9PUFxuICAgIGNvbnN0IGRvbWFpbiA9IENVUlZFLmRvbWFpbiB8fFxuICAgICAgICAoKGRhdGEsIGN0eCwgcGhmbGFnKSA9PiB7XG4gICAgICAgICAgICBhYm9vbCgncGhmbGFnJywgcGhmbGFnKTtcbiAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoIHx8IHBoZmxhZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHRzL3ByZS1oYXNoIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7IC8vIE5PT1BcbiAgICAvLyAwIDw9IG4gPCBNQVNLXG4gICAgLy8gQ29vcmRpbmF0ZXMgbGFyZ2VyIHRoYW4gRnAuT1JERVIgYXJlIGFsbG93ZWQgZm9yIHppcDIxNVxuICAgIGZ1bmN0aW9uIGFDb29yZGluYXRlKHRpdGxlLCBuKSB7XG4gICAgICAgIHV0LmFJblJhbmdlKCdjb29yZGluYXRlICcgKyB0aXRsZSwgbiwgXzBuLCBNQVNLKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0UG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuZGVkUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLy8gQ29udmVydHMgRXh0ZW5kZWQgcG9pbnQgdG8gZGVmYXVsdCAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgY29uc3QgdG9BZmZpbmVNZW1vID0gbWVtb2l6ZWQoKHAsIGl6KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZXg6IHgsIGV5OiB5LCBlejogeiB9ID0gcDtcbiAgICAgICAgY29uc3QgaXMwID0gcC5pczAoKTtcbiAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICBpeiA9IGlzMCA/IF84biA6IEZwLmludih6KTsgLy8gOCB3YXMgY2hvc2VuIGFyYml0cmFyaWx5XG4gICAgICAgIGNvbnN0IGF4ID0gbW9kUCh4ICogaXopO1xuICAgICAgICBjb25zdCBheSA9IG1vZFAoeSAqIGl6KTtcbiAgICAgICAgY29uc3QgenogPSBtb2RQKHogKiBpeik7XG4gICAgICAgIGlmIChpczApXG4gICAgICAgICAgICByZXR1cm4geyB4OiBfMG4sIHk6IF8xbiB9O1xuICAgICAgICBpZiAoenogIT09IF8xbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICB9KTtcbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocCkgPT4ge1xuICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICBpZiAocC5pczAoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7IC8vIFRPRE86IG9wdGltaXplLCB3aXRoIHZhcnMgYmVsb3c/XG4gICAgICAgIC8vIEVxdWF0aW9uIGluIGFmZmluZSBjb29yZGluYXRlczogYXjCsiArIHnCsiA9IDEgKyBkeMKyecKyXG4gICAgICAgIC8vIEVxdWF0aW9uIGluIHByb2plY3RpdmUgY29vcmRpbmF0ZXMgKFgvWiwgWS9aLCBaKTogIChhWMKyICsgWcKyKVrCsiA9IFrigbQgKyBkWMKyWcKyXG4gICAgICAgIGNvbnN0IHsgZXg6IFgsIGV5OiBZLCBlejogWiwgZXQ6IFQgfSA9IHA7XG4gICAgICAgIGNvbnN0IFgyID0gbW9kUChYICogWCk7IC8vIFjCslxuICAgICAgICBjb25zdCBZMiA9IG1vZFAoWSAqIFkpOyAvLyBZwrJcbiAgICAgICAgY29uc3QgWjIgPSBtb2RQKFogKiBaKTsgLy8gWsKyXG4gICAgICAgIGNvbnN0IFo0ID0gbW9kUChaMiAqIFoyKTsgLy8gWuKBtFxuICAgICAgICBjb25zdCBhWDIgPSBtb2RQKFgyICogYSk7IC8vIGFYwrJcbiAgICAgICAgY29uc3QgbGVmdCA9IG1vZFAoWjIgKiBtb2RQKGFYMiArIFkyKSk7IC8vIChhWMKyICsgWcKyKVrCslxuICAgICAgICBjb25zdCByaWdodCA9IG1vZFAoWjQgKyBtb2RQKGQgKiBtb2RQKFgyICogWTIpKSk7IC8vIFrigbQgKyBkWMKyWcKyXG4gICAgICAgIGlmIChsZWZ0ICE9PSByaWdodClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgxKScpO1xuICAgICAgICAvLyBJbiBFeHRlbmRlZCBjb29yZGluYXRlcyB3ZSBhbHNvIGhhdmUgVCwgd2hpY2ggaXMgeCp5PVQvWjogY2hlY2sgWCpZID09IFoqVFxuICAgICAgICBjb25zdCBYWSA9IG1vZFAoWCAqIFkpO1xuICAgICAgICBjb25zdCBaVCA9IG1vZFAoWiAqIFQpO1xuICAgICAgICBpZiAoWFkgIT09IFpUKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQgKDIpJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIC8vIEV4dGVuZGVkIFBvaW50IHdvcmtzIGluIGV4dGVuZGVkIGNvb3JkaW5hdGVzOiAoeCwgeSwgeiwgdCkg4oiLICh4PXgveiwgeT15L3osIHQ9eHkpLlxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3aXN0ZWRfRWR3YXJkc19jdXJ2ZSNFeHRlbmRlZF9jb29yZGluYXRlc1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoZXgsIGV5LCBleiwgZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZXggPSBleDtcbiAgICAgICAgICAgIHRoaXMuZXkgPSBleTtcbiAgICAgICAgICAgIHRoaXMuZXogPSBlejtcbiAgICAgICAgICAgIHRoaXMuZXQgPSBldDtcbiAgICAgICAgICAgIGFDb29yZGluYXRlKCd4JywgZXgpO1xuICAgICAgICAgICAgYUNvb3JkaW5hdGUoJ3knLCBleSk7XG4gICAgICAgICAgICBhQ29vcmRpbmF0ZSgneicsIGV6KTtcbiAgICAgICAgICAgIGFDb29yZGluYXRlKCd0JywgZXQpO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5kZWQgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGFDb29yZGluYXRlKCd4JywgeCk7XG4gICAgICAgICAgICBhQ29vcmRpbmF0ZSgneScsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBfMW4sIG1vZFAoeCAqIHkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5leikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXBwZW5nZXIoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgcmVxdWlyZWQgZm9yIGZyb21IZXgoKSwgd2hpY2ggYWx3YXlzIGNyZWF0ZXMgdmFsaWQgcG9pbnRzLlxuICAgICAgICAvLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGZyb21BZmZpbmUoKS5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBhc3NlcnRWYWxpZE1lbW8odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMiwgZXk6IFkyLCBlejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgWDFaMiA9IG1vZFAoWDEgKiBaMik7XG4gICAgICAgICAgICBjb25zdCBYMloxID0gbW9kUChYMiAqIFoxKTtcbiAgICAgICAgICAgIGNvbnN0IFkxWjIgPSBtb2RQKFkxICogWjIpO1xuICAgICAgICAgICAgY29uc3QgWTJaMSA9IG1vZFAoWTIgKiBaMSk7XG4gICAgICAgICAgICByZXR1cm4gWDFaMiA9PT0gWDJaMSAmJiBZMVoyID09PSBZMloxO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICAvLyBGbGlwcyBwb2ludCBzaWduIHRvIGEgbmVnYXRpdmUgb25lICgteCwgeSBpbiBhZmZpbmUgY29vcmRzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChtb2RQKC10aGlzLmV4KSwgdGhpcy5leSwgdGhpcy5leiwgbW9kUCgtdGhpcy5ldCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhc3QgYWxnbyBmb3IgZG91YmxpbmcgRXh0ZW5kZWQgUG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQuaHRtbCNkb3VibGluZy1kYmwtMjAwOC1od2NkXG4gICAgICAgIC8vIENvc3Q6IDRNICsgNFMgKyAxKmEgKyA2YWRkICsgMSoyLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoWDEgKiBYMSk7IC8vIEEgPSBYMTJcbiAgICAgICAgICAgIGNvbnN0IEIgPSBtb2RQKFkxICogWTEpOyAvLyBCID0gWTEyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChfMm4gKiBtb2RQKFoxICogWjEpKTsgLy8gQyA9IDIqWjEyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChhICogQSk7IC8vIEQgPSBhKkFcbiAgICAgICAgICAgIGNvbnN0IHgxeTEgPSBYMSArIFkxO1xuICAgICAgICAgICAgY29uc3QgRSA9IG1vZFAobW9kUCh4MXkxICogeDF5MSkgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpMi1BLUJcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQjsgLy8gRyA9IEQrQlxuICAgICAgICAgICAgY29uc3QgRiA9IEcgLSBDOyAvLyBGID0gRy1DXG4gICAgICAgICAgICBjb25zdCBIID0gRCAtIEI7IC8vIEggPSBELUJcbiAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7IC8vIFgzID0gRSpGXG4gICAgICAgICAgICBjb25zdCBZMyA9IG1vZFAoRyAqIEgpOyAvLyBZMyA9IEcqSFxuICAgICAgICAgICAgY29uc3QgVDMgPSBtb2RQKEUgKiBIKTsgLy8gVDMgPSBFKkhcbiAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7IC8vIFozID0gRipHXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMsIFQzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYXN0IGFsZ28gZm9yIGFkZGluZyAyIEV4dGVuZGVkIFBvaW50cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2RcbiAgICAgICAgLy8gQ29zdDogOU0gKyAxKmEgKyAxKmQgKyA3YWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEsIGV0OiBUMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIsIGV6OiBaMiwgZXQ6IFQyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIC8vIEZhc3RlciBhbGdvIGZvciBhZGRpbmcgMiBFeHRlbmRlZCBQb2ludHMgd2hlbiBjdXJ2ZSdzIGE9LTEuXG4gICAgICAgICAgICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtNFxuICAgICAgICAgICAgLy8gQ29zdDogOE0gKyA4YWRkICsgMioyLlxuICAgICAgICAgICAgLy8gTm90ZTogSXQgZG9lcyBub3QgY2hlY2sgd2hldGhlciB0aGUgYG90aGVyYCBwb2ludCBpcyB2YWxpZC5cbiAgICAgICAgICAgIGlmIChhID09PSBCaWdJbnQoLTEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoKFkxIC0gWDEpICogKFkyICsgWDIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBCID0gbW9kUCgoWTEgKyBYMSkgKiAoWTIgLSBYMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEYgPSBtb2RQKEIgLSBBKTtcbiAgICAgICAgICAgICAgICBpZiAoRiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb3VibGUoKTsgLy8gU2FtZSBwb2ludC4gVGVzdHMgc2F5IGl0IGRvZXNuJ3QgYWZmZWN0IHRpbWluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKFoxICogXzJuICogVDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKFQxICogXzJuICogWjIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEUgPSBEICsgQztcbiAgICAgICAgICAgICAgICBjb25zdCBHID0gQiArIEE7XG4gICAgICAgICAgICAgICAgY29uc3QgSCA9IEQgLSBDO1xuICAgICAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7XG4gICAgICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTtcbiAgICAgICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgyKTsgLy8gQSA9IFgxKlgyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkyKTsgLy8gQiA9IFkxKlkyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChUMSAqIGQgKiBUMik7IC8vIEMgPSBUMSpkKlQyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChaMSAqIFoyKTsgLy8gRCA9IFoxKloyXG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUCgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpKihYMitZMiktQS1CXG4gICAgICAgICAgICBjb25zdCBGID0gRCAtIEM7IC8vIEYgPSBELUNcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQzsgLy8gRyA9IEQrQ1xuICAgICAgICAgICAgY29uc3QgSCA9IG1vZFAoQiAtIGEgKiBBKTsgLy8gSCA9IEItYSpBXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIG4sIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdzY2FsYXInLCBuLCBfMW4sIENVUlZFX09SREVSKTsgLy8gMSA8PSBzY2FsYXIgPCBMXG4gICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwLCBmXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAvLyBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAvLyBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbi5cbiAgICAgICAgLy8gRG9lcyBOT1QgYWxsb3cgc2NhbGFycyBoaWdoZXIgdGhhbiBDVVJWRS5uLlxuICAgICAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgbiwgXzBuLCBDVVJWRV9PUkRFUik7IC8vIDAgPD0gc2NhbGFyIDwgTFxuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFscyhJKSB8fCBuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHMoRykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihuKS5wO1xuICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrcyBpZiBwb2ludCBpcyBvZiBzbWFsbCBvcmRlci5cbiAgICAgICAgLy8gSWYgeW91IGFkZCBzb21ldGhpbmcgdG8gc21hbGwgb3JkZXIgcG9pbnQsIHlvdSB3aWxsIGhhdmUgXCJkaXJ0eVwiXG4gICAgICAgIC8vIHBvaW50IHdpdGggdG9yc2lvbiBjb21wb25lbnQuXG4gICAgICAgIC8vIE11bHRpcGxpZXMgcG9pbnQgYnkgY29mYWN0b3IgYW5kIGNoZWNrcyBpZiB0aGUgcmVzdWx0IGlzIDAuXG4gICAgICAgIGlzU21hbGxPcmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGN1cnZlIG9yZGVyIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICAvLyBSZXR1cm5zIGBmYWxzZWAgaXMgdGhlIHBvaW50IGlzIGRpcnR5LlxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIENVUlZFX09SREVSKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICByZXR1cm4gdG9BZmZpbmVNZW1vKHRoaXMsIGl6KTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAvLyBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgsIHppcDIxNSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGQsIGEgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7XG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgsIGxlbik7IC8vIGNvcHkgaGV4IHRvIGEgbmV3IGFycmF5XG4gICAgICAgICAgICBhYm9vbCgnemlwMjE1JywgemlwMjE1KTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1lZCA9IGhleC5zbGljZSgpOyAvLyBjb3B5IGFnYWluLCB3ZSdsbCBtYW5pcHVsYXRlIGl0XG4gICAgICAgICAgICBjb25zdCBsYXN0Qnl0ZSA9IGhleFtsZW4gLSAxXTsgLy8gc2VsZWN0IGxhc3QgYnl0ZVxuICAgICAgICAgICAgbm9ybWVkW2xlbiAtIDFdID0gbGFzdEJ5dGUgJiB+MHg4MDsgLy8gY2xlYXIgbGFzdCBiaXRcbiAgICAgICAgICAgIGNvbnN0IHkgPSB1dC5ieXRlc1RvTnVtYmVyTEUobm9ybWVkKTtcbiAgICAgICAgICAgIC8vIFJGQzgwMzIgcHJvaGliaXRzID49IHAsIGJ1dCBaSVAyMTUgZG9lc24ndFxuICAgICAgICAgICAgLy8gemlwMjE1PXRydWU6ICAwIDw9IHkgPCBNQVNLICgyXjI1NiBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgIC8vIHppcDIxNT1mYWxzZTogMCA8PSB5IDwgUCAoMl4yNTUtMTkgZm9yIGVkMjU1MTkpXG4gICAgICAgICAgICBjb25zdCBtYXggPSB6aXAyMTUgPyBNQVNLIDogRnAuT1JERVI7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgncG9pbnRIZXgueScsIHksIF8wbiwgbWF4KTtcbiAgICAgICAgICAgIC8vIEVkMjU1MTk6IHjCsiA9ICh5wrItMSkvKGR5wrIrMSkgbW9kIHAuIEVkNDQ4OiB4wrIgPSAoecKyLTEpLyhkecKyLTEpIG1vZCBwLiBHZW5lcmljIGNhc2U6XG4gICAgICAgICAgICAvLyBheMKyK3nCsj0xK2R4wrJ5wrIgPT4gecKyLTE9ZHjCsnnCsi1heMKyID0+IHnCsi0xPXjCsihkecKyLWEpID0+IHjCsj0oecKyLTEpLyhkecKyLWEpXG4gICAgICAgICAgICBjb25zdCB5MiA9IG1vZFAoeSAqIHkpOyAvLyBkZW5vbWluYXRvciBpcyBhbHdheXMgbm9uLTAgbW9kIHAuXG4gICAgICAgICAgICBjb25zdCB1ID0gbW9kUCh5MiAtIF8xbik7IC8vIHUgPSB5wrIgLSAxXG4gICAgICAgICAgICBjb25zdCB2ID0gbW9kUChkICogeTIgLSBhKTsgLy8gdiA9IGQgecKyICsgMS5cbiAgICAgICAgICAgIGxldCB7IGlzVmFsaWQsIHZhbHVlOiB4IH0gPSB1dlJhdGlvKHUsIHYpOyAvLyDiiJoodS92KVxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQuZnJvbUhleDogaW52YWxpZCB5IGNvb3JkaW5hdGUnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzWE9kZCA9ICh4ICYgXzFuKSA9PT0gXzFuOyAvLyBUaGVyZSBhcmUgMiBzcXVhcmUgcm9vdHMuIFVzZSB4XzAgYml0IHRvIHNlbGVjdCBwcm9wZXJcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdEJ5dGVPZGQgPSAobGFzdEJ5dGUgJiAweDgwKSAhPT0gMDsgLy8geF8wLCBsYXN0IGJpdFxuICAgICAgICAgICAgaWYgKCF6aXAyMTUgJiYgeCA9PT0gXzBuICYmIGlzTGFzdEJ5dGVPZGQpXG4gICAgICAgICAgICAgICAgLy8gaWYgeD0wIGFuZCB4XzAgPSAxLCBmYWlsXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludC5mcm9tSGV4OiB4PTAgYW5kIHhfMD0xJyk7XG4gICAgICAgICAgICBpZiAoaXNMYXN0Qnl0ZU9kZCAhPT0gaXNYT2RkKVxuICAgICAgICAgICAgICAgIHggPSBtb2RQKC14KTsgLy8gaWYgeF8wICE9IHggbW9kIDIsIHNldCB4ID0gcC14XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZSh7IHgsIHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2S2V5KS5wb2ludDtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IHV0Lm51bWJlclRvQnl0ZXNMRSh5LCBGcC5CWVRFUyk7IC8vIGVhY2ggeSBoYXMgMiB4IHZhbHVlcyAoeCwgLXkpXG4gICAgICAgICAgICBieXRlc1tieXRlcy5sZW5ndGggLSAxXSB8PSB4ICYgXzFuID8gMHg4MCA6IDA7IC8vIHdoZW4gY29tcHJlc3NpbmcsIGl0J3MgZW5vdWdoIHRvIHN0b3JlIHlcbiAgICAgICAgICAgIHJldHVybiBieXRlczsgLy8gYW5kIHVzZSB0aGUgbGFzdCBieXRlIHRvIGVuY29kZSBzaWduIG9mIHhcbiAgICAgICAgfVxuICAgICAgICB0b0hleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcygpKTsgLy8gU2FtZSBhcyB0b1Jhd0J5dGVzLCBidXQgcmV0dXJucyBzdHJpbmcuXG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIF8xbiwgbW9kUChDVVJWRS5HeCAqIENVUlZFLkd5KSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChfMG4sIF8xbiwgXzFuLCBfMG4pOyAvLyAwLCAxLCAxLCAwXG4gICAgY29uc3QgeyBCQVNFOiBHLCBaRVJPOiBJIH0gPSBQb2ludDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgbkJ5dGVMZW5ndGggKiA4KTtcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIC8vIExpdHRsZS1lbmRpYW4gU0hBNTEyIHdpdGggbW9kdWxvIG5cbiAgICBmdW5jdGlvbiBtb2ROX0xFKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIG1vZE4odXQuYnl0ZXNUb051bWJlckxFKGhhc2gpKTtcbiAgICB9XG4gICAgLyoqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNyZWF0ZXMgcHVibGljIGtleSBhbmQgb3RoZXIgc3R1ZmYuIFJGQzgwMzIgNS4xLjUgKi9cbiAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZFB1YmxpY0tleShrZXkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbkJ5dGVMZW5ndGg7XG4gICAgICAgIGtleSA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbGVuKTtcbiAgICAgICAgLy8gSGFzaCBwcml2YXRlIGtleSB3aXRoIGN1cnZlJ3MgaGFzaCBmdW5jdGlvbiB0byBwcm9kdWNlIHVuaWZvcm1pbmdseSByYW5kb20gaW5wdXRcbiAgICAgICAgLy8gQ2hlY2sgYnl0ZSBsZW5ndGhzOiBlbnN1cmUoNjQsIGgoZW5zdXJlKDMyLCBrZXkpKSlcbiAgICAgICAgY29uc3QgaGFzaGVkID0gZW5zdXJlQnl0ZXMoJ2hhc2hlZCBwcml2YXRlIGtleScsIGNIYXNoKGtleSksIDIgKiBsZW4pO1xuICAgICAgICBjb25zdCBoZWFkID0gYWRqdXN0U2NhbGFyQnl0ZXMoaGFzaGVkLnNsaWNlKDAsIGxlbikpOyAvLyBjbGVhciBmaXJzdCBoYWxmIGJpdHMsIHByb2R1Y2UgRkVcbiAgICAgICAgY29uc3QgcHJlZml4ID0gaGFzaGVkLnNsaWNlKGxlbiwgMiAqIGxlbik7IC8vIHNlY29uZCBoYWxmIGlzIGNhbGxlZCBrZXkgcHJlZml4ICg1LjEuNilcbiAgICAgICAgY29uc3Qgc2NhbGFyID0gbW9kTl9MRShoZWFkKTsgLy8gVGhlIGFjdHVhbCBwcml2YXRlIHNjYWxhclxuICAgICAgICBjb25zdCBwb2ludCA9IEcubXVsdGlwbHkoc2NhbGFyKTsgLy8gUG9pbnQgb24gRWR3YXJkcyBjdXJ2ZSBha2EgcHVibGljIGtleVxuICAgICAgICBjb25zdCBwb2ludEJ5dGVzID0gcG9pbnQudG9SYXdCeXRlcygpOyAvLyBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uXG4gICAgICAgIHJldHVybiB7IGhlYWQsIHByZWZpeCwgc2NhbGFyLCBwb2ludCwgcG9pbnRCeXRlcyB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGVzIEVkRFNBIHB1YiBrZXkuIFJGQzgwMzIgNS4xLjUuIFByaXZrZXkgaXMgaGFzaGVkLiBVc2UgZmlyc3QgaGFsZiB3aXRoIDMgYml0cyBjbGVhcmVkXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZLZXkpIHtcbiAgICAgICAgcmV0dXJuIGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpLnBvaW50Qnl0ZXM7XG4gICAgfVxuICAgIC8vIGludCgnTEUnLCBTSEE1MTIoZG9tMihGLCBDKSB8fCBtc2dzKSkgbW9kIE5cbiAgICBmdW5jdGlvbiBoYXNoRG9tYWluVG9TY2FsYXIoY29udGV4dCA9IG5ldyBVaW50OEFycmF5KCksIC4uLm1zZ3MpIHtcbiAgICAgICAgY29uc3QgbXNnID0gdXQuY29uY2F0Qnl0ZXMoLi4ubXNncyk7XG4gICAgICAgIHJldHVybiBtb2ROX0xFKGNIYXNoKGRvbWFpbihtc2csIGVuc3VyZUJ5dGVzKCdjb250ZXh0JywgY29udGV4dCksICEhcHJlaGFzaCkpKTtcbiAgICB9XG4gICAgLyoqIFNpZ25zIG1lc3NhZ2Ugd2l0aCBwcml2YXRlS2V5LiBSRkM4MDMyIDUuMS42ICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2csIHByaXZLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBtc2cgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1zZyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnID0gcHJlaGFzaChtc2cpOyAvLyBmb3IgZWQyNTUxOXBoIGV0Yy5cbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHNjYWxhciwgcG9pbnRCeXRlcyB9ID0gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdktleSk7XG4gICAgICAgIGNvbnN0IHIgPSBoYXNoRG9tYWluVG9TY2FsYXIob3B0aW9ucy5jb250ZXh0LCBwcmVmaXgsIG1zZyk7IC8vIHIgPSBkb20yKEYsIEMpIHx8IHByZWZpeCB8fCBQSChNKVxuICAgICAgICBjb25zdCBSID0gRy5tdWx0aXBseShyKS50b1Jhd0J5dGVzKCk7IC8vIFIgPSByR1xuICAgICAgICBjb25zdCBrID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgUiwgcG9pbnRCeXRlcywgbXNnKTsgLy8gUiB8fCBBIHx8IFBIKE0pXG4gICAgICAgIGNvbnN0IHMgPSBtb2ROKHIgKyBrICogc2NhbGFyKTsgLy8gUyA9IChyICsgayAqIHMpIG1vZCBMXG4gICAgICAgIHV0LmFJblJhbmdlKCdzaWduYXR1cmUucycsIHMsIF8wbiwgQ1VSVkVfT1JERVIpOyAvLyAwIDw9IHMgPCBsXG4gICAgICAgIGNvbnN0IHJlcyA9IHV0LmNvbmNhdEJ5dGVzKFIsIHV0Lm51bWJlclRvQnl0ZXNMRShzLCBGcC5CWVRFUykpO1xuICAgICAgICByZXR1cm4gZW5zdXJlQnl0ZXMoJ3Jlc3VsdCcsIHJlcywgbkJ5dGVMZW5ndGggKiAyKTsgLy8gNjQtYnl0ZSBzaWduYXR1cmVcbiAgICB9XG4gICAgY29uc3QgdmVyaWZ5T3B0cyA9IFZFUklGWV9ERUZBVUxUO1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5LCBvcHRpb25zID0gdmVyaWZ5T3B0cykge1xuICAgICAgICBjb25zdCB7IGNvbnRleHQsIHppcDIxNSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7IC8vIFZlcmlmaWVzIEVkRFNBIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuIFJGQzgwMzIgNS4xLjcuXG4gICAgICAgIHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWcsIDIgKiBsZW4pOyAvLyBBbiBleHRlbmRlZCBncm91cCBlcXVhdGlvbiBpcyBjaGVja2VkLlxuICAgICAgICBtc2cgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1zZyk7XG4gICAgICAgIGlmICh6aXAyMTUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGFib29sKCd6aXAyMTUnLCB6aXAyMTUpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZyA9IHByZWhhc2gobXNnKTsgLy8gZm9yIGVkMjU1MTlwaCwgZXRjXG4gICAgICAgIGNvbnN0IHMgPSB1dC5ieXRlc1RvTnVtYmVyTEUoc2lnLnNsaWNlKGxlbiwgMiAqIGxlbikpO1xuICAgICAgICAvLyB6aXAyMTU6IHRydWUgaXMgZ29vZCBmb3IgY29uc2Vuc3VzLWNyaXRpY2FsIGFwcHMgYW5kIGFsbG93cyBwb2ludHMgPCAyXjI1NlxuICAgICAgICAvLyB6aXAyMTU6IGZhbHNlIGZvbGxvd3MgUkZDODAzMiAvIE5JU1QxODYtNSBhbmQgcmVzdHJpY3RzIHBvaW50cyB0byBDVVJWRS5wXG4gICAgICAgIGxldCBBLCBSLCBTQjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEEgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSwgemlwMjE1KTtcbiAgICAgICAgICAgIFIgPSBQb2ludC5mcm9tSGV4KHNpZy5zbGljZSgwLCBsZW4pLCB6aXAyMTUpO1xuICAgICAgICAgICAgU0IgPSBHLm11bHRpcGx5VW5zYWZlKHMpOyAvLyAwIDw9IHMgPCBsIGlzIGRvbmUgaW5zaWRlXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6aXAyMTUgJiYgQS5pc1NtYWxsT3JkZXIoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihjb250ZXh0LCBSLnRvUmF3Qnl0ZXMoKSwgQS50b1Jhd0J5dGVzKCksIG1zZyk7XG4gICAgICAgIGNvbnN0IFJrQSA9IFIuYWRkKEEubXVsdGlwbHlVbnNhZmUoaykpO1xuICAgICAgICAvLyBbOF1bU11CID0gWzhdUiArIFs4XVtrXUEnXG4gICAgICAgIHJldHVybiBSa0Euc3VidHJhY3QoU0IpLmNsZWFyQ29mYWN0b3IoKS5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgfVxuICAgIEcuX3NldFdpbmRvd1NpemUoOCk7IC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgZ2V0RXh0ZW5kZWRQdWJsaWNLZXksXG4gICAgICAgIC8vIGVkMjU1MTkgcHJpdmF0ZSBrZXlzIGFyZSB1bmlmb3JtIDMyYi4gTm8gbmVlZCB0byBjaGVjayBmb3IgbW9kdWxvIGJpYXMsIGxpa2UgaW4gc2VjcDI1NmsxLlxuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiByYW5kb21CeXRlcyhGcC5CWVRFUyksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSdyZSBkb2luZyBzY2FsYXIgbXVsdGlwbGljYXRpb24gKHVzZWQgaW4gZ2V0UHVibGljS2V5IGV0Yykgd2l0aCBwcmVjb21wdXRlZCBCQVNFX1BPSU5UXG4gICAgICAgICAqIHZhbHVlcy4gVGhpcyBzbG93cyBkb3duIGZpcnN0IGdldFB1YmxpY0tleSgpIGJ5IG1pbGxpc2Vjb25kcyAoc2VlIFNwZWVkIHNlY3Rpb24pLFxuICAgICAgICAgKiBidXQgYWxsb3dzIHRvIHNwZWVkLXVwIHN1YnNlcXVlbnQgZ2V0UHVibGljS2V5KCkgY2FsbHMgdXAgdG8gMjB4LlxuICAgICAgICAgKiBAcGFyYW0gd2luZG93U2l6ZSAyLCA0LCA4LCAxNlxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIEV4dGVuZGVkUG9pbnQ6IFBvaW50LFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWR3YXJkcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/edwards.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQzREO0FBQy9GO0FBQ0EsY0FBYyxzREFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU8sU0FBUyxPQUFPO0FBQ3hFO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckMsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVcsQ0FBQyxzREFBVztBQUN2QyxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQVc7QUFDakM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0IsYUFBYSxzREFBVztBQUN4QixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBLGlCQUFpQixzREFBVztBQUM1QjtBQUNBLGdDQUFnQyxzREFBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sU0FBUyxzREFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBNkU7QUFDakc7QUFDQTtBQUNPO0FBQ1AsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksbUNBQW1DO0FBQy9DLElBQUksaURBQU07QUFDVjtBQUNBLDJDQUEyQyxzREFBVztBQUN0RDtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQUNqRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixHQUFHO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYWJ5dGVzLCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcywgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5jb25zdCBvczJpcCA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgYW51bSh2YWx1ZSk7XG4gICAgYW51bShsZW5ndGgpO1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGFudW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIERTVCA9IEgoY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3htZDogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gY29uY2F0Qnl0ZXMoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKGNvbmNhdEJ5dGVzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKGNvbmNhdEJ5dGVzKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKGNvbmNhdEJ5dGVzKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9IGNvbmNhdEJ5dGVzKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4vLyAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbi8vIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4vLyAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjJcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEZcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFudW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBfRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKF9EU1QpIDogX0RTVDtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmU6IGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cywgZ290ICR7aX0gaW4gYXJyYXlgKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUoc2NhbGFycykpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\nfunction FpLegendre(order) {\n    // (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n    // (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x) => f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x) => {\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * NOTE: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUN1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUVBQXFFLFFBQVEsTUFBTSxPQUFPO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxtQ0FBbUM7QUFDbkMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRDtBQUNBLGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUMsc0RBQXNEO0FBQ3RELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcseURBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0RBQXNEO0FBQzdEO0FBQ0EseURBQXlELE1BQU07QUFDL0QsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsV0FBVztBQUMxRiw4Q0FBOEM7QUFDOUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwREFBZSxlQUFlLDBEQUFlO0FBQy9FO0FBQ0E7QUFDQSwwREFBMEQsTUFBTSxRQUFRLGFBQWE7QUFDckYsMEJBQTBCLDBEQUFlLFVBQVUsMERBQWU7QUFDbEUsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHNEQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPLDRCQUE0QixRQUFRO0FBQ3BHLHVCQUF1QiwwREFBZSxTQUFTLDBEQUFlO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTyw0QkFBNEIsSUFBSTtBQUMzRSx1QkFBdUIsMERBQWUsUUFBUSwwREFBZTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFlLHNCQUFzQiwwREFBZTtBQUN0RTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS42LjAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5pbXBvcnQgeyBiaXRNYXNrLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBMZWdlbmRyZShvcmRlcikge1xuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgcmVzaWR1ZVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKG9yZGVyIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuIChmLCB4KSA9PiBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlID0gRnBMZWdlbmRyZShmLk9SREVSKTtcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGxlZ2VuZHJlKGYsIHgpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuICoqTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZC4qKlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogTk9URTogb3BlcmF0aW9ucyBkb24ndCBjaGVjayAnaXNWYWxpZCcgZm9yIGFsbCBlbGVtZW50cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcbiAqIGl0IGlzIGNhbGxlciByZXNwb25zaWJpbGl0eSB0byBjaGVjayB0aGlzLlxuICogVGhpcyBpcyBsb3ctbGV2ZWwgY29kZSwgcGxlYXNlIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSBkb2luZy5cbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: () => (/* binding */ montgomery)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.pow)(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(u, scalar) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('u', u, _0n, P);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('scalar', scalar, _0n, P);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('u coordinate', uEnc, montgomeryBytes);\n        if (fieldLen === 32)\n            u[31] &= 127; // 0b0111_1111\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(u);\n    }\n    function decodeScalar(n) {\n        const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('scalar', n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen)\n            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n//# sourceMappingURL=montgomery.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUN3QztBQUM4RDtBQUN0RztBQUNBO0FBQ0E7QUFDQSxJQUFJLHlEQUFjO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLElBQUk7QUFDaEIsd0JBQXdCLGdEQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdEQUFHO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFRO0FBQ2hCLFFBQVEsbURBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCO0FBQ0EsMEJBQTBCO0FBQzFCLGVBQWUsMERBQWU7QUFDOUI7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQixLQUFLLFVBQVUsYUFBYSxJQUFJO0FBQ3pGLGVBQWUsMERBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhEQUE4RDtBQUMvRTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuNi4wL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb250Z29tZXJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IG1vZCwgcG93IH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGFJblJhbmdlLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzTEUsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgYTogJ2JpZ2ludCcsXG4gICAgfSwge1xuICAgICAgICBtb250Z29tZXJ5Qml0czogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBhZGp1c3RTY2FsYXJCeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZG9tYWluOiAnZnVuY3Rpb24nLFxuICAgICAgICBwb3dQbWludXMyOiAnZnVuY3Rpb24nLFxuICAgICAgICBHdTogJ2JpZ2ludCcsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jdXJ2ZSB9KTtcbn1cbi8vIE5PVEU6IG5vdCByZWFsbHkgbW9udGdvbWVyeSBjdXJ2ZSwganVzdCBidW5jaCBvZiB2ZXJ5IHNwZWNpZmljIG1ldGhvZHMgZm9yIFgyNTUxOS9YNDQ4IChSRkMgNzc0OCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzc3NDgpXG4vLyBVc2VzIG9ubHkgb25lIGNvb3JkaW5hdGUgaW5zdGVhZCBvZiB0d29cbmV4cG9ydCBmdW5jdGlvbiBtb250Z29tZXJ5KGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgbW9kUCA9IChuKSA9PiBtb2QobiwgUCk7XG4gICAgY29uc3QgbW9udGdvbWVyeUJpdHMgPSBDVVJWRS5tb250Z29tZXJ5Qml0cztcbiAgICBjb25zdCBtb250Z29tZXJ5Qnl0ZXMgPSBNYXRoLmNlaWwobW9udGdvbWVyeUJpdHMgLyA4KTtcbiAgICBjb25zdCBmaWVsZExlbiA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gQ1VSVkUuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlcykgPT4gYnl0ZXMpO1xuICAgIGNvbnN0IHBvd1BtaW51czIgPSBDVVJWRS5wb3dQbWludXMyIHx8ICgoeCkgPT4gcG93KHgsIFAgLSBCaWdJbnQoMiksIFApKTtcbiAgICAvLyBjc3dhcCBmcm9tIFJGQzc3NDguIEJ1dCBpdCBpcyBub3QgZnJvbSBSRkM3NzQ4IVxuICAgIC8qXG4gICAgICBjc3dhcChzd2FwLCB4XzIsIHhfMyk6XG4gICAgICAgICAgIGR1bW15ID0gbWFzayhzd2FwKSBBTkQgKHhfMiBYT1IgeF8zKVxuICAgICAgICAgICB4XzIgPSB4XzIgWE9SIGR1bW15XG4gICAgICAgICAgIHhfMyA9IHhfMyBYT1IgZHVtbXlcbiAgICAgICAgICAgUmV0dXJuICh4XzIsIHhfMylcbiAgICBXaGVyZSBtYXNrKHN3YXApIGlzIHRoZSBhbGwtMSBvciBhbGwtMCB3b3JkIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4XzJcbiAgICAgYW5kIHhfMywgY29tcHV0ZWQsIGUuZy4sIGFzIG1hc2soc3dhcCkgPSAwIC0gc3dhcC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG4gICAgICAgIGNvbnN0IGR1bW15ID0gbW9kUChzd2FwICogKHhfMiAtIHhfMykpO1xuICAgICAgICB4XzIgPSBtb2RQKHhfMiAtIGR1bW15KTtcbiAgICAgICAgeF8zID0gbW9kUCh4XzMgKyBkdW1teSk7XG4gICAgICAgIHJldHVybiBbeF8yLCB4XzNdO1xuICAgIH1cbiAgICAvLyB4MjU1MTkgZnJvbSA0XG4gICAgLy8gVGhlIGNvbnN0YW50IGEyNCBpcyAoNDg2NjYyIC0gMikgLyA0ID0gMTIxNjY1IGZvciBjdXJ2ZTI1NTE5L1gyNTUxOVxuICAgIGNvbnN0IGEyNCA9IChDVVJWRS5hIC0gQmlnSW50KDIpKSAvIEJpZ0ludCg0KTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2ludFUgdSBjb29yZGluYXRlICh4KSBvbiBNb250Z29tZXJ5IEN1cnZlIDI1NTE5XG4gICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAqIEByZXR1cm5zIG5ldyBQb2ludCBvbiBNb250Z29tZXJ5IGN1cnZlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9udGdvbWVyeUxhZGRlcih1LCBzY2FsYXIpIHtcbiAgICAgICAgYUluUmFuZ2UoJ3UnLCB1LCBfMG4sIFApO1xuICAgICAgICBhSW5SYW5nZSgnc2NhbGFyJywgc2NhbGFyLCBfMG4sIFApO1xuICAgICAgICAvLyBTZWN0aW9uIDU6IEltcGxlbWVudGF0aW9ucyBNVVNUIGFjY2VwdCBub24tY2Fub25pY2FsIHZhbHVlcyBhbmQgcHJvY2VzcyB0aGVtIGFzXG4gICAgICAgIC8vIGlmIHRoZXkgaGFkIGJlZW4gcmVkdWNlZCBtb2R1bG8gdGhlIGZpZWxkIHByaW1lLlxuICAgICAgICBjb25zdCBrID0gc2NhbGFyO1xuICAgICAgICBjb25zdCB4XzEgPSB1O1xuICAgICAgICBsZXQgeF8yID0gXzFuO1xuICAgICAgICBsZXQgel8yID0gXzBuO1xuICAgICAgICBsZXQgeF8zID0gdTtcbiAgICAgICAgbGV0IHpfMyA9IF8xbjtcbiAgICAgICAgbGV0IHN3YXAgPSBfMG47XG4gICAgICAgIGxldCBzdztcbiAgICAgICAgZm9yIChsZXQgdCA9IEJpZ0ludChtb250Z29tZXJ5Qml0cyAtIDEpOyB0ID49IF8wbjsgdC0tKSB7XG4gICAgICAgICAgICBjb25zdCBrX3QgPSAoayA+PiB0KSAmIF8xbjtcbiAgICAgICAgICAgIHN3YXAgXj0ga190O1xuICAgICAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB4XzIsIHhfMyk7XG4gICAgICAgICAgICB4XzIgPSBzd1swXTtcbiAgICAgICAgICAgIHhfMyA9IHN3WzFdO1xuICAgICAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB6XzIsIHpfMyk7XG4gICAgICAgICAgICB6XzIgPSBzd1swXTtcbiAgICAgICAgICAgIHpfMyA9IHN3WzFdO1xuICAgICAgICAgICAgc3dhcCA9IGtfdDtcbiAgICAgICAgICAgIGNvbnN0IEEgPSB4XzIgKyB6XzI7XG4gICAgICAgICAgICBjb25zdCBBQSA9IG1vZFAoQSAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQiA9IHhfMiAtIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEJCID0gbW9kUChCICogQik7XG4gICAgICAgICAgICBjb25zdCBFID0gQUEgLSBCQjtcbiAgICAgICAgICAgIGNvbnN0IEMgPSB4XzMgKyB6XzM7XG4gICAgICAgICAgICBjb25zdCBEID0geF8zIC0gel8zO1xuICAgICAgICAgICAgY29uc3QgREEgPSBtb2RQKEQgKiBBKTtcbiAgICAgICAgICAgIGNvbnN0IENCID0gbW9kUChDICogQik7XG4gICAgICAgICAgICBjb25zdCBkYWNiID0gREEgKyBDQjtcbiAgICAgICAgICAgIGNvbnN0IGRhX2NiID0gREEgLSBDQjtcbiAgICAgICAgICAgIHhfMyA9IG1vZFAoZGFjYiAqIGRhY2IpO1xuICAgICAgICAgICAgel8zID0gbW9kUCh4XzEgKiBtb2RQKGRhX2NiICogZGFfY2IpKTtcbiAgICAgICAgICAgIHhfMiA9IG1vZFAoQUEgKiBCQik7XG4gICAgICAgICAgICB6XzIgPSBtb2RQKEUgKiAoQUEgKyBtb2RQKGEyNCAqIEUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gKHhfMiwgeF8zKSA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKVxuICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKTtcbiAgICAgICAgeF8yID0gc3dbMF07XG4gICAgICAgIHhfMyA9IHN3WzFdO1xuICAgICAgICAvLyAoel8yLCB6XzMpID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpXG4gICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpO1xuICAgICAgICB6XzIgPSBzd1swXTtcbiAgICAgICAgel8zID0gc3dbMV07XG4gICAgICAgIC8vIHpfMl4ocCAtIDIpXG4gICAgICAgIGNvbnN0IHoyID0gcG93UG1pbnVzMih6XzIpO1xuICAgICAgICAvLyBSZXR1cm4geF8yICogKHpfMl4ocCAtIDIpKVxuICAgICAgICByZXR1cm4gbW9kUCh4XzIgKiB6Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZVVDb29yZGluYXRlKHUpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNMRShtb2RQKHUpLCBtb250Z29tZXJ5Qnl0ZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVVQ29vcmRpbmF0ZSh1RW5jKSB7XG4gICAgICAgIC8vIFNlY3Rpb24gNTogV2hlbiByZWNlaXZpbmcgc3VjaCBhbiBhcnJheSwgaW1wbGVtZW50YXRpb25zIG9mIFgyNTUxOVxuICAgICAgICAvLyBNVVNUIG1hc2sgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGluIHRoZSBmaW5hbCBieXRlLlxuICAgICAgICBjb25zdCB1ID0gZW5zdXJlQnl0ZXMoJ3UgY29vcmRpbmF0ZScsIHVFbmMsIG1vbnRnb21lcnlCeXRlcyk7XG4gICAgICAgIGlmIChmaWVsZExlbiA9PT0gMzIpXG4gICAgICAgICAgICB1WzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gICAgICAgIHJldHVybiBieXRlc1RvTnVtYmVyTEUodSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVNjYWxhcihuKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMoJ3NjYWxhcicsIG4pO1xuICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IG1vbnRnb21lcnlCeXRlcyAmJiBsZW4gIT09IGZpZWxkTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke21vbnRnb21lcnlCeXRlc30gb3IgJHtmaWVsZExlbn0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRShhZGp1c3RTY2FsYXJCeXRlcyhieXRlcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsYXJNdWx0KHNjYWxhciwgdSkge1xuICAgICAgICBjb25zdCBwb2ludFUgPSBkZWNvZGVVQ29vcmRpbmF0ZSh1KTtcbiAgICAgICAgY29uc3QgX3NjYWxhciA9IGRlY29kZVNjYWxhcihzY2FsYXIpO1xuICAgICAgICBjb25zdCBwdSA9IG1vbnRnb21lcnlMYWRkZXIocG9pbnRVLCBfc2NhbGFyKTtcbiAgICAgICAgLy8gVGhlIHJlc3VsdCB3YXMgbm90IGNvbnRyaWJ1dG9yeVxuICAgICAgICAvLyBodHRwczovL2NyLnlwLnRvL2VjZGguaHRtbCN2YWxpZGF0ZVxuICAgICAgICBpZiAocHUgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIG9yIHB1YmxpYyBrZXkgcmVjZWl2ZWQnKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVDb29yZGluYXRlKHB1KTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcHVibGljIGtleSBmcm9tIHByaXZhdGUuIEJ5IGRvaW5nIHNjYWxhciBtdWx0aXBsaWNhdGlvbiBvZiBiYXNlIHBvaW50LlxuICAgIGNvbnN0IEd1Qnl0ZXMgPSBlbmNvZGVVQ29vcmRpbmF0ZShDVVJWRS5HdSk7XG4gICAgZnVuY3Rpb24gc2NhbGFyTXVsdEJhc2Uoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBzY2FsYXJNdWx0KHNjYWxhciwgR3VCeXRlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxhck11bHQsXG4gICAgICAgIHNjYWxhck11bHRCYXNlLFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQ6IChwcml2YXRlS2V5LCBwdWJsaWNLZXkpID0+IHNjYWxhck11bHQocHJpdmF0ZUtleSwgcHVibGljS2V5KSxcbiAgICAgICAgZ2V0UHVibGljS2V5OiAocHJpdmF0ZUtleSkgPT4gc2NhbGFyTXVsdEJhc2UocHJpdmF0ZUtleSksXG4gICAgICAgIHV0aWxzOiB7IHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IENVUlZFLnJhbmRvbUJ5dGVzKENVUlZFLm5CeXRlTGVuZ3RoKSB9LFxuICAgICAgICBHdUJ5dGVzOiBHdUJ5dGVzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb250Z29tZXJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/montgomery.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/tower.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/tower.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   psiFrobenius: () => (/* binding */ psiFrobenius),\n/* harmony export */   tower12: () => (/* binding */ tower12)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n/*\nTowered extension fields\n\nRather than implementing a massive 12th-degree extension directly, it is more efficient\nto build it up from smaller extensions: a tower of extensions.\n\nFor BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\non top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n\nFor more info: \"Pairings for beginners\" by Costello, section 7.3.\n*/\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\nfunction calcFrobeniusCoefficients(Fp, nonResidue, modulus, degree, num = 1, divisor) {\n    const _divisor = BigInt(divisor === undefined ? degree : divisor);\n    const towerModulus = modulus ** BigInt(degree);\n    const res = [];\n    for (let i = 0; i < num; i++) {\n        const a = BigInt(i + 1);\n        const powers = [];\n        for (let j = 0, qPower = _1n; j < degree; j++) {\n            const power = ((a * qPower - a) / _divisor) % towerModulus;\n            powers.push(Fp.pow(nonResidue, power));\n            qPower *= modulus;\n        }\n        res.push(powers);\n    }\n    return res;\n}\n// This works same at least for bls12-381, bn254 and bls12-377\nfunction psiFrobenius(Fp, Fp2, base) {\n    // Ψ endomorphism\n    const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n    const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n    function psi(x, y) {\n        // This x10 faster than previous version in bls12-381\n        const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n        const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n        return [x2, y2];\n    }\n    // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\n    const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n    // This equals -1, which causes y to be Fp2.neg(y).\n    // But not sure if there are case when this is not true?\n    const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n    if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE)))\n        throw new Error('psiFrobenius: PSI2_Y!==-1');\n    function psi2(x, y) {\n        return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\n    }\n    // Map points\n    const mapAffine = (fn) => (c, P) => {\n        const affine = P.toAffine();\n        const p = fn(affine.x, affine.y);\n        return c.fromAffine({ x: p[0], y: p[1] });\n    };\n    const G2psi = mapAffine(psi);\n    const G2psi2 = mapAffine(psi2);\n    return { psi, psi2, G2psi, G2psi2, PSI_X, PSI_Y, PSI2_X, PSI2_Y };\n}\nfunction tower12(opts) {\n    const { ORDER } = opts;\n    // Fp\n    const Fp = _modular_js__WEBPACK_IMPORTED_MODULE_0__.Field(ORDER);\n    const FpNONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n    const FpLegendre = _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpLegendre(ORDER);\n    const Fpdiv2 = Fp.div(Fp.ONE, _2n); // 1/2\n    // Fp2\n    const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, FpNONRESIDUE, Fp.ORDER, 2)[0];\n    const Fp2Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n        c0: Fp.add(c0, r0),\n        c1: Fp.add(c1, r1),\n    });\n    const Fp2Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n        c0: Fp.sub(c0, r0),\n        c1: Fp.sub(c1, r1),\n    });\n    const Fp2Multiply = ({ c0, c1 }, rhs) => {\n        if (typeof rhs === 'bigint')\n            return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\n        // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\n        const { c0: r0, c1: r1 } = rhs;\n        let t1 = Fp.mul(c0, r0); // c0 * o0\n        let t2 = Fp.mul(c1, r1); // c1 * o1\n        // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n        const o0 = Fp.sub(t1, t2);\n        const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n        return { c0: o0, c1: o1 };\n    };\n    const Fp2Square = ({ c0, c1 }) => {\n        const a = Fp.add(c0, c1);\n        const b = Fp.sub(c0, c1);\n        const c = Fp.add(c0, c0);\n        return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\n    };\n    const Fp2fromBigTuple = (tuple) => {\n        if (tuple.length !== 2)\n            throw new Error('Invalid tuple');\n        const fps = tuple.map((n) => Fp.create(n));\n        return { c0: fps[0], c1: fps[1] };\n    };\n    const FP2_ORDER = ORDER * ORDER;\n    const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n    const Fp2 = {\n        ORDER: FP2_ORDER,\n        NONRESIDUE: Fp2Nonresidue,\n        BITS: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER),\n        BYTES: Math.ceil((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER) / 8),\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER)),\n        ZERO: { c0: Fp.ZERO, c1: Fp.ZERO },\n        ONE: { c0: Fp.ONE, c1: Fp.ZERO },\n        create: (num) => num,\n        isValid: ({ c0, c1 }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\n        is0: ({ c0, c1 }) => Fp.is0(c0) && Fp.is0(c1),\n        eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\n        neg: ({ c0, c1 }) => ({ c0: Fp.neg(c0), c1: Fp.neg(c1) }),\n        pow: (num, power) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp2, num, power),\n        invertBatch: (nums) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp2, nums),\n        // Normalized\n        add: Fp2Add,\n        sub: Fp2Subtract,\n        mul: Fp2Multiply,\n        sqr: Fp2Square,\n        // NonNormalized stuff\n        addN: Fp2Add,\n        subN: Fp2Subtract,\n        mulN: Fp2Multiply,\n        sqrN: Fp2Square,\n        // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n        div: (lhs, rhs) => Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\n        inv: ({ c0: a, c1: b }) => {\n            // We wish to find the multiplicative inverse of a nonzero\n            // element a + bu in Fp2. We leverage an identity\n            //\n            // (a + bu)(a - bu) = a² + b²\n            //\n            // which holds because u² = -1. This can be rewritten as\n            //\n            // (a + bu)(a - bu)/(a² + b²) = 1\n            //\n            // because a² + b² = 0 has no nonzero solutions for (a, b).\n            // This gives that (a - bu)/(a² + b²) is the inverse\n            // of (a + bu). Importantly, this can be computing using\n            // only a single inversion in Fp.\n            const factor = Fp.inv(Fp.create(a * a + b * b));\n            return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\n        },\n        sqrt: (num) => {\n            if (opts.Fp2sqrt)\n                return opts.Fp2sqrt(num);\n            // This is generic for all quadratic extensions (Fp2)\n            const { c0, c1 } = num;\n            if (Fp.is0(c1)) {\n                // if c0 is quadratic residue\n                if (Fp.eql(FpLegendre(Fp, c0), Fp.ONE))\n                    return Fp2.create({ c0: Fp.sqrt(c0), c1: Fp.ZERO });\n                else\n                    return Fp2.create({ c0: Fp.ZERO, c1: Fp.sqrt(Fp.div(c0, FpNONRESIDUE)) });\n            }\n            const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), FpNONRESIDUE)));\n            let d = Fp.mul(Fp.add(a, c0), Fpdiv2);\n            const legendre = FpLegendre(Fp, d);\n            // -1, Quadratic non residue\n            if (!Fp.is0(legendre) && !Fp.eql(legendre, Fp.ONE))\n                d = Fp.sub(d, a);\n            const a0 = Fp.sqrt(d);\n            const candidateSqrt = Fp2.create({ c0: a0, c1: Fp.div(Fp.mul(c1, Fpdiv2), a0) });\n            if (!Fp2.eql(Fp2.sqr(candidateSqrt), num))\n                throw new Error('Cannot find square root');\n            // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n            const x1 = candidateSqrt;\n            const x2 = Fp2.neg(x1);\n            const { re: re1, im: im1 } = Fp2.reim(x1);\n            const { re: re2, im: im2 } = Fp2.reim(x2);\n            if (im1 > im2 || (im1 === im2 && re1 > re2))\n                return x1;\n            return x2;\n        },\n        // Same as sgn0_m_eq_2 in RFC 9380\n        isOdd: (x) => {\n            const { re: x0, im: x1 } = Fp2.reim(x);\n            const sign_0 = x0 % _2n;\n            const zero_0 = x0 === _0n;\n            const sign_1 = x1 % _2n;\n            return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\n        },\n        // Bytes util\n        fromBytes(b) {\n            if (b.length !== Fp2.BYTES)\n                throw new Error(`fromBytes wrong length=${b.length}`);\n            return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\n        },\n        toBytes: ({ c0, c1 }) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp.toBytes(c0), Fp.toBytes(c1)),\n        cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n            c0: Fp.cmov(c0, r0, c),\n            c1: Fp.cmov(c1, r1, c),\n        }),\n        reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\n        // multiply by u + 1\n        mulByNonresidue: ({ c0, c1 }) => Fp2.mul({ c0, c1 }, Fp2Nonresidue),\n        mulByB: opts.Fp2mulByB,\n        fromBigTuple: Fp2fromBigTuple,\n        frobeniusMap: ({ c0, c1 }, power) => ({\n            c0,\n            c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2]),\n        }),\n    };\n    // Fp6\n    const Fp6Add = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({\n        c0: Fp2.add(c0, r0),\n        c1: Fp2.add(c1, r1),\n        c2: Fp2.add(c2, r2),\n    });\n    const Fp6Subtract = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({\n        c0: Fp2.sub(c0, r0),\n        c1: Fp2.sub(c1, r1),\n        c2: Fp2.sub(c2, r2),\n    });\n    const Fp6Multiply = ({ c0, c1, c2 }, rhs) => {\n        if (typeof rhs === 'bigint') {\n            return {\n                c0: Fp2.mul(c0, rhs),\n                c1: Fp2.mul(c1, rhs),\n                c2: Fp2.mul(c2, rhs),\n            };\n        }\n        const { c0: r0, c1: r1, c2: r2 } = rhs;\n        const t0 = Fp2.mul(c0, r0); // c0 * o0\n        const t1 = Fp2.mul(c1, r1); // c1 * o1\n        const t2 = Fp2.mul(c2, r2); // c2 * o2\n        return {\n            // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n            c0: Fp2.add(t0, Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))),\n            // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n            c1: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)), Fp2.mulByNonresidue(t2)),\n            // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n            c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\n        };\n    };\n    const Fp6Square = ({ c0, c1, c2 }) => {\n        let t0 = Fp2.sqr(c0); // c0²\n        let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n        let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n        let t4 = Fp2.sqr(c2); // c2²\n        return {\n            c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\n            c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\n            // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\n            c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\n        };\n    };\n    const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(Fp2, Fp2Nonresidue, Fp.ORDER, 6, 2, 3);\n    const Fp6 = {\n        ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n        BITS: 3 * Fp2.BITS,\n        BYTES: 3 * Fp2.BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(3 * Fp2.BITS),\n        ZERO: { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO },\n        ONE: { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO },\n        create: (num) => num,\n        isValid: ({ c0, c1, c2 }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\n        is0: ({ c0, c1, c2 }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\n        neg: ({ c0, c1, c2 }) => ({ c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) }),\n        eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\n        sqrt: _utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented,\n        // Do we need division by bigint at all? Should be done via order:\n        div: (lhs, rhs) => Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\n        pow: (num, power) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp6, num, power),\n        invertBatch: (nums) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp6, nums),\n        // Normalized\n        add: Fp6Add,\n        sub: Fp6Subtract,\n        mul: Fp6Multiply,\n        sqr: Fp6Square,\n        // NonNormalized stuff\n        addN: Fp6Add,\n        subN: Fp6Subtract,\n        mulN: Fp6Multiply,\n        sqrN: Fp6Square,\n        inv: ({ c0, c1, c2 }) => {\n            let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\n            let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\n            let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\n            // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n            let t4 = Fp2.inv(Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0)));\n            return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\n        },\n        // Bytes utils\n        fromBytes: (b) => {\n            if (b.length !== Fp6.BYTES)\n                throw new Error(`fromBytes wrong length=${b.length}`);\n            return {\n                c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\n                c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\n                c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES)),\n            };\n        },\n        toBytes: ({ c0, c1, c2 }) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\n        cmov: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }, c) => ({\n            c0: Fp2.cmov(c0, r0, c),\n            c1: Fp2.cmov(c1, r1, c),\n            c2: Fp2.cmov(c2, r2, c),\n        }),\n        fromBigSix: (t) => {\n            if (!Array.isArray(t) || t.length !== 6)\n                throw new Error('Invalid Fp6 usage');\n            return {\n                c0: Fp2.fromBigTuple(t.slice(0, 2)),\n                c1: Fp2.fromBigTuple(t.slice(2, 4)),\n                c2: Fp2.fromBigTuple(t.slice(4, 6)),\n            };\n        },\n        frobeniusMap: ({ c0, c1, c2 }, power) => ({\n            c0: Fp2.frobeniusMap(c0, power),\n            c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n            c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6]),\n        }),\n        mulByFp2: ({ c0, c1, c2 }, rhs) => ({\n            c0: Fp2.mul(c0, rhs),\n            c1: Fp2.mul(c1, rhs),\n            c2: Fp2.mul(c2, rhs),\n        }),\n        mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 }),\n        // Sparse multiplication\n        mul1: ({ c0, c1, c2 }, b1) => ({\n            c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n            c1: Fp2.mul(c0, b1),\n            c2: Fp2.mul(c1, b1),\n        }),\n        // Sparse multiplication\n        mul01({ c0, c1, c2 }, b0, b1) {\n            let t0 = Fp2.mul(c0, b0); // c0 * b0\n            let t1 = Fp2.mul(c1, b1); // c1 * b1\n            return {\n                // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n                c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n                // (b0 + b1) * (c0 + c1) - T0 - T1\n                c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n                // (c0 + c2) * b0 - T0 + T1\n                c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\n            };\n        },\n    };\n    // Fp12\n    const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp2, Fp2Nonresidue, Fp.ORDER, 12, 1, 6)[0];\n    const Fp12Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n        c0: Fp6.add(c0, r0),\n        c1: Fp6.add(c1, r1),\n    });\n    const Fp12Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n        c0: Fp6.sub(c0, r0),\n        c1: Fp6.sub(c1, r1),\n    });\n    const Fp12Multiply = ({ c0, c1 }, rhs) => {\n        if (typeof rhs === 'bigint')\n            return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\n        let { c0: r0, c1: r1 } = rhs;\n        let t1 = Fp6.mul(c0, r0); // c0 * r0\n        let t2 = Fp6.mul(c1, r1); // c1 * r1\n        return {\n            c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\n            // (c0 + c1) * (r0 + r1) - (T1 + T2)\n            c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\n        };\n    };\n    const Fp12Square = ({ c0, c1 }) => {\n        let ab = Fp6.mul(c0, c1); // c0 * c1\n        return {\n            // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n            c0: Fp6.sub(Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab), Fp6.mulByNonresidue(ab)),\n            c1: Fp6.add(ab, ab),\n        }; // AB + AB\n    };\n    function Fp4Square(a, b) {\n        const a2 = Fp2.sqr(a);\n        const b2 = Fp2.sqr(b);\n        return {\n            first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b² * Nonresidue + a²\n            second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b)² - a² - b²\n        };\n    }\n    const Fp12 = {\n        ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n        BITS: 2 * Fp2.BITS,\n        BYTES: 2 * Fp2.BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(2 * Fp2.BITS),\n        ZERO: { c0: Fp6.ZERO, c1: Fp6.ZERO },\n        ONE: { c0: Fp6.ONE, c1: Fp6.ZERO },\n        create: (num) => num,\n        isValid: ({ c0, c1 }) => Fp6.isValid(c0) && Fp6.isValid(c1),\n        is0: ({ c0, c1 }) => Fp6.is0(c0) && Fp6.is0(c1),\n        neg: ({ c0, c1 }) => ({ c0: Fp6.neg(c0), c1: Fp6.neg(c1) }),\n        eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\n        sqrt: _utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented,\n        inv: ({ c0, c1 }) => {\n            let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\n            return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\n        },\n        div: (lhs, rhs) => Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\n        pow: (num, power) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp12, num, power),\n        invertBatch: (nums) => _modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp12, nums),\n        // Normalized\n        add: Fp12Add,\n        sub: Fp12Subtract,\n        mul: Fp12Multiply,\n        sqr: Fp12Square,\n        // NonNormalized stuff\n        addN: Fp12Add,\n        subN: Fp12Subtract,\n        mulN: Fp12Multiply,\n        sqrN: Fp12Square,\n        // Bytes utils\n        fromBytes: (b) => {\n            if (b.length !== Fp12.BYTES)\n                throw new Error(`fromBytes wrong length=${b.length}`);\n            return {\n                c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n                c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\n            };\n        },\n        toBytes: ({ c0, c1 }) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp6.toBytes(c0), Fp6.toBytes(c1)),\n        cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n            c0: Fp6.cmov(c0, r0, c),\n            c1: Fp6.cmov(c1, r1, c),\n        }),\n        // Utils\n        // toString() {\n        //   return `Fp12(${this.c0} + ${this.c1} * w)`;\n        // },\n        // fromTuple(c: [Fp6, Fp6]) {\n        //   return new Fp12(...c);\n        // }\n        fromBigTwelve: (t) => ({\n            c0: Fp6.fromBigSix(t.slice(0, 6)),\n            c1: Fp6.fromBigSix(t.slice(6, 12)),\n        }),\n        // Raises to q**i -th power\n        frobeniusMap(lhs, power) {\n            const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n            const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n            return {\n                c0: Fp6.frobeniusMap(lhs.c0, power),\n                c1: Fp6.create({\n                    c0: Fp2.mul(c0, coeff),\n                    c1: Fp2.mul(c1, coeff),\n                    c2: Fp2.mul(c2, coeff),\n                }),\n            };\n        },\n        mulByFp2: ({ c0, c1 }, rhs) => ({\n            c0: Fp6.mulByFp2(c0, rhs),\n            c1: Fp6.mulByFp2(c1, rhs),\n        }),\n        conjugate: ({ c0, c1 }) => ({ c0, c1: Fp6.neg(c1) }),\n        // Sparse multiplication\n        mul014: ({ c0, c1 }, o0, o1, o4) => {\n            let t0 = Fp6.mul01(c0, o0, o1);\n            let t1 = Fp6.mul1(c1, o4);\n            return {\n                c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\n                // (c1 + c0) * [o0, o1+o4] - T0 - T1\n                c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\n            };\n        },\n        mul034: ({ c0, c1 }, o0, o3, o4) => {\n            const a = Fp6.create({\n                c0: Fp2.mul(c0.c0, o0),\n                c1: Fp2.mul(c0.c1, o0),\n                c2: Fp2.mul(c0.c2, o0),\n            });\n            const b = Fp6.mul01(c1, o3, o4);\n            const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n            return {\n                c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n                c1: Fp6.sub(e, Fp6.add(a, b)),\n            };\n        },\n        // A cyclotomic group is a subgroup of Fp^n defined by\n        //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n        // The result of any pairing is in a cyclotomic subgroup\n        // https://eprint.iacr.org/2009/565.pdf\n        _cyclotomicSquare: opts.Fp12cyclotomicSquare,\n        _cyclotomicExp: opts.Fp12cyclotomicExp,\n        // https://eprint.iacr.org/2010/354.pdf\n        // https://eprint.iacr.org/2009/565.pdf\n        finalExponentiate: opts.Fp12finalExponentiate,\n    };\n    return { Fp, Fp2, Fp6, Fp4Square, Fp12 };\n}\n//# sourceMappingURL=tower.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdG93ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ29DO0FBQ3NDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EseURBQXlEO0FBQ3pELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCxZQUFZLFFBQVE7QUFDcEI7QUFDQSxlQUFlLDhDQUFTO0FBQ3hCO0FBQ0EsdUJBQXVCLG1EQUFjO0FBQ3JDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0Esc0JBQXNCLFFBQVEsSUFBSSxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsUUFBUSxJQUFJLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQU07QUFDcEIseUJBQXlCLGlEQUFNO0FBQy9CLGNBQWMsa0RBQU8sQ0FBQyxpREFBTTtBQUM1QixnQkFBZ0IsMEJBQTBCO0FBQzFDLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVEsSUFBSSxnQkFBZ0I7QUFDNUMsZ0JBQWdCLFFBQVEsUUFBUSxnQ0FBZ0M7QUFDaEUsNkJBQTZCLDhDQUFTO0FBQ3RDLCtCQUErQixzREFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOEJBQThCO0FBQ3RFO0FBQ0Esd0NBQXdDLG9EQUFvRDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDRDQUE0QztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QyxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsU0FBUztBQUNuRSxxQkFBcUI7QUFDckIsU0FBUztBQUNULG9CQUFvQixRQUFRLEtBQUssc0RBQVc7QUFDNUMsaUJBQWlCLFFBQVEsSUFBSSxnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUIsUUFBUSxRQUFRLGdCQUFnQjtBQUNqRDtBQUNBLDRCQUE0QixRQUFRLGVBQWUsUUFBUTtBQUMzRDtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksSUFBSSx3QkFBd0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQixZQUFZLElBQUksd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckMsOEJBQThCO0FBQzlCLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQU87QUFDckIsZ0JBQWdCLDBDQUEwQztBQUMxRCxlQUFlLHlDQUF5QztBQUN4RDtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixZQUFZLFFBQVEsbURBQW1EO0FBQ3ZGLGdCQUFnQixZQUFZLElBQUksd0JBQXdCO0FBQ3hELGNBQWMscURBQWM7QUFDNUI7QUFDQTtBQUNBLDZCQUE2Qiw4Q0FBUztBQUN0QywrQkFBK0Isc0RBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUIsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRiw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQkFBb0IsWUFBWSxLQUFLLHNEQUFXO0FBQ2hELGlCQUFpQixZQUFZLElBQUksd0JBQXdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLFlBQVksUUFBUSw2Q0FBNkM7QUFDN0Y7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsSUFBSSxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsUUFBUSxJQUFJLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0EsS0FBSztBQUNMLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EscUJBQXFCO0FBQ3JCLGNBQWMsaUJBQWlCO0FBQy9CLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBTztBQUNyQixnQkFBZ0IsNEJBQTRCO0FBQzVDLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVEsUUFBUSxrQ0FBa0M7QUFDbEUsZ0JBQWdCLFFBQVEsSUFBSSxnQkFBZ0I7QUFDNUMsY0FBYyxxREFBYztBQUM1QixnQkFBZ0IsUUFBUTtBQUN4QixxRkFBcUY7QUFDckYscUJBQXFCLG1EQUFtRDtBQUN4RSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkIsOENBQVM7QUFDdEMsK0JBQStCLHNEQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9CQUFvQixRQUFRLEtBQUssc0RBQVc7QUFDNUMsaUJBQWlCLFFBQVEsSUFBSSxnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCLFNBQVMsSUFBSSxTQUFTO0FBQ2xELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0JBQXNCLFFBQVEsUUFBUSxxQkFBcUI7QUFDM0Q7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS42LjAvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3Rvd2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYml0TGVuLCBiaXRNYXNrLCBjb25jYXRCeXRlcywgbm90SW1wbGVtZW50ZWQgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8qXG5Ub3dlcmVkIGV4dGVuc2lvbiBmaWVsZHNcblxuUmF0aGVyIHRoYW4gaW1wbGVtZW50aW5nIGEgbWFzc2l2ZSAxMnRoLWRlZ3JlZSBleHRlbnNpb24gZGlyZWN0bHksIGl0IGlzIG1vcmUgZWZmaWNpZW50XG50byBidWlsZCBpdCB1cCBmcm9tIHNtYWxsZXIgZXh0ZW5zaW9uczogYSB0b3dlciBvZiBleHRlbnNpb25zLlxuXG5Gb3IgQkxTMTItMzgxLCB0aGUgRnAxMiBmaWVsZCBpcyBpbXBsZW1lbnRlZCBhcyBhIHF1YWRyYXRpYyAoZGVncmVlIHR3bykgZXh0ZW5zaW9uLFxub24gdG9wIG9mIGEgY3ViaWMgKGRlZ3JlZSB0aHJlZSkgZXh0ZW5zaW9uLCBvbiB0b3Agb2YgYSBxdWFkcmF0aWMgZXh0ZW5zaW9uIG9mIEZwLlxuXG5Gb3IgbW9yZSBpbmZvOiBcIlBhaXJpbmdzIGZvciBiZWdpbm5lcnNcIiBieSBDb3N0ZWxsbywgc2VjdGlvbiA3LjMuXG4qL1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbmZ1bmN0aW9uIGNhbGNGcm9iZW5pdXNDb2VmZmljaWVudHMoRnAsIG5vblJlc2lkdWUsIG1vZHVsdXMsIGRlZ3JlZSwgbnVtID0gMSwgZGl2aXNvcikge1xuICAgIGNvbnN0IF9kaXZpc29yID0gQmlnSW50KGRpdmlzb3IgPT09IHVuZGVmaW5lZCA/IGRlZ3JlZSA6IGRpdmlzb3IpO1xuICAgIGNvbnN0IHRvd2VyTW9kdWx1cyA9IG1vZHVsdXMgKiogQmlnSW50KGRlZ3JlZSk7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgICBjb25zdCBhID0gQmlnSW50KGkgKyAxKTtcbiAgICAgICAgY29uc3QgcG93ZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBxUG93ZXIgPSBfMW47IGogPCBkZWdyZWU7IGorKykge1xuICAgICAgICAgICAgY29uc3QgcG93ZXIgPSAoKGEgKiBxUG93ZXIgLSBhKSAvIF9kaXZpc29yKSAlIHRvd2VyTW9kdWx1cztcbiAgICAgICAgICAgIHBvd2Vycy5wdXNoKEZwLnBvdyhub25SZXNpZHVlLCBwb3dlcikpO1xuICAgICAgICAgICAgcVBvd2VyICo9IG1vZHVsdXM7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2gocG93ZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIFRoaXMgd29ya3Mgc2FtZSBhdCBsZWFzdCBmb3IgYmxzMTItMzgxLCBibjI1NCBhbmQgYmxzMTItMzc3XG5leHBvcnQgZnVuY3Rpb24gcHNpRnJvYmVuaXVzKEZwLCBGcDIsIGJhc2UpIHtcbiAgICAvLyDOqCBlbmRvbW9ycGhpc21cbiAgICBjb25zdCBQU0lfWCA9IEZwMi5wb3coYmFzZSwgKEZwLk9SREVSIC0gXzFuKSAvIF8zbik7IC8vIHVeKChwLTEpLzMpXG4gICAgY29uc3QgUFNJX1kgPSBGcDIucG93KGJhc2UsIChGcC5PUkRFUiAtIF8xbikgLyBfMm4pOyAvLyB1XigocC0xKS8yKVxuICAgIGZ1bmN0aW9uIHBzaSh4LCB5KSB7XG4gICAgICAgIC8vIFRoaXMgeDEwIGZhc3RlciB0aGFuIHByZXZpb3VzIHZlcnNpb24gaW4gYmxzMTItMzgxXG4gICAgICAgIGNvbnN0IHgyID0gRnAyLm11bChGcDIuZnJvYmVuaXVzTWFwKHgsIDEpLCBQU0lfWCk7XG4gICAgICAgIGNvbnN0IHkyID0gRnAyLm11bChGcDIuZnJvYmVuaXVzTWFwKHksIDEpLCBQU0lfWSk7XG4gICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICB9XG4gICAgLy8gzqjCsihQKSBlbmRvbW9ycGhpc20gKHBzaTIoeCkgPSBwc2kocHNpKHgpKSlcbiAgICBjb25zdCBQU0kyX1ggPSBGcDIucG93KGJhc2UsIChGcC5PUkRFUiAqKiBfMm4gLSBfMW4pIC8gXzNuKTsgLy8gdV4oKHBeMiAtIDEpLzMpXG4gICAgLy8gVGhpcyBlcXVhbHMgLTEsIHdoaWNoIGNhdXNlcyB5IHRvIGJlIEZwMi5uZWcoeSkuXG4gICAgLy8gQnV0IG5vdCBzdXJlIGlmIHRoZXJlIGFyZSBjYXNlIHdoZW4gdGhpcyBpcyBub3QgdHJ1ZT9cbiAgICBjb25zdCBQU0kyX1kgPSBGcDIucG93KGJhc2UsIChGcC5PUkRFUiAqKiBfMm4gLSBfMW4pIC8gXzJuKTsgLy8gdV4oKHBeMiAtIDEpLzMpXG4gICAgaWYgKCFGcDIuZXFsKFBTSTJfWSwgRnAyLm5lZyhGcDIuT05FKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHNpRnJvYmVuaXVzOiBQU0kyX1khPT0tMScpO1xuICAgIGZ1bmN0aW9uIHBzaTIoeCwgeSkge1xuICAgICAgICByZXR1cm4gW0ZwMi5tdWwoeCwgUFNJMl9YKSwgRnAyLm5lZyh5KV07XG4gICAgfVxuICAgIC8vIE1hcCBwb2ludHNcbiAgICBjb25zdCBtYXBBZmZpbmUgPSAoZm4pID0+IChjLCBQKSA9PiB7XG4gICAgICAgIGNvbnN0IGFmZmluZSA9IFAudG9BZmZpbmUoKTtcbiAgICAgICAgY29uc3QgcCA9IGZuKGFmZmluZS54LCBhZmZpbmUueSk7XG4gICAgICAgIHJldHVybiBjLmZyb21BZmZpbmUoeyB4OiBwWzBdLCB5OiBwWzFdIH0pO1xuICAgIH07XG4gICAgY29uc3QgRzJwc2kgPSBtYXBBZmZpbmUocHNpKTtcbiAgICBjb25zdCBHMnBzaTIgPSBtYXBBZmZpbmUocHNpMik7XG4gICAgcmV0dXJuIHsgcHNpLCBwc2kyLCBHMnBzaSwgRzJwc2kyLCBQU0lfWCwgUFNJX1ksIFBTSTJfWCwgUFNJMl9ZIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdG93ZXIxMihvcHRzKSB7XG4gICAgY29uc3QgeyBPUkRFUiB9ID0gb3B0cztcbiAgICAvLyBGcFxuICAgIGNvbnN0IEZwID0gbW9kLkZpZWxkKE9SREVSKTtcbiAgICBjb25zdCBGcE5PTlJFU0lEVUUgPSBGcC5jcmVhdGUob3B0cy5OT05SRVNJRFVFIHx8IEJpZ0ludCgtMSkpO1xuICAgIGNvbnN0IEZwTGVnZW5kcmUgPSBtb2QuRnBMZWdlbmRyZShPUkRFUik7XG4gICAgY29uc3QgRnBkaXYyID0gRnAuZGl2KEZwLk9ORSwgXzJuKTsgLy8gMS8yXG4gICAgLy8gRnAyXG4gICAgY29uc3QgRlAyX0ZST0JFTklVU19DT0VGRklDSUVOVFMgPSBjYWxjRnJvYmVuaXVzQ29lZmZpY2llbnRzKEZwLCBGcE5PTlJFU0lEVUUsIEZwLk9SREVSLCAyKVswXTtcbiAgICBjb25zdCBGcDJBZGQgPSAoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9KSA9PiAoe1xuICAgICAgICBjMDogRnAuYWRkKGMwLCByMCksXG4gICAgICAgIGMxOiBGcC5hZGQoYzEsIHIxKSxcbiAgICB9KTtcbiAgICBjb25zdCBGcDJTdWJ0cmFjdCA9ICh7IGMwLCBjMSB9LCB7IGMwOiByMCwgYzE6IHIxIH0pID0+ICh7XG4gICAgICAgIGMwOiBGcC5zdWIoYzAsIHIwKSxcbiAgICAgICAgYzE6IEZwLnN1YihjMSwgcjEpLFxuICAgIH0pO1xuICAgIGNvbnN0IEZwMk11bHRpcGx5ID0gKHsgYzAsIGMxIH0sIHJocykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geyBjMDogRnAubXVsKGMwLCByaHMpLCBjMTogRnAubXVsKGMxLCByaHMpIH07XG4gICAgICAgIC8vIChhK2JpKShjK2RpKSA9IChhY+KIkmJkKSArIChhZCtiYylpXG4gICAgICAgIGNvbnN0IHsgYzA6IHIwLCBjMTogcjEgfSA9IHJocztcbiAgICAgICAgbGV0IHQxID0gRnAubXVsKGMwLCByMCk7IC8vIGMwICogbzBcbiAgICAgICAgbGV0IHQyID0gRnAubXVsKGMxLCByMSk7IC8vIGMxICogbzFcbiAgICAgICAgLy8gKFQxIC0gVDIpICsgKChjMCArIGMxKSAqIChyMCArIHIxKSAtIChUMSArIFQyKSkqaVxuICAgICAgICBjb25zdCBvMCA9IEZwLnN1Yih0MSwgdDIpO1xuICAgICAgICBjb25zdCBvMSA9IEZwLnN1YihGcC5tdWwoRnAuYWRkKGMwLCBjMSksIEZwLmFkZChyMCwgcjEpKSwgRnAuYWRkKHQxLCB0MikpO1xuICAgICAgICByZXR1cm4geyBjMDogbzAsIGMxOiBvMSB9O1xuICAgIH07XG4gICAgY29uc3QgRnAyU3F1YXJlID0gKHsgYzAsIGMxIH0pID0+IHtcbiAgICAgICAgY29uc3QgYSA9IEZwLmFkZChjMCwgYzEpO1xuICAgICAgICBjb25zdCBiID0gRnAuc3ViKGMwLCBjMSk7XG4gICAgICAgIGNvbnN0IGMgPSBGcC5hZGQoYzAsIGMwKTtcbiAgICAgICAgcmV0dXJuIHsgYzA6IEZwLm11bChhLCBiKSwgYzE6IEZwLm11bChjLCBjMSkgfTtcbiAgICB9O1xuICAgIGNvbnN0IEZwMmZyb21CaWdUdXBsZSA9ICh0dXBsZSkgPT4ge1xuICAgICAgICBpZiAodHVwbGUubGVuZ3RoICE9PSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR1cGxlJyk7XG4gICAgICAgIGNvbnN0IGZwcyA9IHR1cGxlLm1hcCgobikgPT4gRnAuY3JlYXRlKG4pKTtcbiAgICAgICAgcmV0dXJuIHsgYzA6IGZwc1swXSwgYzE6IGZwc1sxXSB9O1xuICAgIH07XG4gICAgY29uc3QgRlAyX09SREVSID0gT1JERVIgKiBPUkRFUjtcbiAgICBjb25zdCBGcDJOb25yZXNpZHVlID0gRnAyZnJvbUJpZ1R1cGxlKG9wdHMuRlAyX05PTlJFU0lEVUUpO1xuICAgIGNvbnN0IEZwMiA9IHtcbiAgICAgICAgT1JERVI6IEZQMl9PUkRFUixcbiAgICAgICAgTk9OUkVTSURVRTogRnAyTm9ucmVzaWR1ZSxcbiAgICAgICAgQklUUzogYml0TGVuKEZQMl9PUkRFUiksXG4gICAgICAgIEJZVEVTOiBNYXRoLmNlaWwoYml0TGVuKEZQMl9PUkRFUikgLyA4KSxcbiAgICAgICAgTUFTSzogYml0TWFzayhiaXRMZW4oRlAyX09SREVSKSksXG4gICAgICAgIFpFUk86IHsgYzA6IEZwLlpFUk8sIGMxOiBGcC5aRVJPIH0sXG4gICAgICAgIE9ORTogeyBjMDogRnAuT05FLCBjMTogRnAuWkVSTyB9LFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG51bSxcbiAgICAgICAgaXNWYWxpZDogKHsgYzAsIGMxIH0pID0+IHR5cGVvZiBjMCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIGMxID09PSAnYmlnaW50JyxcbiAgICAgICAgaXMwOiAoeyBjMCwgYzEgfSkgPT4gRnAuaXMwKGMwKSAmJiBGcC5pczAoYzEpLFxuICAgICAgICBlcWw6ICh7IGMwLCBjMSB9LCB7IGMwOiByMCwgYzE6IHIxIH0pID0+IEZwLmVxbChjMCwgcjApICYmIEZwLmVxbChjMSwgcjEpLFxuICAgICAgICBuZWc6ICh7IGMwLCBjMSB9KSA9PiAoeyBjMDogRnAubmVnKGMwKSwgYzE6IEZwLm5lZyhjMSkgfSksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IG1vZC5GcFBvdyhGcDIsIG51bSwgcG93ZXIpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKG51bXMpID0+IG1vZC5GcEludmVydEJhdGNoKEZwMiwgbnVtcyksXG4gICAgICAgIC8vIE5vcm1hbGl6ZWRcbiAgICAgICAgYWRkOiBGcDJBZGQsXG4gICAgICAgIHN1YjogRnAyU3VidHJhY3QsXG4gICAgICAgIG11bDogRnAyTXVsdGlwbHksXG4gICAgICAgIHNxcjogRnAyU3F1YXJlLFxuICAgICAgICAvLyBOb25Ob3JtYWxpemVkIHN0dWZmXG4gICAgICAgIGFkZE46IEZwMkFkZCxcbiAgICAgICAgc3ViTjogRnAyU3VidHJhY3QsXG4gICAgICAgIG11bE46IEZwMk11bHRpcGx5LFxuICAgICAgICBzcXJOOiBGcDJTcXVhcmUsXG4gICAgICAgIC8vIFdoeSBpbnZlcnNpb24gZm9yIGJpZ2ludCBpbnNpZGUgRnAgaW5zdGVhZCBvZiBGcDI/IGl0IGlzIGV2ZW4gdXNlZCBpbiB0aGF0IGNvbnRleHQ/XG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBGcDIubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBGcC5pbnYoRnAuY3JlYXRlKHJocykpIDogRnAyLmludihyaHMpKSxcbiAgICAgICAgaW52OiAoeyBjMDogYSwgYzE6IGIgfSkgPT4ge1xuICAgICAgICAgICAgLy8gV2Ugd2lzaCB0byBmaW5kIHRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGEgbm9uemVyb1xuICAgICAgICAgICAgLy8gZWxlbWVudCBhICsgYnUgaW4gRnAyLiBXZSBsZXZlcmFnZSBhbiBpZGVudGl0eVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIChhICsgYnUpKGEgLSBidSkgPSBhwrIgKyBiwrJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB3aGljaCBob2xkcyBiZWNhdXNlIHXCsiA9IC0xLiBUaGlzIGNhbiBiZSByZXdyaXR0ZW4gYXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAoYSArIGJ1KShhIC0gYnUpLyhhwrIgKyBiwrIpID0gMVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGJlY2F1c2UgYcKyICsgYsKyID0gMCBoYXMgbm8gbm9uemVybyBzb2x1dGlvbnMgZm9yIChhLCBiKS5cbiAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgdGhhdCAoYSAtIGJ1KS8oYcKyICsgYsKyKSBpcyB0aGUgaW52ZXJzZVxuICAgICAgICAgICAgLy8gb2YgKGEgKyBidSkuIEltcG9ydGFudGx5LCB0aGlzIGNhbiBiZSBjb21wdXRpbmcgdXNpbmdcbiAgICAgICAgICAgIC8vIG9ubHkgYSBzaW5nbGUgaW52ZXJzaW9uIGluIEZwLlxuICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gRnAuaW52KEZwLmNyZWF0ZShhICogYSArIGIgKiBiKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjMDogRnAubXVsKGZhY3RvciwgRnAuY3JlYXRlKGEpKSwgYzE6IEZwLm11bChmYWN0b3IsIEZwLmNyZWF0ZSgtYikpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNxcnQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRzLkZwMnNxcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMuRnAyc3FydChudW0pO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBnZW5lcmljIGZvciBhbGwgcXVhZHJhdGljIGV4dGVuc2lvbnMgKEZwMilcbiAgICAgICAgICAgIGNvbnN0IHsgYzAsIGMxIH0gPSBudW07XG4gICAgICAgICAgICBpZiAoRnAuaXMwKGMxKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGMwIGlzIHF1YWRyYXRpYyByZXNpZHVlXG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbChGcExlZ2VuZHJlKEZwLCBjMCksIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGcDIuY3JlYXRlKHsgYzA6IEZwLnNxcnQoYzApLCBjMTogRnAuWkVSTyB9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGcDIuY3JlYXRlKHsgYzA6IEZwLlpFUk8sIGMxOiBGcC5zcXJ0KEZwLmRpdihjMCwgRnBOT05SRVNJRFVFKSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhID0gRnAuc3FydChGcC5zdWIoRnAuc3FyKGMwKSwgRnAubXVsKEZwLnNxcihjMSksIEZwTk9OUkVTSURVRSkpKTtcbiAgICAgICAgICAgIGxldCBkID0gRnAubXVsKEZwLmFkZChhLCBjMCksIEZwZGl2Mik7XG4gICAgICAgICAgICBjb25zdCBsZWdlbmRyZSA9IEZwTGVnZW5kcmUoRnAsIGQpO1xuICAgICAgICAgICAgLy8gLTEsIFF1YWRyYXRpYyBub24gcmVzaWR1ZVxuICAgICAgICAgICAgaWYgKCFGcC5pczAobGVnZW5kcmUpICYmICFGcC5lcWwobGVnZW5kcmUsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgZCA9IEZwLnN1YihkLCBhKTtcbiAgICAgICAgICAgIGNvbnN0IGEwID0gRnAuc3FydChkKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZVNxcnQgPSBGcDIuY3JlYXRlKHsgYzA6IGEwLCBjMTogRnAuZGl2KEZwLm11bChjMSwgRnBkaXYyKSwgYTApIH0pO1xuICAgICAgICAgICAgaWYgKCFGcDIuZXFsKEZwMi5zcXIoY2FuZGlkYXRlU3FydCksIG51bSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHJvb3Q6IGF0IHRoaXMgcG9pbnQgY2FuZGlkYXRlU3FydCAqKiAyID0gbnVtLCBidXQgYWxzbyAtY2FuZGlkYXRlU3FydCAqKiAyID0gbnVtXG4gICAgICAgICAgICBjb25zdCB4MSA9IGNhbmRpZGF0ZVNxcnQ7XG4gICAgICAgICAgICBjb25zdCB4MiA9IEZwMi5uZWcoeDEpO1xuICAgICAgICAgICAgY29uc3QgeyByZTogcmUxLCBpbTogaW0xIH0gPSBGcDIucmVpbSh4MSk7XG4gICAgICAgICAgICBjb25zdCB7IHJlOiByZTIsIGltOiBpbTIgfSA9IEZwMi5yZWltKHgyKTtcbiAgICAgICAgICAgIGlmIChpbTEgPiBpbTIgfHwgKGltMSA9PT0gaW0yICYmIHJlMSA+IHJlMikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHgxO1xuICAgICAgICAgICAgcmV0dXJuIHgyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTYW1lIGFzIHNnbjBfbV9lcV8yIGluIFJGQyA5MzgwXG4gICAgICAgIGlzT2RkOiAoeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyByZTogeDAsIGltOiB4MSB9ID0gRnAyLnJlaW0oeCk7XG4gICAgICAgICAgICBjb25zdCBzaWduXzAgPSB4MCAlIF8ybjtcbiAgICAgICAgICAgIGNvbnN0IHplcm9fMCA9IHgwID09PSBfMG47XG4gICAgICAgICAgICBjb25zdCBzaWduXzEgPSB4MSAlIF8ybjtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQoc2lnbl8wIHx8ICh6ZXJvXzAgJiYgc2lnbl8xKSkgPT0gXzFuO1xuICAgICAgICB9LFxuICAgICAgICAvLyBCeXRlcyB1dGlsXG4gICAgICAgIGZyb21CeXRlcyhiKSB7XG4gICAgICAgICAgICBpZiAoYi5sZW5ndGggIT09IEZwMi5CWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyb21CeXRlcyB3cm9uZyBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiB7IGMwOiBGcC5mcm9tQnl0ZXMoYi5zdWJhcnJheSgwLCBGcC5CWVRFUykpLCBjMTogRnAuZnJvbUJ5dGVzKGIuc3ViYXJyYXkoRnAuQllURVMpKSB9O1xuICAgICAgICB9LFxuICAgICAgICB0b0J5dGVzOiAoeyBjMCwgYzEgfSkgPT4gY29uY2F0Qnl0ZXMoRnAudG9CeXRlcyhjMCksIEZwLnRvQnl0ZXMoYzEpKSxcbiAgICAgICAgY21vdjogKHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSwgYykgPT4gKHtcbiAgICAgICAgICAgIGMwOiBGcC5jbW92KGMwLCByMCwgYyksXG4gICAgICAgICAgICBjMTogRnAuY21vdihjMSwgcjEsIGMpLFxuICAgICAgICB9KSxcbiAgICAgICAgcmVpbTogKHsgYzAsIGMxIH0pID0+ICh7IHJlOiBjMCwgaW06IGMxIH0pLFxuICAgICAgICAvLyBtdWx0aXBseSBieSB1ICsgMVxuICAgICAgICBtdWxCeU5vbnJlc2lkdWU6ICh7IGMwLCBjMSB9KSA9PiBGcDIubXVsKHsgYzAsIGMxIH0sIEZwMk5vbnJlc2lkdWUpLFxuICAgICAgICBtdWxCeUI6IG9wdHMuRnAybXVsQnlCLFxuICAgICAgICBmcm9tQmlnVHVwbGU6IEZwMmZyb21CaWdUdXBsZSxcbiAgICAgICAgZnJvYmVuaXVzTWFwOiAoeyBjMCwgYzEgfSwgcG93ZXIpID0+ICh7XG4gICAgICAgICAgICBjMCxcbiAgICAgICAgICAgIGMxOiBGcC5tdWwoYzEsIEZQMl9GUk9CRU5JVVNfQ09FRkZJQ0lFTlRTW3Bvd2VyICUgMl0pLFxuICAgICAgICB9KSxcbiAgICB9O1xuICAgIC8vIEZwNlxuICAgIGNvbnN0IEZwNkFkZCA9ICh7IGMwLCBjMSwgYzIgfSwgeyBjMDogcjAsIGMxOiByMSwgYzI6IHIyIH0pID0+ICh7XG4gICAgICAgIGMwOiBGcDIuYWRkKGMwLCByMCksXG4gICAgICAgIGMxOiBGcDIuYWRkKGMxLCByMSksXG4gICAgICAgIGMyOiBGcDIuYWRkKGMyLCByMiksXG4gICAgfSk7XG4gICAgY29uc3QgRnA2U3VidHJhY3QgPSAoeyBjMCwgYzEsIGMyIH0sIHsgYzA6IHIwLCBjMTogcjEsIGMyOiByMiB9KSA9PiAoe1xuICAgICAgICBjMDogRnAyLnN1YihjMCwgcjApLFxuICAgICAgICBjMTogRnAyLnN1YihjMSwgcjEpLFxuICAgICAgICBjMjogRnAyLnN1YihjMiwgcjIpLFxuICAgIH0pO1xuICAgIGNvbnN0IEZwNk11bHRpcGx5ID0gKHsgYzAsIGMxLCBjMiB9LCByaHMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByaHMgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGMwOiBGcDIubXVsKGMwLCByaHMpLFxuICAgICAgICAgICAgICAgIGMxOiBGcDIubXVsKGMxLCByaHMpLFxuICAgICAgICAgICAgICAgIGMyOiBGcDIubXVsKGMyLCByaHMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGMwOiByMCwgYzE6IHIxLCBjMjogcjIgfSA9IHJocztcbiAgICAgICAgY29uc3QgdDAgPSBGcDIubXVsKGMwLCByMCk7IC8vIGMwICogbzBcbiAgICAgICAgY29uc3QgdDEgPSBGcDIubXVsKGMxLCByMSk7IC8vIGMxICogbzFcbiAgICAgICAgY29uc3QgdDIgPSBGcDIubXVsKGMyLCByMik7IC8vIGMyICogbzJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIHQwICsgKGMxICsgYzIpICogKHIxICogcjIpIC0gKFQxICsgVDIpICogKHUgKyAxKVxuICAgICAgICAgICAgYzA6IEZwMi5hZGQodDAsIEZwMi5tdWxCeU5vbnJlc2lkdWUoRnAyLnN1YihGcDIubXVsKEZwMi5hZGQoYzEsIGMyKSwgRnAyLmFkZChyMSwgcjIpKSwgRnAyLmFkZCh0MSwgdDIpKSkpLFxuICAgICAgICAgICAgLy8gKGMwICsgYzEpICogKHIwICsgcjEpIC0gKFQwICsgVDEpICsgVDIgKiAodSArIDEpXG4gICAgICAgICAgICBjMTogRnAyLmFkZChGcDIuc3ViKEZwMi5tdWwoRnAyLmFkZChjMCwgYzEpLCBGcDIuYWRkKHIwLCByMSkpLCBGcDIuYWRkKHQwLCB0MSkpLCBGcDIubXVsQnlOb25yZXNpZHVlKHQyKSksXG4gICAgICAgICAgICAvLyBUMSArIChjMCArIGMyKSAqIChyMCArIHIyKSAtIFQwICsgVDJcbiAgICAgICAgICAgIGMyOiBGcDIuc3ViKEZwMi5hZGQodDEsIEZwMi5tdWwoRnAyLmFkZChjMCwgYzIpLCBGcDIuYWRkKHIwLCByMikpKSwgRnAyLmFkZCh0MCwgdDIpKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IEZwNlNxdWFyZSA9ICh7IGMwLCBjMSwgYzIgfSkgPT4ge1xuICAgICAgICBsZXQgdDAgPSBGcDIuc3FyKGMwKTsgLy8gYzDCslxuICAgICAgICBsZXQgdDEgPSBGcDIubXVsKEZwMi5tdWwoYzAsIGMxKSwgXzJuKTsgLy8gMiAqIGMwICogYzFcbiAgICAgICAgbGV0IHQzID0gRnAyLm11bChGcDIubXVsKGMxLCBjMiksIF8ybik7IC8vIDIgKiBjMSAqIGMyXG4gICAgICAgIGxldCB0NCA9IEZwMi5zcXIoYzIpOyAvLyBjMsKyXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKHQzKSwgdDApLCAvLyBUMyAqICh1ICsgMSkgKyBUMFxuICAgICAgICAgICAgYzE6IEZwMi5hZGQoRnAyLm11bEJ5Tm9ucmVzaWR1ZSh0NCksIHQxKSwgLy8gVDQgKiAodSArIDEpICsgVDFcbiAgICAgICAgICAgIC8vIFQxICsgKGMwIC0gYzEgKyBjMinCsiArIFQzIC0gVDAgLSBUNFxuICAgICAgICAgICAgYzI6IEZwMi5zdWIoRnAyLnN1YihGcDIuYWRkKEZwMi5hZGQodDEsIEZwMi5zcXIoRnAyLmFkZChGcDIuc3ViKGMwLCBjMSksIGMyKSkpLCB0MyksIHQwKSwgdDQpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgW0ZQNl9GUk9CRU5JVVNfQ09FRkZJQ0lFTlRTXzEsIEZQNl9GUk9CRU5JVVNfQ09FRkZJQ0lFTlRTXzJdID0gY2FsY0Zyb2Jlbml1c0NvZWZmaWNpZW50cyhGcDIsIEZwMk5vbnJlc2lkdWUsIEZwLk9SREVSLCA2LCAyLCAzKTtcbiAgICBjb25zdCBGcDYgPSB7XG4gICAgICAgIE9SREVSOiBGcDIuT1JERVIsIC8vIFRPRE86IHVudXNlZCwgYnV0IG5lZWQgdG8gdmVyaWZ5XG4gICAgICAgIEJJVFM6IDMgKiBGcDIuQklUUyxcbiAgICAgICAgQllURVM6IDMgKiBGcDIuQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soMyAqIEZwMi5CSVRTKSxcbiAgICAgICAgWkVSTzogeyBjMDogRnAyLlpFUk8sIGMxOiBGcDIuWkVSTywgYzI6IEZwMi5aRVJPIH0sXG4gICAgICAgIE9ORTogeyBjMDogRnAyLk9ORSwgYzE6IEZwMi5aRVJPLCBjMjogRnAyLlpFUk8gfSxcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBudW0sXG4gICAgICAgIGlzVmFsaWQ6ICh7IGMwLCBjMSwgYzIgfSkgPT4gRnAyLmlzVmFsaWQoYzApICYmIEZwMi5pc1ZhbGlkKGMxKSAmJiBGcDIuaXNWYWxpZChjMiksXG4gICAgICAgIGlzMDogKHsgYzAsIGMxLCBjMiB9KSA9PiBGcDIuaXMwKGMwKSAmJiBGcDIuaXMwKGMxKSAmJiBGcDIuaXMwKGMyKSxcbiAgICAgICAgbmVnOiAoeyBjMCwgYzEsIGMyIH0pID0+ICh7IGMwOiBGcDIubmVnKGMwKSwgYzE6IEZwMi5uZWcoYzEpLCBjMjogRnAyLm5lZyhjMikgfSksXG4gICAgICAgIGVxbDogKHsgYzAsIGMxLCBjMiB9LCB7IGMwOiByMCwgYzE6IHIxLCBjMjogcjIgfSkgPT4gRnAyLmVxbChjMCwgcjApICYmIEZwMi5lcWwoYzEsIHIxKSAmJiBGcDIuZXFsKGMyLCByMiksXG4gICAgICAgIHNxcnQ6IG5vdEltcGxlbWVudGVkLFxuICAgICAgICAvLyBEbyB3ZSBuZWVkIGRpdmlzaW9uIGJ5IGJpZ2ludCBhdCBhbGw/IFNob3VsZCBiZSBkb25lIHZpYSBvcmRlcjpcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IEZwNi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IEZwLmludihGcC5jcmVhdGUocmhzKSkgOiBGcDYuaW52KHJocykpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBtb2QuRnBQb3coRnA2LCBudW0sIHBvd2VyKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChudW1zKSA9PiBtb2QuRnBJbnZlcnRCYXRjaChGcDYsIG51bXMpLFxuICAgICAgICAvLyBOb3JtYWxpemVkXG4gICAgICAgIGFkZDogRnA2QWRkLFxuICAgICAgICBzdWI6IEZwNlN1YnRyYWN0LFxuICAgICAgICBtdWw6IEZwNk11bHRpcGx5LFxuICAgICAgICBzcXI6IEZwNlNxdWFyZSxcbiAgICAgICAgLy8gTm9uTm9ybWFsaXplZCBzdHVmZlxuICAgICAgICBhZGROOiBGcDZBZGQsXG4gICAgICAgIHN1Yk46IEZwNlN1YnRyYWN0LFxuICAgICAgICBtdWxOOiBGcDZNdWx0aXBseSxcbiAgICAgICAgc3FyTjogRnA2U3F1YXJlLFxuICAgICAgICBpbnY6ICh7IGMwLCBjMSwgYzIgfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHQwID0gRnAyLnN1YihGcDIuc3FyKGMwKSwgRnAyLm11bEJ5Tm9ucmVzaWR1ZShGcDIubXVsKGMyLCBjMSkpKTsgLy8gYzDCsiAtIGMyICogYzEgKiAodSArIDEpXG4gICAgICAgICAgICBsZXQgdDEgPSBGcDIuc3ViKEZwMi5tdWxCeU5vbnJlc2lkdWUoRnAyLnNxcihjMikpLCBGcDIubXVsKGMwLCBjMSkpOyAvLyBjMsKyICogKHUgKyAxKSAtIGMwICogYzFcbiAgICAgICAgICAgIGxldCB0MiA9IEZwMi5zdWIoRnAyLnNxcihjMSksIEZwMi5tdWwoYzAsIGMyKSk7IC8vIGMxwrIgLSBjMCAqIGMyXG4gICAgICAgICAgICAvLyAxLygoKGMyICogVDEgKyBjMSAqIFQyKSAqIHYpICsgYzAgKiBUMClcbiAgICAgICAgICAgIGxldCB0NCA9IEZwMi5pbnYoRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKEZwMi5hZGQoRnAyLm11bChjMiwgdDEpLCBGcDIubXVsKGMxLCB0MikpKSwgRnAyLm11bChjMCwgdDApKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjMDogRnAyLm11bCh0NCwgdDApLCBjMTogRnAyLm11bCh0NCwgdDEpLCBjMjogRnAyLm11bCh0NCwgdDIpIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEJ5dGVzIHV0aWxzXG4gICAgICAgIGZyb21CeXRlczogKGIpID0+IHtcbiAgICAgICAgICAgIGlmIChiLmxlbmd0aCAhPT0gRnA2LkJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJvbUJ5dGVzIHdyb25nIGxlbmd0aD0ke2IubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjMDogRnAyLmZyb21CeXRlcyhiLnN1YmFycmF5KDAsIEZwMi5CWVRFUykpLFxuICAgICAgICAgICAgICAgIGMxOiBGcDIuZnJvbUJ5dGVzKGIuc3ViYXJyYXkoRnAyLkJZVEVTLCAyICogRnAyLkJZVEVTKSksXG4gICAgICAgICAgICAgICAgYzI6IEZwMi5mcm9tQnl0ZXMoYi5zdWJhcnJheSgyICogRnAyLkJZVEVTKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB0b0J5dGVzOiAoeyBjMCwgYzEsIGMyIH0pID0+IGNvbmNhdEJ5dGVzKEZwMi50b0J5dGVzKGMwKSwgRnAyLnRvQnl0ZXMoYzEpLCBGcDIudG9CeXRlcyhjMikpLFxuICAgICAgICBjbW92OiAoeyBjMCwgYzEsIGMyIH0sIHsgYzA6IHIwLCBjMTogcjEsIGMyOiByMiB9LCBjKSA9PiAoe1xuICAgICAgICAgICAgYzA6IEZwMi5jbW92KGMwLCByMCwgYyksXG4gICAgICAgICAgICBjMTogRnAyLmNtb3YoYzEsIHIxLCBjKSxcbiAgICAgICAgICAgIGMyOiBGcDIuY21vdihjMiwgcjIsIGMpLFxuICAgICAgICB9KSxcbiAgICAgICAgZnJvbUJpZ1NpeDogKHQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0KSB8fCB0Lmxlbmd0aCAhPT0gNilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRnA2IHVzYWdlJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGMwOiBGcDIuZnJvbUJpZ1R1cGxlKHQuc2xpY2UoMCwgMikpLFxuICAgICAgICAgICAgICAgIGMxOiBGcDIuZnJvbUJpZ1R1cGxlKHQuc2xpY2UoMiwgNCkpLFxuICAgICAgICAgICAgICAgIGMyOiBGcDIuZnJvbUJpZ1R1cGxlKHQuc2xpY2UoNCwgNikpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvYmVuaXVzTWFwOiAoeyBjMCwgYzEsIGMyIH0sIHBvd2VyKSA9PiAoe1xuICAgICAgICAgICAgYzA6IEZwMi5mcm9iZW5pdXNNYXAoYzAsIHBvd2VyKSxcbiAgICAgICAgICAgIGMxOiBGcDIubXVsKEZwMi5mcm9iZW5pdXNNYXAoYzEsIHBvd2VyKSwgRlA2X0ZST0JFTklVU19DT0VGRklDSUVOVFNfMVtwb3dlciAlIDZdKSxcbiAgICAgICAgICAgIGMyOiBGcDIubXVsKEZwMi5mcm9iZW5pdXNNYXAoYzIsIHBvd2VyKSwgRlA2X0ZST0JFTklVU19DT0VGRklDSUVOVFNfMltwb3dlciAlIDZdKSxcbiAgICAgICAgfSksXG4gICAgICAgIG11bEJ5RnAyOiAoeyBjMCwgYzEsIGMyIH0sIHJocykgPT4gKHtcbiAgICAgICAgICAgIGMwOiBGcDIubXVsKGMwLCByaHMpLFxuICAgICAgICAgICAgYzE6IEZwMi5tdWwoYzEsIHJocyksXG4gICAgICAgICAgICBjMjogRnAyLm11bChjMiwgcmhzKSxcbiAgICAgICAgfSksXG4gICAgICAgIG11bEJ5Tm9ucmVzaWR1ZTogKHsgYzAsIGMxLCBjMiB9KSA9PiAoeyBjMDogRnAyLm11bEJ5Tm9ucmVzaWR1ZShjMiksIGMxOiBjMCwgYzI6IGMxIH0pLFxuICAgICAgICAvLyBTcGFyc2UgbXVsdGlwbGljYXRpb25cbiAgICAgICAgbXVsMTogKHsgYzAsIGMxLCBjMiB9LCBiMSkgPT4gKHtcbiAgICAgICAgICAgIGMwOiBGcDIubXVsQnlOb25yZXNpZHVlKEZwMi5tdWwoYzIsIGIxKSksXG4gICAgICAgICAgICBjMTogRnAyLm11bChjMCwgYjEpLFxuICAgICAgICAgICAgYzI6IEZwMi5tdWwoYzEsIGIxKSxcbiAgICAgICAgfSksXG4gICAgICAgIC8vIFNwYXJzZSBtdWx0aXBsaWNhdGlvblxuICAgICAgICBtdWwwMSh7IGMwLCBjMSwgYzIgfSwgYjAsIGIxKSB7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcDIubXVsKGMwLCBiMCk7IC8vIGMwICogYjBcbiAgICAgICAgICAgIGxldCB0MSA9IEZwMi5tdWwoYzEsIGIxKTsgLy8gYzEgKiBiMVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyAoKGMxICsgYzIpICogYjEgLSBUMSkgKiAodSArIDEpICsgVDBcbiAgICAgICAgICAgICAgICBjMDogRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKEZwMi5zdWIoRnAyLm11bChGcDIuYWRkKGMxLCBjMiksIGIxKSwgdDEpKSwgdDApLFxuICAgICAgICAgICAgICAgIC8vIChiMCArIGIxKSAqIChjMCArIGMxKSAtIFQwIC0gVDFcbiAgICAgICAgICAgICAgICBjMTogRnAyLnN1YihGcDIuc3ViKEZwMi5tdWwoRnAyLmFkZChiMCwgYjEpLCBGcDIuYWRkKGMwLCBjMSkpLCB0MCksIHQxKSxcbiAgICAgICAgICAgICAgICAvLyAoYzAgKyBjMikgKiBiMCAtIFQwICsgVDFcbiAgICAgICAgICAgICAgICBjMjogRnAyLmFkZChGcDIuc3ViKEZwMi5tdWwoRnAyLmFkZChjMCwgYzIpLCBiMCksIHQwKSwgdDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8vIEZwMTJcbiAgICBjb25zdCBGUDEyX0ZST0JFTklVU19DT0VGRklDSUVOVFMgPSBjYWxjRnJvYmVuaXVzQ29lZmZpY2llbnRzKEZwMiwgRnAyTm9ucmVzaWR1ZSwgRnAuT1JERVIsIDEyLCAxLCA2KVswXTtcbiAgICBjb25zdCBGcDEyQWRkID0gKHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSkgPT4gKHtcbiAgICAgICAgYzA6IEZwNi5hZGQoYzAsIHIwKSxcbiAgICAgICAgYzE6IEZwNi5hZGQoYzEsIHIxKSxcbiAgICB9KTtcbiAgICBjb25zdCBGcDEyU3VidHJhY3QgPSAoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9KSA9PiAoe1xuICAgICAgICBjMDogRnA2LnN1YihjMCwgcjApLFxuICAgICAgICBjMTogRnA2LnN1YihjMSwgcjEpLFxuICAgIH0pO1xuICAgIGNvbnN0IEZwMTJNdWx0aXBseSA9ICh7IGMwLCBjMSB9LCByaHMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByaHMgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIHsgYzA6IEZwNi5tdWwoYzAsIHJocyksIGMxOiBGcDYubXVsKGMxLCByaHMpIH07XG4gICAgICAgIGxldCB7IGMwOiByMCwgYzE6IHIxIH0gPSByaHM7XG4gICAgICAgIGxldCB0MSA9IEZwNi5tdWwoYzAsIHIwKTsgLy8gYzAgKiByMFxuICAgICAgICBsZXQgdDIgPSBGcDYubXVsKGMxLCByMSk7IC8vIGMxICogcjFcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGMwOiBGcDYuYWRkKHQxLCBGcDYubXVsQnlOb25yZXNpZHVlKHQyKSksIC8vIFQxICsgVDIgKiB2XG4gICAgICAgICAgICAvLyAoYzAgKyBjMSkgKiAocjAgKyByMSkgLSAoVDEgKyBUMilcbiAgICAgICAgICAgIGMxOiBGcDYuc3ViKEZwNi5tdWwoRnA2LmFkZChjMCwgYzEpLCBGcDYuYWRkKHIwLCByMSkpLCBGcDYuYWRkKHQxLCB0MikpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgRnAxMlNxdWFyZSA9ICh7IGMwLCBjMSB9KSA9PiB7XG4gICAgICAgIGxldCBhYiA9IEZwNi5tdWwoYzAsIGMxKTsgLy8gYzAgKiBjMVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gKGMxICogdiArIGMwKSAqIChjMCArIGMxKSAtIEFCIC0gQUIgKiB2XG4gICAgICAgICAgICBjMDogRnA2LnN1YihGcDYuc3ViKEZwNi5tdWwoRnA2LmFkZChGcDYubXVsQnlOb25yZXNpZHVlKGMxKSwgYzApLCBGcDYuYWRkKGMwLCBjMSkpLCBhYiksIEZwNi5tdWxCeU5vbnJlc2lkdWUoYWIpKSxcbiAgICAgICAgICAgIGMxOiBGcDYuYWRkKGFiLCBhYiksXG4gICAgICAgIH07IC8vIEFCICsgQUJcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEZwNFNxdWFyZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGEyID0gRnAyLnNxcihhKTtcbiAgICAgICAgY29uc3QgYjIgPSBGcDIuc3FyKGIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlyc3Q6IEZwMi5hZGQoRnAyLm11bEJ5Tm9ucmVzaWR1ZShiMiksIGEyKSwgLy8gYsKyICogTm9ucmVzaWR1ZSArIGHCslxuICAgICAgICAgICAgc2Vjb25kOiBGcDIuc3ViKEZwMi5zdWIoRnAyLnNxcihGcDIuYWRkKGEsIGIpKSwgYTIpLCBiMiksIC8vIChhICsgYinCsiAtIGHCsiAtIGLCslxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBGcDEyID0ge1xuICAgICAgICBPUkRFUjogRnAyLk9SREVSLCAvLyBUT0RPOiB1bnVzZWQsIGJ1dCBuZWVkIHRvIHZlcmlmeVxuICAgICAgICBCSVRTOiAyICogRnAyLkJJVFMsXG4gICAgICAgIEJZVEVTOiAyICogRnAyLkJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKDIgKiBGcDIuQklUUyksXG4gICAgICAgIFpFUk86IHsgYzA6IEZwNi5aRVJPLCBjMTogRnA2LlpFUk8gfSxcbiAgICAgICAgT05FOiB7IGMwOiBGcDYuT05FLCBjMTogRnA2LlpFUk8gfSxcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBudW0sXG4gICAgICAgIGlzVmFsaWQ6ICh7IGMwLCBjMSB9KSA9PiBGcDYuaXNWYWxpZChjMCkgJiYgRnA2LmlzVmFsaWQoYzEpLFxuICAgICAgICBpczA6ICh7IGMwLCBjMSB9KSA9PiBGcDYuaXMwKGMwKSAmJiBGcDYuaXMwKGMxKSxcbiAgICAgICAgbmVnOiAoeyBjMCwgYzEgfSkgPT4gKHsgYzA6IEZwNi5uZWcoYzApLCBjMTogRnA2Lm5lZyhjMSkgfSksXG4gICAgICAgIGVxbDogKHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSkgPT4gRnA2LmVxbChjMCwgcjApICYmIEZwNi5lcWwoYzEsIHIxKSxcbiAgICAgICAgc3FydDogbm90SW1wbGVtZW50ZWQsXG4gICAgICAgIGludjogKHsgYzAsIGMxIH0pID0+IHtcbiAgICAgICAgICAgIGxldCB0ID0gRnA2LmludihGcDYuc3ViKEZwNi5zcXIoYzApLCBGcDYubXVsQnlOb25yZXNpZHVlKEZwNi5zcXIoYzEpKSkpOyAvLyAxIC8gKGMwwrIgLSBjMcKyICogdilcbiAgICAgICAgICAgIHJldHVybiB7IGMwOiBGcDYubXVsKGMwLCB0KSwgYzE6IEZwNi5uZWcoRnA2Lm11bChjMSwgdCkpIH07IC8vICgoQzAgKiBUKSAqIFQpICsgKC1DMSAqIFQpICogd1xuICAgICAgICB9LFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gRnAxMi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IEZwLmludihGcC5jcmVhdGUocmhzKSkgOiBGcDEyLmludihyaHMpKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gbW9kLkZwUG93KEZwMTIsIG51bSwgcG93ZXIpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKG51bXMpID0+IG1vZC5GcEludmVydEJhdGNoKEZwMTIsIG51bXMpLFxuICAgICAgICAvLyBOb3JtYWxpemVkXG4gICAgICAgIGFkZDogRnAxMkFkZCxcbiAgICAgICAgc3ViOiBGcDEyU3VidHJhY3QsXG4gICAgICAgIG11bDogRnAxMk11bHRpcGx5LFxuICAgICAgICBzcXI6IEZwMTJTcXVhcmUsXG4gICAgICAgIC8vIE5vbk5vcm1hbGl6ZWQgc3R1ZmZcbiAgICAgICAgYWRkTjogRnAxMkFkZCxcbiAgICAgICAgc3ViTjogRnAxMlN1YnRyYWN0LFxuICAgICAgICBtdWxOOiBGcDEyTXVsdGlwbHksXG4gICAgICAgIHNxck46IEZwMTJTcXVhcmUsXG4gICAgICAgIC8vIEJ5dGVzIHV0aWxzXG4gICAgICAgIGZyb21CeXRlczogKGIpID0+IHtcbiAgICAgICAgICAgIGlmIChiLmxlbmd0aCAhPT0gRnAxMi5CWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyb21CeXRlcyB3cm9uZyBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYzA6IEZwNi5mcm9tQnl0ZXMoYi5zdWJhcnJheSgwLCBGcDYuQllURVMpKSxcbiAgICAgICAgICAgICAgICBjMTogRnA2LmZyb21CeXRlcyhiLnN1YmFycmF5KEZwNi5CWVRFUykpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9CeXRlczogKHsgYzAsIGMxIH0pID0+IGNvbmNhdEJ5dGVzKEZwNi50b0J5dGVzKGMwKSwgRnA2LnRvQnl0ZXMoYzEpKSxcbiAgICAgICAgY21vdjogKHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSwgYykgPT4gKHtcbiAgICAgICAgICAgIGMwOiBGcDYuY21vdihjMCwgcjAsIGMpLFxuICAgICAgICAgICAgYzE6IEZwNi5jbW92KGMxLCByMSwgYyksXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBVdGlsc1xuICAgICAgICAvLyB0b1N0cmluZygpIHtcbiAgICAgICAgLy8gICByZXR1cm4gYEZwMTIoJHt0aGlzLmMwfSArICR7dGhpcy5jMX0gKiB3KWA7XG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIGZyb21UdXBsZShjOiBbRnA2LCBGcDZdKSB7XG4gICAgICAgIC8vICAgcmV0dXJuIG5ldyBGcDEyKC4uLmMpO1xuICAgICAgICAvLyB9XG4gICAgICAgIGZyb21CaWdUd2VsdmU6ICh0KSA9PiAoe1xuICAgICAgICAgICAgYzA6IEZwNi5mcm9tQmlnU2l4KHQuc2xpY2UoMCwgNikpLFxuICAgICAgICAgICAgYzE6IEZwNi5mcm9tQmlnU2l4KHQuc2xpY2UoNiwgMTIpKSxcbiAgICAgICAgfSksXG4gICAgICAgIC8vIFJhaXNlcyB0byBxKippIC10aCBwb3dlclxuICAgICAgICBmcm9iZW5pdXNNYXAobGhzLCBwb3dlcikge1xuICAgICAgICAgICAgY29uc3QgeyBjMCwgYzEsIGMyIH0gPSBGcDYuZnJvYmVuaXVzTWFwKGxocy5jMSwgcG93ZXIpO1xuICAgICAgICAgICAgY29uc3QgY29lZmYgPSBGUDEyX0ZST0JFTklVU19DT0VGRklDSUVOVFNbcG93ZXIgJSAxMl07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGMwOiBGcDYuZnJvYmVuaXVzTWFwKGxocy5jMCwgcG93ZXIpLFxuICAgICAgICAgICAgICAgIGMxOiBGcDYuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYzA6IEZwMi5tdWwoYzAsIGNvZWZmKSxcbiAgICAgICAgICAgICAgICAgICAgYzE6IEZwMi5tdWwoYzEsIGNvZWZmKSxcbiAgICAgICAgICAgICAgICAgICAgYzI6IEZwMi5tdWwoYzIsIGNvZWZmKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG11bEJ5RnAyOiAoeyBjMCwgYzEgfSwgcmhzKSA9PiAoe1xuICAgICAgICAgICAgYzA6IEZwNi5tdWxCeUZwMihjMCwgcmhzKSxcbiAgICAgICAgICAgIGMxOiBGcDYubXVsQnlGcDIoYzEsIHJocyksXG4gICAgICAgIH0pLFxuICAgICAgICBjb25qdWdhdGU6ICh7IGMwLCBjMSB9KSA9PiAoeyBjMCwgYzE6IEZwNi5uZWcoYzEpIH0pLFxuICAgICAgICAvLyBTcGFyc2UgbXVsdGlwbGljYXRpb25cbiAgICAgICAgbXVsMDE0OiAoeyBjMCwgYzEgfSwgbzAsIG8xLCBvNCkgPT4ge1xuICAgICAgICAgICAgbGV0IHQwID0gRnA2Lm11bDAxKGMwLCBvMCwgbzEpO1xuICAgICAgICAgICAgbGV0IHQxID0gRnA2Lm11bDEoYzEsIG80KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYzA6IEZwNi5hZGQoRnA2Lm11bEJ5Tm9ucmVzaWR1ZSh0MSksIHQwKSwgLy8gVDEgKiB2ICsgVDBcbiAgICAgICAgICAgICAgICAvLyAoYzEgKyBjMCkgKiBbbzAsIG8xK280XSAtIFQwIC0gVDFcbiAgICAgICAgICAgICAgICBjMTogRnA2LnN1YihGcDYuc3ViKEZwNi5tdWwwMShGcDYuYWRkKGMxLCBjMCksIG8wLCBGcDIuYWRkKG8xLCBvNCkpLCB0MCksIHQxKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG11bDAzNDogKHsgYzAsIGMxIH0sIG8wLCBvMywgbzQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBGcDYuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBjMDogRnAyLm11bChjMC5jMCwgbzApLFxuICAgICAgICAgICAgICAgIGMxOiBGcDIubXVsKGMwLmMxLCBvMCksXG4gICAgICAgICAgICAgICAgYzI6IEZwMi5tdWwoYzAuYzIsIG8wKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYiA9IEZwNi5tdWwwMShjMSwgbzMsIG80KTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBGcDYubXVsMDEoRnA2LmFkZChjMCwgYzEpLCBGcDIuYWRkKG8wLCBvMyksIG80KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYzA6IEZwNi5hZGQoRnA2Lm11bEJ5Tm9ucmVzaWR1ZShiKSwgYSksXG4gICAgICAgICAgICAgICAgYzE6IEZwNi5zdWIoZSwgRnA2LmFkZChhLCBiKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvLyBBIGN5Y2xvdG9taWMgZ3JvdXAgaXMgYSBzdWJncm91cCBvZiBGcF5uIGRlZmluZWQgYnlcbiAgICAgICAgLy8gICBHzqbigpkocCkgPSB7zrEg4oiIIEZw4oG/IDogzrFezqbigpkocCkgPSAxfVxuICAgICAgICAvLyBUaGUgcmVzdWx0IG9mIGFueSBwYWlyaW5nIGlzIGluIGEgY3ljbG90b21pYyBzdWJncm91cFxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDA5LzU2NS5wZGZcbiAgICAgICAgX2N5Y2xvdG9taWNTcXVhcmU6IG9wdHMuRnAxMmN5Y2xvdG9taWNTcXVhcmUsXG4gICAgICAgIF9jeWNsb3RvbWljRXhwOiBvcHRzLkZwMTJjeWNsb3RvbWljRXhwLFxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzM1NC5wZGZcbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAwOS81NjUucGRmXG4gICAgICAgIGZpbmFsRXhwb25lbnRpYXRlOiBvcHRzLkZwMTJmaW5hbEV4cG9uZW50aWF0ZSxcbiAgICB9O1xuICAgIHJldHVybiB7IEZwLCBGcDIsIEZwNiwgRnA0U3F1YXJlLCBGcDEyIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3dlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/tower.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(`${title} must be valid boolean, got \"${value}\".`);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkIsT0FBTyw4QkFBOEIsTUFBTTtBQUN0RTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU0sSUFBSSxLQUFLLFNBQVMsSUFBSSxRQUFRLFVBQVUsRUFBRSxFQUFFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDTztBQUNQO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDbkQsOERBQThEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixHQUFHLEtBQUssR0FBRyxXQUFXLGNBQWMsS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsV0FBVyxZQUFZLElBQUk7QUFDcEQsa0NBQWtDLG9CQUFvQixJQUFJLGFBQWEsR0FBRztBQUMxRTtBQUNBLGtDQUFrQyxVQUFVLElBQUksU0FBUztBQUN6RCxrQ0FBa0Msb0JBQW9CLElBQUksU0FBUztBQUNuRSxrQ0FBa0MsMkJBQTJCO0FBQzdELGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWJ5dGVzKGl0ZW0pIHtcbiAgICBpZiAoIWlzQnl0ZXMoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFib29sKHRpdGxlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGJvb2xlYW4sIGdvdCBcIiR7dmFsdWV9XCIuYCk7XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtoZXh9XCIuIENhdXNlOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCeXRlcyhoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vLyBJcyBwb3NpdGl2ZSBiaWdpbnRcbmNvbnN0IGlzUG9zQmlnID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiBfMG4gPD0gbjtcbmV4cG9ydCBmdW5jdGlvbiBpblJhbmdlKG4sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGlzUG9zQmlnKG4pICYmIGlzUG9zQmlnKG1pbikgJiYgaXNQb3NCaWcobWF4KSAmJiBtaW4gPD0gbiAmJiBuIDwgbWF4O1xufVxuLyoqXG4gKiBBc3NlcnRzIG1pbiA8PSBuIDwgbWF4LiBOT1RFOiBJdCdzIDwgbWF4IGFuZCBub3QgPD0gbWF4LlxuICogQGV4YW1wbGVcbiAqIGFJblJhbmdlKCd4JywgeCwgMW4sIDI1Nm4pOyAvLyB3b3VsZCBhc3N1bWUgeCBpcyBpbiAoMW4uLjI1NW4pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhSW5SYW5nZSh0aXRsZSwgbiwgbWluLCBtYXgpIHtcbiAgICAvLyBXaHkgbWluIDw9IG4gPCBtYXggYW5kIG5vdCBhIChtaW4gPCBuIDwgbWF4KSBPUiBiIChtaW4gPD0gbiA8PSBtYXgpP1xuICAgIC8vIGNvbnNpZGVyIFA9MjU2biwgbWluPTBuLCBtYXg9UFxuICAgIC8vIC0gYSBmb3IgbWluPTAgd291bGQgcmVxdWlyZSAtMTogICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAtMW4sIFApYFxuICAgIC8vIC0gYiB3b3VsZCBjb21tb25seSByZXF1aXJlIHN1YnRyYWN0aW9uOiAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUCAtIDFuKWBcbiAgICAvLyAtIG91ciB3YXkgaXMgdGhlIGNsZWFuZXN0OiAgICAgICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgMG4sIFApXG4gICAgaWYgKCFpblJhbmdlKG4sIG1pbiwgbWF4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCB2YWxpZCAke3RpdGxlfTogJHttaW59IDw9IG4gPCAke21heH0sIGdvdCAke3R5cGVvZiBufSAke259YCk7XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRTZXQobiwgcG9zLCB2YWx1ZSkge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8qKlxuICogdGhyb3dzIG5vdCBpbXBsZW1lbnRlZCBlcnJvclxuICovXG5leHBvcnQgY29uc3Qgbm90SW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG4vKipcbiAqIE1lbW9pemVzIChjYWNoZXMpIGNvbXB1dGF0aW9uIHJlc3VsdC5cbiAqIFVzZXMgV2Vha01hcDogdGhlIHZhbHVlIGlzIGdvaW5nIGF1dG8tY2xlYW5lZCBieSBHQyBhZnRlciBsYXN0IHJlZmVyZW5jZSBpcyByZW1vdmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZWQoZm4pIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiAoYXJnLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG1hcC5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBmbihhcmcsIC4uLmFyZ3MpO1xuICAgICAgICBtYXAuc2V0KGFyZywgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_0__;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded((len.length / 2) | 128) : '';\n            return `${_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(tag)}${lenLen}${len}${data}`;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected assertion');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('Invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('Invalid signature integer: unnecessary leading zero');\n            return b2n(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const seq = `${tlv.encode(0x02, int.encode(sig.r))}${tlv.encode(0x02, int.encode(sig.s))}`;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = _modular_js__WEBPACK_IMPORTED_MODULE_2__.Field(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, N); // disabled by default, enabled for BLS\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        if (!Fp.eql(left, right))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('scalar', sc, _0n, CURVE.n);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (sc === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, sc);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(tail);\n                if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        validateSigVerOpts(opts);\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQzZEO0FBQ3pCO0FBQ0g7QUFDeUI7QUFDMUQ7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQSxRQUFRLHdDQUF3QyxFQUFFLHNDQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwREFBc0I7QUFDakUsc0JBQXNCLDBEQUFzQixNQUFNLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxLQUFLO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLHNCQUFzQiwwREFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQSxRQUFRLDZDQUFTO0FBQ2pCLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0MsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkMsdUJBQXVCLG9DQUFvQyxFQUFFLG9DQUFvQztBQUNqRztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLEtBQUssU0FBUztBQUMxQixlQUFlLDhDQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBYztBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2Qiw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVFQUF1RTtBQUN2RjtBQUNBLGdCQUFnQiw4Q0FBVTtBQUMxQixzQkFBc0IsaURBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWtCLENBQUMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLDRCQUE0QixXQUFXO0FBQ3ZHO0FBQ0E7QUFDQSxrQkFBa0IsNENBQU8sVUFBVTtBQUNuQyxRQUFRLCtDQUFXLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBUTtBQUNqQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsbURBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNEQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0Msb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0MsMERBQTBEO0FBQzFELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0IseUJBQXlCO0FBQzdDLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakMsWUFBWSwrQ0FBVztBQUN2Qiw2QkFBNkI7QUFDN0I7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DLHNCQUFzQixpQkFBaUI7QUFDdkMsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFLO0FBQ2pCLG1CQUFtQixpREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLCtCQUErQixzQ0FBc0M7QUFDckU7QUFDTztBQUNQO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5QztBQUNBLGVBQWUsNENBQU87QUFDdEI7QUFDQTtBQUNBLGVBQWUsK0NBQVU7QUFDekI7QUFDQSxZQUFZLDJGQUEyRjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrREFBYztBQUN0QyxZQUFZLGdEQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQWtCO0FBQzVDLHFCQUFxQiw4Q0FBVTtBQUMvQjtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxtREFBbUQsS0FBSyx3QkFBd0IsZUFBZSxzQkFBc0IsaUJBQWlCO0FBQ3RJO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxtQ0FBbUMsaURBQWEsQ0FBQyxzREFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzREFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPLFlBQVksc0RBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBVyxpQ0FBaUM7QUFDeEQsWUFBWSwrQ0FBVyxpQ0FBaUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUMsb0NBQW9DLHNEQUFXLHVCQUF1QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDLGtFQUFrRTtBQUNsRTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWE7QUFDaEM7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlEQUFvQjtBQUMvQyxtQkFBbUIsdURBQWtCO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFrQixTQUFTO0FBQ25ELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsdUJBQXVCLDhDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBVyxZQUFZLGlCQUFpQjtBQUNoRDtBQUNBLGVBQWUsc0RBQWtCO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQyxjQUFjLG1DQUFtQyxRQUFRO0FBQ3pEO0FBQ0EseUJBQXlCO0FBQ3pCLGtCQUFrQixzREFBVztBQUM3QjtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLDBCQUEwQixzREFBVyxzQkFBc0I7QUFDM0Q7QUFDQSxxQkFBcUIsa0RBQWMsZUFBZTtBQUNsRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyx5REFBeUQ7QUFDekQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLCtCQUErQjtBQUMvQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjLG1DQUFtQztBQUNqRTtBQUNBLHFCQUFxQixxREFBaUI7QUFDdEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBVztBQUM3QixvQkFBb0Isc0RBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsOENBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QiwwQ0FBMEM7QUFDMUMsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQSxrQkFBa0I7QUFDbEIsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsNENBQTRDO0FBQzVDO0FBQ0Esc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsb0NBQW9DO0FBQ3BDLCtCQUErQjtBQUMvQix3Q0FBd0M7QUFDeEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEMsK0JBQStCO0FBQy9CLHNDQUFzQztBQUN0Qyx5Q0FBeUM7QUFDekMsNkNBQTZDO0FBQzdDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLHlDQUF5QztBQUN6QywwQ0FBMEM7QUFDMUM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHVDQUF1QztBQUN2QztBQUNBLGlDQUFpQztBQUNqQyxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxrQ0FBa0M7QUFDbEMsdUNBQXVDO0FBQ3ZDLCtDQUErQyxrQkFBa0I7QUFDakUseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQyxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHNEQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1FQUFtRTtBQUNuRSxtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsZ0JBQWdCLGlCQUFpQix1QkFBdUI7QUFDeEQsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QixzQ0FBc0M7QUFDdEMsd0NBQXdDO0FBQ3hDLGdEQUFnRDtBQUNoRCx1Q0FBdUM7QUFDdkMsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCB7IHZhbGlkYXRlQmFzaWMsIHdOQUYsIHBpcHBlbmdlciwgfSBmcm9tICcuL2N1cnZlLmpzJztcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcywgbWVtb2l6ZWQsIGFib29sIH0gZnJvbSAnLi91dGlscy5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cykge1xuICAgIGlmIChvcHRzLmxvd1MgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYWJvb2woJ2xvd1MnLCBvcHRzLmxvd1MpO1xuICAgIGlmIChvcHRzLnByZWhhc2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgYWJvb2woJ3ByZWhhc2gnLCBvcHRzLnByZWhhc2gpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuLyoqXG4gKiBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzLiBBU04gaXMgdmVyeSBjb21wbGV4ICYgZnJhZ2lsZS4gRm9ybWF0OlxuICpcbiAqICAgICBbMHgzMCAoU0VRVUVOQ0UpLCBieXRlbGVuZ3RoLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBSLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBTXVxuICpcbiAqIERvY3M6IGh0dHBzOi8vbGV0c2VuY3J5cHQub3JnL2RvY3MvYS13YXJtLXdlbGNvbWUtdG8tYXNuMS1hbmQtZGVyLywgaHR0cHM6Ly9sdWNhLm50b3Aub3JnL1RlYWNoaW5nL0FwcHVudGkvYXNuMS5odG1sXG4gKi9cbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIEJhc2ljIGJ1aWxkaW5nIGJsb2NrIGlzIFRMViAoVGFnLUxlbmd0aC1WYWx1ZSlcbiAgICBfdGx2OiB7XG4gICAgICAgIGVuY29kZTogKHRhZywgZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB1bnBhZGRlZCBkYXRhJyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhTGVuID0gZGF0YS5sZW5ndGggLyAyO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gdXQubnVtYmVyVG9IZXhVbnBhZGRlZChkYXRhTGVuKTtcbiAgICAgICAgICAgIGlmICgobGVuLmxlbmd0aCAvIDIpICYgMTI4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiBsb25nIGZvcm0gbGVuZ3RoIHRvbyBiaWcnKTtcbiAgICAgICAgICAgIC8vIGxlbmd0aCBvZiBsZW5ndGggd2l0aCBsb25nIGZvcm0gZmxhZ1xuICAgICAgICAgICAgY29uc3QgbGVuTGVuID0gZGF0YUxlbiA+IDEyNyA/IHV0Lm51bWJlclRvSGV4VW5wYWRkZWQoKGxlbi5sZW5ndGggLyAyKSB8IDEyOCkgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBgJHt1dC5udW1iZXJUb0hleFVucGFkZGVkKHRhZyl9JHtsZW5MZW59JHtsZW59JHtkYXRhfWA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHYgLSB2YWx1ZSwgbCAtIGxlZnQgYnl0ZXMgKHVucGFyc2VkKVxuICAgICAgICBkZWNvZGUodGFnLCBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHdyb25nIHRhZycpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhW3BvcysrXSAhPT0gdGFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB0bHYnKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBjb25zdCBpc0xvbmcgPSAhIShmaXJzdCAmIDEyOCk7IC8vIEZpcnN0IGJpdCBvZiBmaXJzdCBsZW5ndGggYnl0ZSBpcyBmbGFnIGZvciBzaG9ydC9sb25nIGZvcm1cbiAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYgKCFpc0xvbmcpXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZmlyc3Q7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMb25nIGZvcm06IFtsb25nRmxhZygxYml0KSwgbGVuZ3RoTGVuZ3RoKDdiaXQpLCBsZW5ndGggKEJFKV1cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBmaXJzdCAmIDEyNztcbiAgICAgICAgICAgICAgICBpZiAoIWxlbkxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IGluZGVmaW5pdGUgbGVuZ3RoIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuTGVuID4gNClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IGJ5dGUgbGVuZ3RoIGlzIHRvbyBiaWcnKTsgLy8gdGhpcyB3aWxsIG92ZXJmbG93IHUzMiBpbiBqc1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbkxlbik7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzLmxlbmd0aCAhPT0gbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogbGVuZ3RoIGJ5dGVzIG5vdCBjb21wbGV0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhCeXRlc1swXSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IHplcm8gbGVmdG1vc3QgYnl0ZScpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiBsZW5ndGhCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCA8PCA4KSB8IGI7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbkxlbjtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDwgMTI4KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogbm90IG1pbmltYWwgZW5jb2RpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHYgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh2Lmxlbmd0aCAhPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB2YWx1ZSBsZW5ndGgnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHYsIGw6IGRhdGEuc3ViYXJyYXkocG9zICsgbGVuZ3RoKSB9O1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgIF9pbnQ6IHtcbiAgICAgICAgZW5jb2RlKG51bSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmIChudW0gPCBfMG4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludGVnZXI6IG5lZ2F0aXZlIGludGVnZXJzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgbGV0IGhleCA9IHV0Lm51bWJlclRvSGV4VW5wYWRkZWQobnVtKTtcbiAgICAgICAgICAgIC8vIFBhZCB3aXRoIHplcm8gYnl0ZSBpZiBuZWdhdGl2ZSBmbGFnIGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoaGV4WzBdLCAxNikgJiAwYjEwMDApXG4gICAgICAgICAgICAgICAgaGV4ID0gJzAwJyArIGhleDtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndW5leHBlY3RlZCBhc3NlcnRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiBoZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSA9PT0gMHgwMCAmJiAhKGRhdGFbMV0gJiAxMjgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgICAgIHJldHVybiBiMm4oZGF0YSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSwgX2ludDogaW50LCBfdGx2OiB0bHYgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIHV0LmFieXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuICAgICAgICBpZiAoc2VxTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcbiAgICAgICAgY29uc3QgeyB2OiBzQnl0ZXMsIGw6IHNMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgckxlZnRCeXRlcyk7XG4gICAgICAgIGlmIChzTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHI6IGludC5kZWNvZGUockJ5dGVzKSwgczogaW50LmRlY29kZShzQnl0ZXMpIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICBjb25zdCB7IF90bHY6IHRsdiwgX2ludDogaW50IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IHNlcSA9IGAke3Rsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucikpfSR7dGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5zKSl9YDtcbiAgICAgICAgcmV0dXJuIHRsdi5lbmNvZGUoMHgzMCwgc2VxKTtcbiAgICB9LFxufTtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzc1BvaW50cyhvcHRzKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZVBvaW50T3B0cyhvcHRzKTtcbiAgICBjb25zdCB7IEZwIH0gPSBDVVJWRTsgLy8gQWxsIGN1cnZlcyBoYXMgc2FtZSBmaWVsZCAvIGdyb3VwIGxlbmd0aCBhcyBmb3Igbm93LCBidXQgdGhleSBjYW4gZGlmZmVyXG4gICAgY29uc3QgRm4gPSBtb2QuRmllbGQoQ1VSVkUubiwgQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gV2UgY2hlY2sgaWYgY3VydmUgZXF1YXRpb24gd29ya3MgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgICAvLyBQcm9qZWN0aXZlUG9pbnQgY2xhc3MgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIoQ1VSVkUuR3kpLCB3ZWllcnN0cmFzc0VxdWF0aW9uKENVUlZFLkd4KSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIC8vIFZhbGlkIGdyb3VwIGVsZW1lbnRzIHJlc2lkZSBpbiByYW5nZSAxLi5uLTFcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB1dC5pblJhbmdlKG51bSwgXzFuLCBDVVJWRS5uKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG46IE4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKHV0LmlzQnl0ZXMoa2V5KSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIE4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgdXQuYUluUmFuZ2UoJ3ByaXZhdGUga2V5JywgbnVtLCBfMW4sIE4pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvLyBNZW1vaXplZCB0b0FmZmluZSAvIHZhbGlkaXR5IGNoZWNrLiBUaGV5IGFyZSBoZWF2eS4gUG9pbnRzIGFyZSBpbW11dGFibGUuXG4gICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICBjb25zdCB0b0FmZmluZU1lbW8gPSBtZW1vaXplZCgocCwgaXopID0+IHtcbiAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSBwO1xuICAgICAgICAvLyBGYXN0LXBhdGggZm9yIG5vcm1hbGl6ZWQgcG9pbnRzXG4gICAgICAgIGlmIChGcC5lcWwoeiwgRnAuT05FKSlcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgY29uc3QgaXMwID0gcC5pczAoKTtcbiAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xuICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgIGlmIChpczApXG4gICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgIH0pO1xuICAgIC8vIE5PVEU6IG9uIGV4Y2VwdGlvbiB0aGlzIHdpbGwgY3Jhc2ggJ2NhY2hlZCcgYW5kIG5vIHZhbHVlIHdpbGwgYmUgc2V0LlxuICAgIC8vIE90aGVyd2lzZSB0cnVlIHdpbGwgYmUgcmV0dXJuXG4gICAgY29uc3QgYXNzZXJ0VmFsaWRNZW1vID0gbWVtb2l6ZWQoKHApID0+IHtcbiAgICAgICAgaWYgKHAuaXMwKCkpIHtcbiAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHAucHkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAudG9BZmZpbmUoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgIGlmICghcC5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXBwZW5nZXIoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBuLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2MpIHtcbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdzY2FsYXInLCBzYywgXzBuLCBDVVJWRS5uKTtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKHNjID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBpZiAoc2MgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIHNjKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2MpO1xuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XG4gICAgICAgICAgICBsZXQgazJwID0gSTtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvLCBuOiBOIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdzY2FsYXInLCBzY2FsYXIsIF8xbiwgTik7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsxcCwgZjogZjFwIH0gPSB0aGlzLndOQUYoazEpO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xuICAgICAgICAgICAgICAgIGsxcCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsxbmVnLCBrMXApO1xuICAgICAgICAgICAgICAgIGsycCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsybmVnLCBrMnApO1xuICAgICAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGYxcC5hZGQoZjJwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKHNjYWxhcik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICByZXR1cm4gdG9BZmZpbmVNZW1vKHRoaXMsIGl6KTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICBhYm9vbCgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIHNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGFuZCBFQ0RTQSBzaWduYXR1cmUgbWV0aG9kcyBmb3IgaXQuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRmllbGQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuICogLy8gQmVmb3JlIHRoYXQsIGRlZmluZSBCaWdJbnQtczogYSwgYiwgcCwgbiwgR3gsIEd5XG4gKiBjb25zdCBjdXJ2ZSA9IHdlaWVyc3RyYXNzKHsgYSwgYiwgRnA6IEZpZWxkKHApLCBuLCBHeCwgR3ksIGg6IDFuIH0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBhYm9vbCgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCF1dC5pblJhbmdlKHgsIF8xbiwgRnAuT1JERVIpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoc3FydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gJzogJyArIHNxcnRFcnJvci5tZXNzYWdlIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyArIHN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhlbnN1cmVCeXRlcygnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdyJywgdGhpcy5yLCBfMW4sIENVUlZFX09SREVSKTsgLy8gciBpbiBbMS4uTl1cbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdzJywgdGhpcy5zLCBfMW4sIENVUlZFX09SREVSKTsgLy8gcyBpbiBbMS4uTl1cbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHV0LmlzQnl0ZXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIHV0LmFJblJhbmdlKGBudW0gPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gLCBudW0sIF8wbiwgT1JERVJfTUFTSyk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLCB0aGlzIHdpbGwgYmUgd3JvbmcgYXQgbGVhc3QgZm9yIFA1MjEuXG4gICAgLy8gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgICAgICBsZXQgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHk6IGVudCB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsICYmIGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goZW5zdXJlQnl0ZXMoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IHV0LmNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZykpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/bls12-381.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/bls12-381.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls12_381: () => (/* binding */ bls12_381)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_bls_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/bls.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/bls.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/modular.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/utils.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_tower_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract/tower.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/tower.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n// Types\n\n\n\n/*\nbls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\n- Construct zk-SNARKs at the 120-bit security\n- Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\n  the Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\n\n### Summary\n1. BLS Relies on Bilinear Pairing (expensive)\n2. Private Keys: 32 bytes\n3. Public Keys: 48 bytes: 381 bit affine x coordinate, encoded into 48 big-endian bytes.\n4. Signatures: 96 bytes: two 381 bit integers (affine x coordinate), encoded into two 48 big-endian byte arrays.\n    - The signature is a point on the G2 subgroup, which is defined over a finite field\n    with elements twice as big as the G1 curve (G2 is over Fp2 rather than Fp. Fp2 is analogous to the complex numbers).\n5. The 12 stands for the Embedding degree.\n\n### Formulas\n- `P = pk x G` - public keys\n- `S = pk x H(m)` - signing\n- `e(P, H(m)) == e(G, S)` - verification using pairings\n- `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\n\n### Compatibility and notes\n1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC\n   Filecoin uses little endian byte arrays for private keys - make sure to reverse byte order.\n2. Some projects use G2 for public keys and G1 for signatures. It's called \"short signature\"\n3. Curve security level is about 120 bits as per Barbulescu-Duquesne 2017\n   https://hal.science/hal-01534101/file/main.pdf\n4. Compatible with specs:\n[cfrg-pairing-friendly-curves-11](https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11),\n[cfrg-bls-signature-05](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05),\n[RFC 9380](https://www.rfc-editor.org/rfc/rfc9380).\n*/\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n/*\nEmbedding degree (k): 12\nSeed (X): -15132376222941642752\nFr:  (x⁴-x²+1)\nFp: ((x-1)² ⋅ r(x)/3+x)\n(E/Fp): Y²=X³+4\n(Eₜ/Fp²): Y² = X³+4(u+1) (M-type twist)\nAte loop size: X\n\nTowers:\n- Fp²[u] = Fp/u²+1\n- Fp⁶[v] = Fp²/v³-1-u\n- Fp¹²[w] = Fp⁶/w²-v\n\n\nTODO: BLS & BN Fp/Fr can be constructed from seed.\n*/\n// The BLS parameter x (seed) for BLS12-381. NOTE: it is negative!\nconst BLS_X = BigInt('0xd201000000010000');\nconst BLS_X_LEN = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BLS_X);\n// CURVE FIELDS\nconst { Fp, Fp2, Fp6, Fp4Square, Fp12 } = (0,_abstract_tower_js__WEBPACK_IMPORTED_MODULE_1__.tower12)({\n    // Order of Fp\n    ORDER: BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'),\n    // Finite extension field over irreducible polynominal.\n    // Fp(u) / (u² - β) where β = -1\n    FP2_NONRESIDUE: [_1n, _1n],\n    Fp2mulByB: ({ c0, c1 }) => {\n        const t0 = Fp.mul(c0, _4n); // 4 * c0\n        const t1 = Fp.mul(c1, _4n); // 4 * c1\n        // (T0-T1) + (T0+T1)*i\n        return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\n    },\n    // Fp12\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    Fp12cyclotomicSquare: ({ c0, c1 }) => {\n        const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n        const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n        const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);\n        const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);\n        const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);\n        const t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\n        return {\n            c0: Fp6.create({\n                c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\n                c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\n                c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\n            }), // 2 * (T7 - c0c2)  + T7\n            c1: Fp6.create({\n                c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\n                c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\n                c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\n            }),\n        }; // 2 * (T6 + c1c2) + T6\n    },\n    Fp12cyclotomicExp(num, n) {\n        let z = Fp12.ONE;\n        for (let i = BLS_X_LEN - 1; i >= 0; i--) {\n            z = Fp12._cyclotomicSquare(z);\n            if ((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitGet)(n, i))\n                z = Fp12.mul(z, num);\n        }\n        return z;\n    },\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    Fp12finalExponentiate: (num) => {\n        const x = BLS_X;\n        // this^(q⁶) / this\n        const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n        // t0^(q²) * t0\n        const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n        const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n        const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n        const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n        const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n        const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n        const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n        const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n        const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n        const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n        const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n        // (t2 * t5)^(q²) * (t4 * t1)^(q³) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\n        return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n    },\n});\n// Finite field over r.\n// This particular field is not used anywhere in bls12-381, but it is still useful.\nconst Fr = _abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field(BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'));\n// END OF CURVE FIELDS\n// HashToCurve\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\nconst isogenyMapG2 = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__.isogenyMap)(Fp2, [\n    // xNum\n    [\n        [\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n        ],\n        [\n            '0x0',\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\n        ],\n        [\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\n            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\n        ],\n        [\n            '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\n            '0x0',\n        ],\n    ],\n    // xDen\n    [\n        [\n            '0x0',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\n        ],\n        [\n            '0xc',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\n        ],\n        ['0x1', '0x0'], // LAST 1\n    ],\n    // yNum\n    [\n        [\n            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n        ],\n        [\n            '0x0',\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\n        ],\n        [\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\n            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\n        ],\n        [\n            '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\n            '0x0',\n        ],\n    ],\n    // yDen\n    [\n        [\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n        ],\n        [\n            '0x0',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\n        ],\n        [\n            '0x12',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\n        ],\n        ['0x1', '0x0'], // LAST 1\n    ],\n].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))));\n// 11-isogeny map from E' to E\nconst isogenyMapG1 = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\n        '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\n        '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\n        '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\n        '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\n        '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\n        '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\n        '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\n        '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\n        '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\n        '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\n        '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\n    ],\n    // xDen\n    [\n        '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\n        '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\n        '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\n        '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\n        '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\n        '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\n        '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\n        '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\n        '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\n        '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\n        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\n        '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\n        '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\n        '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\n        '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\n        '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\n        '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\n        '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\n        '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\n        '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\n        '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\n        '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\n        '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\n        '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\n        '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\n        '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\n    ],\n    // yDen\n    [\n        '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\n        '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\n        '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\n        '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\n        '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\n        '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\n        '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\n        '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\n        '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\n        '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\n        '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\n        '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\n        '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\n        '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\n        '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\n        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j))));\n// SWU Map - Fp2 to G2': y² = x³ + 240i * x + 1012 + 1012i\nconst G2_SWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__.mapToCurveSimpleSWU)(Fp2, {\n    A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\n    B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\n    Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\n});\n// Optimized SWU Map - Fp to G1\nconst G1_SWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__.mapToCurveSimpleSWU)(Fp, {\n    A: Fp.create(BigInt('0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d')),\n    B: Fp.create(BigInt('0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0')),\n    Z: Fp.create(BigInt(11)),\n});\n// Endomorphisms (for fast cofactor clearing)\n// Ψ(P) endomorphism\nconst { G2psi, G2psi2 } = (0,_abstract_tower_js__WEBPACK_IMPORTED_MODULE_1__.psiFrobenius)(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)); // 1/(u+1)\n// Default hash_to_field options are for hash to G2.\n//\n// Parameter definitions are in section 5.3 of the spec unless otherwise noted.\n// Parameter values come from section 8.8.2 of the spec.\n// https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2\n//\n// Base field F is GF(p^m)\n// p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n// m = 2 (or 1 for G1 see section 8.8.1)\n// k = 128\nconst htfDefaults = Object.freeze({\n    // DST: a domain separation tag\n    // defined in section 2.2.5\n    // Use utils.getDSTLabel(), utils.setDSTLabel(value)\n    DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n    encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n    // p: the characteristic of F\n    //    where F is a finite field of characteristic p and order q = p^m\n    p: Fp.ORDER,\n    // m: the extension degree of F, m >= 1\n    //     where F is a finite field of characteristic p and order q = p^m\n    m: 2,\n    // k: the target security level for the suite in bits\n    // defined in section 5.1\n    k: 128,\n    // option to use a message that has already been processed by\n    // expand_message_xmd\n    expand: 'xmd',\n    // Hash functions for: expand_message_xmd is appropriate for use with a\n    // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.\n    // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__.sha256,\n});\n// Encoding utils\n// Point on G1 curve: (x, y)\n// Compressed point of infinity\nconst COMPRESSED_ZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true }); // set compressed & point-at-infinity bits\nfunction parseMask(bytes) {\n    // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\n    bytes = bytes.slice();\n    const mask = bytes[0] & 224;\n    const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\n    const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\n    const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\n    bytes[0] &= 31; // clear mask (zero first 3 bits)\n    return { compressed, infinity, sort, value: bytes };\n}\nfunction setMask(bytes, mask) {\n    if (bytes[0] & 224)\n        throw new Error('setMask: non-empty mask');\n    if (mask.compressed)\n        bytes[0] |= 128;\n    if (mask.infinity)\n        bytes[0] |= 64;\n    if (mask.sort)\n        bytes[0] |= 32;\n    return bytes;\n}\nfunction signatureG1ToRawBytes(point) {\n    point.assertValidity();\n    const isZero = point.equals(bls12_381.G1.ProjectivePoint.ZERO);\n    const { x, y } = point.toAffine();\n    if (isZero)\n        return COMPRESSED_ZERO.slice();\n    const P = Fp.ORDER;\n    const sort = Boolean((y * _2n) / P);\n    return setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x, Fp.BYTES), { compressed: true, sort });\n}\nfunction signatureG2ToRawBytes(point) {\n    // NOTE: by some reasons it was missed in bls12-381, looks like bug\n    point.assertValidity();\n    const len = Fp.BYTES;\n    if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(COMPRESSED_ZERO, (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(_0n, len));\n    const { x, y } = point.toAffine();\n    const { re: x0, im: x1 } = Fp2.reim(x);\n    const { re: y0, im: y1 } = Fp2.reim(y);\n    const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\n    const sort = Boolean((tmp / Fp.ORDER) & _1n);\n    const z2 = x0;\n    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x1, len), { sort, compressed: true }), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(z2, len));\n}\n// To verify curve parameters, see pairing-friendly-curves spec:\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11\n// Basic math is done over finite fields over p.\n// More complicated math is done over polynominal extension fields.\n// To simplify calculations in Fp12, we construct extension tower:\n// Fp₁₂ = Fp₆² => Fp₂³\n// Fp(u) / (u² - β) where β = -1\n// Fp₂(v) / (v³ - ξ) where ξ = u + 1\n// Fp₆(w) / (w² - γ) where γ = v\n// Here goes constants && point encoding format\nconst bls12_381 = (0,_abstract_bls_js__WEBPACK_IMPORTED_MODULE_6__.bls)({\n    // Fields\n    fields: {\n        Fp,\n        Fp2,\n        Fp6,\n        Fp12,\n        Fr,\n    },\n    // G1 is the order-q subgroup of E1(Fp) : y² = x³ + 4, #E1(Fp) = h1q, where\n    // characteristic; z + (z⁴ - z² + 1)(z - 1)²/3\n    G1: {\n        Fp,\n        // cofactor; (z - 1)²/3\n        h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\n        // generator's coordinates\n        // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n        // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\n        Gx: BigInt('0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'),\n        Gy: BigInt('0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'),\n        a: Fp.ZERO,\n        b: _4n,\n        htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\n        wrapPrivateKey: true,\n        allowInfinityPoint: true,\n        // Checks is the point resides in prime-order subgroup.\n        // point.isTorsionFree() should return true for valid points\n        // It returns false for shitty points.\n        // https://eprint.iacr.org/2021/1130.pdf\n        isTorsionFree: (c, point) => {\n            // φ endomorphism\n            const cubicRootOfUnityModP = BigInt('0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe');\n            const phi = new c(Fp.mul(point.px, cubicRootOfUnityModP), point.py, point.pz);\n            // todo: unroll\n            const xP = point.multiplyUnsafe(BLS_X).negate(); // [x]P\n            const u2P = xP.multiplyUnsafe(BLS_X); // [u2]P\n            return u2P.equals(phi);\n            // https://eprint.iacr.org/2019/814.pdf\n            // (z² − 1)/3\n            // const c1 = BigInt('0x396c8c005555e1560000000055555555');\n            // const P = this;\n            // const S = P.sigma();\n            // const Q = S.double();\n            // const S2 = S.sigma();\n            // // [(z² − 1)/3](2σ(P) − P − σ²(P)) − σ²(P) = O\n            // const left = Q.subtract(P).subtract(S2).multiplyUnsafe(c1);\n            // const C = left.subtract(S2);\n            // return C.isZero();\n        },\n        // Clear cofactor of G1\n        // https://eprint.iacr.org/2019/403\n        clearCofactor: (_c, point) => {\n            // return this.multiplyUnsafe(CURVE.h);\n            return point.multiplyUnsafe(BLS_X).add(point); // x*P + P\n        },\n        mapToCurve: (scalars) => {\n            const { x, y } = G1_SWU(Fp.create(scalars[0]));\n            return isogenyMapG1(x, y);\n        },\n        fromBytes: (bytes) => {\n            const { compressed, infinity, sort, value } = parseMask(bytes);\n            if (value.length === 48 && compressed) {\n                // TODO: Fp.bytes\n                const P = Fp.ORDER;\n                const compressedValue = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value);\n                // Zero\n                const x = Fp.create(compressedValue & Fp.MASK);\n                if (infinity) {\n                    if (x !== _0n)\n                        throw new Error('G1: non-empty compressed point at infinity');\n                    return { x: _0n, y: _0n };\n                }\n                const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y² = x³ + b\n                let y = Fp.sqrt(right);\n                if (!y)\n                    throw new Error('Invalid compressed G1 point');\n                if ((y * _2n) / P !== BigInt(sort))\n                    y = Fp.neg(y);\n                return { x: Fp.create(x), y: Fp.create(y) };\n            }\n            else if (value.length === 96 && !compressed) {\n                // Check if the infinity flag is set\n                const x = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.subarray(0, Fp.BYTES));\n                const y = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.subarray(Fp.BYTES));\n                if (infinity) {\n                    if (x !== _0n || y !== _0n)\n                        throw new Error('G1: non-empty point at infinity');\n                    return bls12_381.G1.ProjectivePoint.ZERO.toAffine();\n                }\n                return { x: Fp.create(x), y: Fp.create(y) };\n            }\n            else {\n                throw new Error('Invalid point G1, expected 48/96 bytes');\n            }\n        },\n        toBytes: (c, point, isCompressed) => {\n            const isZero = point.equals(c.ZERO);\n            const { x, y } = point.toAffine();\n            if (isCompressed) {\n                if (isZero)\n                    return COMPRESSED_ZERO.slice();\n                const P = Fp.ORDER;\n                const sort = Boolean((y * _2n) / P);\n                return setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x, Fp.BYTES), { compressed: true, sort });\n            }\n            else {\n                if (isZero) {\n                    // 2x PUBLIC_KEY_LENGTH\n                    const x = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(new Uint8Array([0x40]), new Uint8Array(2 * Fp.BYTES - 1));\n                    return x;\n                }\n                else {\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x, Fp.BYTES), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(y, Fp.BYTES));\n                }\n            }\n        },\n        ShortSignature: {\n            fromHex(hex) {\n                const { infinity, sort, value } = parseMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('signatureHex', hex, 48));\n                const P = Fp.ORDER;\n                const compressedValue = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value);\n                // Zero\n                if (infinity)\n                    return bls12_381.G1.ProjectivePoint.ZERO;\n                const x = Fp.create(compressedValue & Fp.MASK);\n                const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y² = x³ + b\n                let y = Fp.sqrt(right);\n                if (!y)\n                    throw new Error('Invalid compressed G1 point');\n                const aflag = BigInt(sort);\n                if ((y * _2n) / P !== aflag)\n                    y = Fp.neg(y);\n                const point = bls12_381.G1.ProjectivePoint.fromAffine({ x, y });\n                point.assertValidity();\n                return point;\n            },\n            toRawBytes(point) {\n                return signatureG1ToRawBytes(point);\n            },\n            toHex(point) {\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(signatureG1ToRawBytes(point));\n            },\n        },\n    },\n    // G2 is the order-q subgroup of E2(Fp²) : y² = x³+4(1+√−1),\n    // where Fp2 is Fp[√−1]/(x2+1). #E2(Fp2 ) = h2q, where\n    // G² - 1\n    // h2q\n    G2: {\n        Fp: Fp2,\n        // cofactor\n        h: BigInt('0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'),\n        Gx: Fp2.fromBigTuple([\n            BigInt('0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'),\n            BigInt('0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'),\n        ]),\n        // y =\n        // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,\n        // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n        Gy: Fp2.fromBigTuple([\n            BigInt('0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'),\n            BigInt('0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'),\n        ]),\n        a: Fp2.ZERO,\n        b: Fp2.fromBigTuple([_4n, _4n]),\n        hEff: BigInt('0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'),\n        htfDefaults: { ...htfDefaults },\n        wrapPrivateKey: true,\n        allowInfinityPoint: true,\n        mapToCurve: (scalars) => {\n            const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));\n            return isogenyMapG2(x, y);\n        },\n        // Checks is the point resides in prime-order subgroup.\n        // point.isTorsionFree() should return true for valid points\n        // It returns false for shitty points.\n        // https://eprint.iacr.org/2021/1130.pdf\n        isTorsionFree: (c, P) => {\n            return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P)); // ψ(P) == [u](P)\n            // Older version: https://eprint.iacr.org/2019/814.pdf\n            // Ψ²(P) => Ψ³(P) => [z]Ψ³(P) where z = -x => [z]Ψ³(P) - Ψ²(P) + P == O\n            // return P.psi2().psi().mulNegX().subtract(psi2).add(P).isZero();\n        },\n        // Maps the point into the prime-order subgroup G2.\n        // clear_cofactor_bls12381_g2 from cfrg-hash-to-curve-11\n        // https://eprint.iacr.org/2017/419.pdf\n        // prettier-ignore\n        clearCofactor: (c, P) => {\n            const x = BLS_X;\n            let t1 = P.multiplyUnsafe(x).negate(); // [-x]P\n            let t2 = G2psi(c, P); // Ψ(P)\n            let t3 = P.double(); // 2P\n            t3 = G2psi2(c, t3); // Ψ²(2P)\n            t3 = t3.subtract(t2); // Ψ²(2P) - Ψ(P)\n            t2 = t1.add(t2); // [-x]P + Ψ(P)\n            t2 = t2.multiplyUnsafe(x).negate(); // [x²]P - [x]Ψ(P)\n            t3 = t3.add(t2); // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P)\n            t3 = t3.subtract(t1); // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P\n            const Q = t3.subtract(P); // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P - 1P\n            return Q; // [x²-x-1]P + [x-1]Ψ(P) + Ψ²(2P)\n        },\n        fromBytes: (bytes) => {\n            const { compressed, infinity, sort, value } = parseMask(bytes);\n            if ((!compressed && !infinity && sort) || // 00100000\n                (!compressed && infinity && sort) || // 01100000\n                (sort && infinity && compressed) // 11100000\n            ) {\n                throw new Error('Invalid encoding flag: ' + (bytes[0] & 224));\n            }\n            const L = Fp.BYTES;\n            const slc = (b, from, to) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(b.slice(from, to));\n            if (value.length === 96 && compressed) {\n                const b = bls12_381.params.G2b;\n                const P = Fp.ORDER;\n                if (infinity) {\n                    // check that all bytes are 0\n                    if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n                        throw new Error('Invalid compressed G2 point');\n                    }\n                    return { x: Fp2.ZERO, y: Fp2.ZERO };\n                }\n                const x_1 = slc(value, 0, L);\n                const x_0 = slc(value, L, 2 * L);\n                const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\n                const right = Fp2.add(Fp2.pow(x, _3n), b); // y² = x³ + 4 * (u+1) = x³ + b\n                let y = Fp2.sqrt(right);\n                const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\n                y = sort && Y_bit > 0 ? y : Fp2.neg(y);\n                return { x, y };\n            }\n            else if (value.length === 192 && !compressed) {\n                if (infinity) {\n                    if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n                        throw new Error('Invalid uncompressed G2 point');\n                    }\n                    return { x: Fp2.ZERO, y: Fp2.ZERO };\n                }\n                const x1 = slc(value, 0, L);\n                const x0 = slc(value, L, 2 * L);\n                const y1 = slc(value, 2 * L, 3 * L);\n                const y0 = slc(value, 3 * L, 4 * L);\n                return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\n            }\n            else {\n                throw new Error('Invalid point G2, expected 96/192 bytes');\n            }\n        },\n        toBytes: (c, point, isCompressed) => {\n            const { BYTES: len, ORDER: P } = Fp;\n            const isZero = point.equals(c.ZERO);\n            const { x, y } = point.toAffine();\n            if (isCompressed) {\n                if (isZero)\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(COMPRESSED_ZERO, (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(_0n, len));\n                const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x.c1, len), { compressed: true, sort: flag }), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x.c0, len));\n            }\n            else {\n                if (isZero)\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(new Uint8Array([0x40]), new Uint8Array(4 * len - 1)); // bytes[0] |= 1 << 6;\n                const { re: x0, im: x1 } = Fp2.reim(x);\n                const { re: y0, im: y1 } = Fp2.reim(y);\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x1, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x0, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(y1, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(y0, len));\n            }\n        },\n        Signature: {\n            // TODO: Optimize, it's very slow because of sqrt.\n            fromHex(hex) {\n                const { infinity, sort, value } = parseMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('signatureHex', hex));\n                const P = Fp.ORDER;\n                const half = value.length / 2;\n                if (half !== 48 && half !== 96)\n                    throw new Error('Invalid compressed signature length, must be 96 or 192');\n                const z1 = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.slice(0, half));\n                const z2 = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.slice(half));\n                // Indicates the infinity point\n                if (infinity)\n                    return bls12_381.G2.ProjectivePoint.ZERO;\n                const x1 = Fp.create(z1 & Fp.MASK);\n                const x2 = Fp.create(z2);\n                const x = Fp2.create({ c0: x2, c1: x1 });\n                const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381.params.G2b); // y² = x³ + 4\n                // The slow part\n                let y = Fp2.sqrt(y2);\n                if (!y)\n                    throw new Error('Failed to find a square root');\n                // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n                // If y1 happens to be zero, then use the bit of y0\n                const { re: y0, im: y1 } = Fp2.reim(y);\n                const aflag1 = BigInt(sort);\n                const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\n                const isZero = y1 === _0n && (y0 * _2n) / P !== aflag1;\n                if (isGreater || isZero)\n                    y = Fp2.neg(y);\n                const point = bls12_381.G2.ProjectivePoint.fromAffine({ x, y });\n                point.assertValidity();\n                return point;\n            },\n            toRawBytes(point) {\n                return signatureG2ToRawBytes(point);\n            },\n            toHex(point) {\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(signatureG2ToRawBytes(point));\n            },\n        },\n    },\n    params: {\n        ateLoopSize: BLS_X, // The BLS parameter x for BLS12-381\n        r: Fr.ORDER, // order; z⁴ − z² + 1; CURVE.n from other curves\n        xNegative: true,\n        twistType: 'multiplicative',\n    },\n    htfDefaults,\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__.sha256,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_7__.randomBytes,\n});\n//# sourceMappingURL=bls12-381.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYmxzMTItMzgxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQzhDO0FBQ0k7QUFDVjtBQUNLO0FBQzRGO0FBQ3pJO0FBQ3lEO0FBQ087QUFDSjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQU07QUFDeEI7QUFDQSxRQUFRLGdDQUFnQyxFQUFFLDJEQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQyxnQkFBZ0IsK0JBQStCO0FBQy9DLGdCQUFnQiwrQkFBK0I7QUFDL0MsZ0JBQWdCLHdCQUF3QjtBQUN4QyxnQkFBZ0Isd0JBQXdCO0FBQ3hDLGdCQUFnQix3QkFBd0I7QUFDeEMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQSxnQkFBZ0IsMERBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQSxXQUFXLHVEQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzRUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNFQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkVBQW1CO0FBQ2xDLG9CQUFvQixnREFBZ0Q7QUFDcEUsb0JBQW9CLDBEQUEwRDtBQUM5RSxvQkFBb0Isc0RBQXNEO0FBQzFFLENBQUM7QUFDRDtBQUNBLGVBQWUsNkVBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0IsRUFBRSxnRUFBWSw2Q0FBNkM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0NBQWtDLEdBQUc7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsMENBQTBDO0FBQzFDLHNDQUFzQztBQUN0QyxvQkFBb0I7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBZSxpQkFBaUIsd0JBQXdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQU8sa0JBQWtCLG1FQUFlO0FBQ3ZELFlBQVksT0FBTztBQUNuQixZQUFZLGlCQUFpQjtBQUM3QixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtEQUFPLFNBQVMsbUVBQWUsYUFBYSx3QkFBd0IsR0FBRyxtRUFBZTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0JBQWtCLHFEQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwRUFBMEU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELFNBQVM7QUFDVDtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtRUFBZTtBQUN6QywwQkFBMEIsbUVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtRUFBZSxpQkFBaUIsd0JBQXdCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtEQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBTyxDQUFDLG1FQUFlLGVBQWUsbUVBQWU7QUFDaEY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QixZQUFZLCtEQUFXO0FBQ3ZFO0FBQ0Esd0NBQXdDLG1FQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1Qiw4REFBVTtBQUNqQyxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyw2QkFBNkI7QUFDN0IsZ0RBQWdEO0FBQ2hELDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsc0NBQXNDO0FBQ3RDLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1Q7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1FQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdDQUF3QztBQUMvRSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQU8sa0JBQWtCLG1FQUFlO0FBQ25FO0FBQ0EsdUJBQXVCLCtEQUFPLFNBQVMsbUVBQWUsZUFBZSw4QkFBOEIsR0FBRyxtRUFBZTtBQUNySDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQU8sdURBQXVEO0FBQ3pGLHdCQUF3QixpQkFBaUI7QUFDekMsd0JBQXdCLGlCQUFpQjtBQUN6Qyx1QkFBdUIsK0RBQU8sQ0FBQyxtRUFBZSxXQUFXLG1FQUFlLFdBQVcsbUVBQWUsV0FBVyxtRUFBZTtBQUM1SDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCLFlBQVksK0RBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUVBQWU7QUFDMUMsMkJBQTJCLG1FQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsTUFBTTtBQUM5RTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUIsOERBQVU7QUFDakMsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLGVBQWU7QUFDZixDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYmxzMTItMzgxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBibHMgfSBmcm9tICcuL2Fic3RyYWN0L2Jscy5qcyc7XG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGJpdEdldCwgYml0TGVuLCBieXRlc1RvSGV4LCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzIGFzIGNvbmNhdEIsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUsIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG4vLyBUeXBlc1xuaW1wb3J0IHsgaXNvZ2VueU1hcCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG5pbXBvcnQgeyB0b3dlcjEyLCBwc2lGcm9iZW5pdXMgfSBmcm9tICcuL2Fic3RyYWN0L3Rvd2VyLmpzJztcbi8qXG5ibHMxMi0zODEgaXMgcGFpcmluZy1mcmllbmRseSBCYXJyZXRvLUx5bm4tU2NvdHQgZWxsaXB0aWMgY3VydmUgY29uc3RydWN0aW9uIGFsbG93aW5nIHRvOlxuLSBDb25zdHJ1Y3QgemstU05BUktzIGF0IHRoZSAxMjAtYml0IHNlY3VyaXR5XG4tIEVmZmljaWVudGx5IHZlcmlmeSBOIGFnZ3JlZ2F0ZSBzaWduYXR1cmVzIHdpdGggMSBwYWlyaW5nIGFuZCBOIGVjIGFkZGl0aW9uczpcbiAgdGhlIEJvbmVoLUx5bm4tU2hhY2hhbSBzaWduYXR1cmUgc2NoZW1lIGlzIG9yZGVycyBvZiBtYWduaXR1ZGUgbW9yZSBlZmZpY2llbnQgdGhhbiBTY2hub3JyXG5cbiMjIyBTdW1tYXJ5XG4xLiBCTFMgUmVsaWVzIG9uIEJpbGluZWFyIFBhaXJpbmcgKGV4cGVuc2l2ZSlcbjIuIFByaXZhdGUgS2V5czogMzIgYnl0ZXNcbjMuIFB1YmxpYyBLZXlzOiA0OCBieXRlczogMzgxIGJpdCBhZmZpbmUgeCBjb29yZGluYXRlLCBlbmNvZGVkIGludG8gNDggYmlnLWVuZGlhbiBieXRlcy5cbjQuIFNpZ25hdHVyZXM6IDk2IGJ5dGVzOiB0d28gMzgxIGJpdCBpbnRlZ2VycyAoYWZmaW5lIHggY29vcmRpbmF0ZSksIGVuY29kZWQgaW50byB0d28gNDggYmlnLWVuZGlhbiBieXRlIGFycmF5cy5cbiAgICAtIFRoZSBzaWduYXR1cmUgaXMgYSBwb2ludCBvbiB0aGUgRzIgc3ViZ3JvdXAsIHdoaWNoIGlzIGRlZmluZWQgb3ZlciBhIGZpbml0ZSBmaWVsZFxuICAgIHdpdGggZWxlbWVudHMgdHdpY2UgYXMgYmlnIGFzIHRoZSBHMSBjdXJ2ZSAoRzIgaXMgb3ZlciBGcDIgcmF0aGVyIHRoYW4gRnAuIEZwMiBpcyBhbmFsb2dvdXMgdG8gdGhlIGNvbXBsZXggbnVtYmVycykuXG41LiBUaGUgMTIgc3RhbmRzIGZvciB0aGUgRW1iZWRkaW5nIGRlZ3JlZS5cblxuIyMjIEZvcm11bGFzXG4tIGBQID0gcGsgeCBHYCAtIHB1YmxpYyBrZXlzXG4tIGBTID0gcGsgeCBIKG0pYCAtIHNpZ25pbmdcbi0gYGUoUCwgSChtKSkgPT0gZShHLCBTKWAgLSB2ZXJpZmljYXRpb24gdXNpbmcgcGFpcmluZ3Ncbi0gYGUoRywgUykgPSBlKEcsIFNVTShuKShTaSkpID0gTVVMKG4pKGUoRywgU2kpKWAgLSBzaWduYXR1cmUgYWdncmVnYXRpb25cblxuIyMjIENvbXBhdGliaWxpdHkgYW5kIG5vdGVzXG4xLiBJdCBpcyBjb21wYXRpYmxlIHdpdGggQWxnb3JhbmQsIENoaWEsIERmaW5pdHksIEV0aGVyZXVtLCBGaWxlY29pbiwgWkVDXG4gICBGaWxlY29pbiB1c2VzIGxpdHRsZSBlbmRpYW4gYnl0ZSBhcnJheXMgZm9yIHByaXZhdGUga2V5cyAtIG1ha2Ugc3VyZSB0byByZXZlcnNlIGJ5dGUgb3JkZXIuXG4yLiBTb21lIHByb2plY3RzIHVzZSBHMiBmb3IgcHVibGljIGtleXMgYW5kIEcxIGZvciBzaWduYXR1cmVzLiBJdCdzIGNhbGxlZCBcInNob3J0IHNpZ25hdHVyZVwiXG4zLiBDdXJ2ZSBzZWN1cml0eSBsZXZlbCBpcyBhYm91dCAxMjAgYml0cyBhcyBwZXIgQmFyYnVsZXNjdS1EdXF1ZXNuZSAyMDE3XG4gICBodHRwczovL2hhbC5zY2llbmNlL2hhbC0wMTUzNDEwMS9maWxlL21haW4ucGRmXG40LiBDb21wYXRpYmxlIHdpdGggc3BlY3M6XG5bY2ZyZy1wYWlyaW5nLWZyaWVuZGx5LWN1cnZlcy0xMV0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1wYWlyaW5nLWZyaWVuZGx5LWN1cnZlcy0xMSksXG5bY2ZyZy1ibHMtc2lnbmF0dXJlLTA1XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1ibHMtc2lnbmF0dXJlLTA1KSxcbltSRkMgOTM4MF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODApLlxuKi9cbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbi8qXG5FbWJlZGRpbmcgZGVncmVlIChrKTogMTJcblNlZWQgKFgpOiAtMTUxMzIzNzYyMjI5NDE2NDI3NTJcbkZyOiAgKHjigbQteMKyKzEpXG5GcDogKCh4LTEpwrIg4ouFIHIoeCkvMyt4KVxuKEUvRnApOiBZwrI9WMKzKzRcbihF4oKcL0ZwwrIpOiBZwrIgPSBYwrMrNCh1KzEpIChNLXR5cGUgdHdpc3QpXG5BdGUgbG9vcCBzaXplOiBYXG5cblRvd2Vyczpcbi0gRnDCslt1XSA9IEZwL3XCsisxXG4tIEZw4oG2W3ZdID0gRnDCsi92wrMtMS11XG4tIEZwwrnCslt3XSA9IEZw4oG2L3fCsi12XG5cblxuVE9ETzogQkxTICYgQk4gRnAvRnIgY2FuIGJlIGNvbnN0cnVjdGVkIGZyb20gc2VlZC5cbiovXG4vLyBUaGUgQkxTIHBhcmFtZXRlciB4IChzZWVkKSBmb3IgQkxTMTItMzgxLiBOT1RFOiBpdCBpcyBuZWdhdGl2ZSFcbmNvbnN0IEJMU19YID0gQmlnSW50KCcweGQyMDEwMDAwMDAwMTAwMDAnKTtcbmNvbnN0IEJMU19YX0xFTiA9IGJpdExlbihCTFNfWCk7XG4vLyBDVVJWRSBGSUVMRFNcbmNvbnN0IHsgRnAsIEZwMiwgRnA2LCBGcDRTcXVhcmUsIEZwMTIgfSA9IHRvd2VyMTIoe1xuICAgIC8vIE9yZGVyIG9mIEZwXG4gICAgT1JERVI6IEJpZ0ludCgnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWInKSxcbiAgICAvLyBGaW5pdGUgZXh0ZW5zaW9uIGZpZWxkIG92ZXIgaXJyZWR1Y2libGUgcG9seW5vbWluYWwuXG4gICAgLy8gRnAodSkgLyAodcKyIC0gzrIpIHdoZXJlIM6yID0gLTFcbiAgICBGUDJfTk9OUkVTSURVRTogW18xbiwgXzFuXSxcbiAgICBGcDJtdWxCeUI6ICh7IGMwLCBjMSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHQwID0gRnAubXVsKGMwLCBfNG4pOyAvLyA0ICogYzBcbiAgICAgICAgY29uc3QgdDEgPSBGcC5tdWwoYzEsIF80bik7IC8vIDQgKiBjMVxuICAgICAgICAvLyAoVDAtVDEpICsgKFQwK1QxKSppXG4gICAgICAgIHJldHVybiB7IGMwOiBGcC5zdWIodDAsIHQxKSwgYzE6IEZwLmFkZCh0MCwgdDEpIH07XG4gICAgfSxcbiAgICAvLyBGcDEyXG4gICAgLy8gQSBjeWNsb3RvbWljIGdyb3VwIGlzIGEgc3ViZ3JvdXAgb2YgRnBebiBkZWZpbmVkIGJ5XG4gICAgLy8gICBHzqbigpkocCkgPSB7zrEg4oiIIEZw4oG/IDogzrFezqbigpkocCkgPSAxfVxuICAgIC8vIFRoZSByZXN1bHQgb2YgYW55IHBhaXJpbmcgaXMgaW4gYSBjeWNsb3RvbWljIHN1Ymdyb3VwXG4gICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAwOS81NjUucGRmXG4gICAgRnAxMmN5Y2xvdG9taWNTcXVhcmU6ICh7IGMwLCBjMSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYzA6IGMwYzAsIGMxOiBjMGMxLCBjMjogYzBjMiB9ID0gYzA7XG4gICAgICAgIGNvbnN0IHsgYzA6IGMxYzAsIGMxOiBjMWMxLCBjMjogYzFjMiB9ID0gYzE7XG4gICAgICAgIGNvbnN0IHsgZmlyc3Q6IHQzLCBzZWNvbmQ6IHQ0IH0gPSBGcDRTcXVhcmUoYzBjMCwgYzFjMSk7XG4gICAgICAgIGNvbnN0IHsgZmlyc3Q6IHQ1LCBzZWNvbmQ6IHQ2IH0gPSBGcDRTcXVhcmUoYzFjMCwgYzBjMik7XG4gICAgICAgIGNvbnN0IHsgZmlyc3Q6IHQ3LCBzZWNvbmQ6IHQ4IH0gPSBGcDRTcXVhcmUoYzBjMSwgYzFjMik7XG4gICAgICAgIGNvbnN0IHQ5ID0gRnAyLm11bEJ5Tm9ucmVzaWR1ZSh0OCk7IC8vIFQ4ICogKHUgKyAxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IEZwNi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGMwOiBGcDIuYWRkKEZwMi5tdWwoRnAyLnN1Yih0MywgYzBjMCksIF8ybiksIHQzKSwgLy8gMiAqIChUMyAtIGMwYzApICArIFQzXG4gICAgICAgICAgICAgICAgYzE6IEZwMi5hZGQoRnAyLm11bChGcDIuc3ViKHQ1LCBjMGMxKSwgXzJuKSwgdDUpLCAvLyAyICogKFQ1IC0gYzBjMSkgICsgVDVcbiAgICAgICAgICAgICAgICBjMjogRnAyLmFkZChGcDIubXVsKEZwMi5zdWIodDcsIGMwYzIpLCBfMm4pLCB0NyksXG4gICAgICAgICAgICB9KSwgLy8gMiAqIChUNyAtIGMwYzIpICArIFQ3XG4gICAgICAgICAgICBjMTogRnA2LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYzA6IEZwMi5hZGQoRnAyLm11bChGcDIuYWRkKHQ5LCBjMWMwKSwgXzJuKSwgdDkpLCAvLyAyICogKFQ5ICsgYzFjMCkgKyBUOVxuICAgICAgICAgICAgICAgIGMxOiBGcDIuYWRkKEZwMi5tdWwoRnAyLmFkZCh0NCwgYzFjMSksIF8ybiksIHQ0KSwgLy8gMiAqIChUNCArIGMxYzEpICsgVDRcbiAgICAgICAgICAgICAgICBjMjogRnAyLmFkZChGcDIubXVsKEZwMi5hZGQodDYsIGMxYzIpLCBfMm4pLCB0NiksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTsgLy8gMiAqIChUNiArIGMxYzIpICsgVDZcbiAgICB9LFxuICAgIEZwMTJjeWNsb3RvbWljRXhwKG51bSwgbikge1xuICAgICAgICBsZXQgeiA9IEZwMTIuT05FO1xuICAgICAgICBmb3IgKGxldCBpID0gQkxTX1hfTEVOIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHogPSBGcDEyLl9jeWNsb3RvbWljU3F1YXJlKHopO1xuICAgICAgICAgICAgaWYgKGJpdEdldChuLCBpKSlcbiAgICAgICAgICAgICAgICB6ID0gRnAxMi5tdWwoeiwgbnVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gejtcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvMzU0LnBkZlxuICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMDkvNTY1LnBkZlxuICAgIEZwMTJmaW5hbEV4cG9uZW50aWF0ZTogKG51bSkgPT4ge1xuICAgICAgICBjb25zdCB4ID0gQkxTX1g7XG4gICAgICAgIC8vIHRoaXNeKHHigbYpIC8gdGhpc1xuICAgICAgICBjb25zdCB0MCA9IEZwMTIuZGl2KEZwMTIuZnJvYmVuaXVzTWFwKG51bSwgNiksIG51bSk7XG4gICAgICAgIC8vIHQwXihxwrIpICogdDBcbiAgICAgICAgY29uc3QgdDEgPSBGcDEyLm11bChGcDEyLmZyb2Jlbml1c01hcCh0MCwgMiksIHQwKTtcbiAgICAgICAgY29uc3QgdDIgPSBGcDEyLmNvbmp1Z2F0ZShGcDEyLl9jeWNsb3RvbWljRXhwKHQxLCB4KSk7XG4gICAgICAgIGNvbnN0IHQzID0gRnAxMi5tdWwoRnAxMi5jb25qdWdhdGUoRnAxMi5fY3ljbG90b21pY1NxdWFyZSh0MSkpLCB0Mik7XG4gICAgICAgIGNvbnN0IHQ0ID0gRnAxMi5jb25qdWdhdGUoRnAxMi5fY3ljbG90b21pY0V4cCh0MywgeCkpO1xuICAgICAgICBjb25zdCB0NSA9IEZwMTIuY29uanVnYXRlKEZwMTIuX2N5Y2xvdG9taWNFeHAodDQsIHgpKTtcbiAgICAgICAgY29uc3QgdDYgPSBGcDEyLm11bChGcDEyLmNvbmp1Z2F0ZShGcDEyLl9jeWNsb3RvbWljRXhwKHQ1LCB4KSksIEZwMTIuX2N5Y2xvdG9taWNTcXVhcmUodDIpKTtcbiAgICAgICAgY29uc3QgdDcgPSBGcDEyLmNvbmp1Z2F0ZShGcDEyLl9jeWNsb3RvbWljRXhwKHQ2LCB4KSk7XG4gICAgICAgIGNvbnN0IHQyX3Q1X3Bvd19xMiA9IEZwMTIuZnJvYmVuaXVzTWFwKEZwMTIubXVsKHQyLCB0NSksIDIpO1xuICAgICAgICBjb25zdCB0NF90MV9wb3dfcTMgPSBGcDEyLmZyb2Jlbml1c01hcChGcDEyLm11bCh0NCwgdDEpLCAzKTtcbiAgICAgICAgY29uc3QgdDZfdDFjX3Bvd19xMSA9IEZwMTIuZnJvYmVuaXVzTWFwKEZwMTIubXVsKHQ2LCBGcDEyLmNvbmp1Z2F0ZSh0MSkpLCAxKTtcbiAgICAgICAgY29uc3QgdDdfdDNjX3QxID0gRnAxMi5tdWwoRnAxMi5tdWwodDcsIEZwMTIuY29uanVnYXRlKHQzKSksIHQxKTtcbiAgICAgICAgLy8gKHQyICogdDUpXihxwrIpICogKHQ0ICogdDEpXihxwrMpICogKHQ2ICogdDEuY29uaileKHFeMSkgKiB0NyAqIHQzLmNvbmogKiB0MVxuICAgICAgICByZXR1cm4gRnAxMi5tdWwoRnAxMi5tdWwoRnAxMi5tdWwodDJfdDVfcG93X3EyLCB0NF90MV9wb3dfcTMpLCB0Nl90MWNfcG93X3ExKSwgdDdfdDNjX3QxKTtcbiAgICB9LFxufSk7XG4vLyBGaW5pdGUgZmllbGQgb3ZlciByLlxuLy8gVGhpcyBwYXJ0aWN1bGFyIGZpZWxkIGlzIG5vdCB1c2VkIGFueXdoZXJlIGluIGJsczEyLTM4MSwgYnV0IGl0IGlzIHN0aWxsIHVzZWZ1bC5cbmNvbnN0IEZyID0gbW9kLkZpZWxkKEJpZ0ludCgnMHg3M2VkYTc1MzI5OWQ3ZDQ4MzMzOWQ4MDgwOWExZDgwNTUzYmRhNDAyZmZmZTViZmVmZmZmZmZmZjAwMDAwMDAxJykpO1xuLy8gRU5EIE9GIENVUlZFIEZJRUxEU1xuLy8gSGFzaFRvQ3VydmVcbi8vIDMtaXNvZ2VueSBtYXAgZnJvbSBFJyB0byBFIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI2FwcGVuZGl4LUUuM1xuY29uc3QgaXNvZ2VueU1hcEcyID0gaXNvZ2VueU1hcChGcDIsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICBbXG4gICAgICAgICAgICAnMHg1Yzc1OTUwN2U4ZTMzM2ViYjViN2E5YTQ3ZDdlZDg1MzJjNTJkMzlmZDNhMDQyYTg4YjU4NDIzYzUwYWUxNWQ1YzI2MzhlMzQzZDljNzFjNjIzOGFhYWFhYWFhOTdkNicsXG4gICAgICAgICAgICAnMHg1Yzc1OTUwN2U4ZTMzM2ViYjViN2E5YTQ3ZDdlZDg1MzJjNTJkMzlmZDNhMDQyYTg4YjU4NDIzYzUwYWUxNWQ1YzI2MzhlMzQzZDljNzFjNjIzOGFhYWFhYWFhOTdkNicsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDAnLFxuICAgICAgICAgICAgJzB4MTE1NjBiZjE3YmFhOTliYzMyMTI2ZmNlZDc4N2M4OGY5ODRmODdhZGY3YWUwYzdmOWEyMDhjNmI0ZjIwYTQxODE0NzJhYWE5Y2I4ZDU1NTUyNmE5ZmZmZmZmZmZjNzFhJyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MTE1NjBiZjE3YmFhOTliYzMyMTI2ZmNlZDc4N2M4OGY5ODRmODdhZGY3YWUwYzdmOWEyMDhjNmI0ZjIwYTQxODE0NzJhYWE5Y2I4ZDU1NTUyNmE5ZmZmZmZmZmZjNzFlJyxcbiAgICAgICAgICAgICcweDhhYjA1ZjhiZGQ1NGNkZTE5MDkzN2U3NmJjM2U0NDdjYzI3YzNkNmZiZDcwNjNmY2QxMDQ2MzVhNzkwNTIwYzBhMzk1NTU0ZTVjNmFhYWE5MzU0ZmZmZmZmZmZlMzhkJyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MTcxZDY1NDFmYTM4Y2NmYWVkNmRlYTY5MWY1ZmI2MTRjYjE0YjRlN2Y0ZTgxMGFhMjJkNjEwOGYxNDJiODU3NTcwOThlMzhkMGY2NzFjNzE4OGUyYWFhYWFhYWE1ZWQxJyxcbiAgICAgICAgICAgICcweDAnLFxuICAgICAgICBdLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MCcsXG4gICAgICAgICAgICAnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhNjMnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHhjJyxcbiAgICAgICAgICAgICcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWE5ZicsXG4gICAgICAgIF0sXG4gICAgICAgIFsnMHgxJywgJzB4MCddLCAvLyBMQVNUIDFcbiAgICBdLFxuICAgIC8vIHlOdW1cbiAgICBbXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDE1MzA0NzdjN2FiNDExM2I1OWE0YzE4YjA3NmQxMTkzMGY3ZGE1ZDRhMDdmNjQ5YmY1NDQzOWQ4N2QyN2U1MDBmYzhjMjVlYmY4YzkyZjY4MTJjZmM3MWM3MWM2ZDcwNicsXG4gICAgICAgICAgICAnMHgxNTMwNDc3YzdhYjQxMTNiNTlhNGMxOGIwNzZkMTE5MzBmN2RhNWQ0YTA3ZjY0OWJmNTQ0MzlkODdkMjdlNTAwZmM4YzI1ZWJmOGM5MmY2ODEyY2ZjNzFjNzFjNmQ3MDYnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgwJyxcbiAgICAgICAgICAgICcweDVjNzU5NTA3ZThlMzMzZWJiNWI3YTlhNDdkN2VkODUzMmM1MmQzOWZkM2EwNDJhODhiNTg0MjNjNTBhZTE1ZDVjMjYzOGUzNDNkOWM3MWM2MjM4YWFhYWFhYWE5N2JlJyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MTE1NjBiZjE3YmFhOTliYzMyMTI2ZmNlZDc4N2M4OGY5ODRmODdhZGY3YWUwYzdmOWEyMDhjNmI0ZjIwYTQxODE0NzJhYWE5Y2I4ZDU1NTUyNmE5ZmZmZmZmZmZjNzFjJyxcbiAgICAgICAgICAgICcweDhhYjA1ZjhiZGQ1NGNkZTE5MDkzN2U3NmJjM2U0NDdjYzI3YzNkNmZiZDcwNjNmY2QxMDQ2MzVhNzkwNTIwYzBhMzk1NTU0ZTVjNmFhYWE5MzU0ZmZmZmZmZmZlMzhmJyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MTI0YzlhZDQzYjZjZjc5YmZiZjcwNDNkZTM4MTFhZDA3NjFiMGYzN2ExZTI2Mjg2YjBlOTc3YzY5YWEyNzQ1MjRlNzkwOTdhNTZkYzRiZDllMWIzNzFjNzFjNzE4YjEwJyxcbiAgICAgICAgICAgICcweDAnLFxuICAgICAgICBdLFxuICAgIF0sXG4gICAgLy8geURlblxuICAgIFtcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhOGZiJyxcbiAgICAgICAgICAgICcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYThmYicsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDAnLFxuICAgICAgICAgICAgJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhOWQzJyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MTInLFxuICAgICAgICAgICAgJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYTk5JyxcbiAgICAgICAgXSxcbiAgICAgICAgWycweDEnLCAnMHgwJ10sIC8vIExBU1QgMVxuICAgIF0sXG5dLm1hcCgoaSkgPT4gaS5tYXAoKHBhaXIpID0+IEZwMi5mcm9tQmlnVHVwbGUocGFpci5tYXAoQmlnSW50KSkpKSk7XG4vLyAxMS1pc29nZW55IG1hcCBmcm9tIEUnIHRvIEVcbmNvbnN0IGlzb2dlbnlNYXBHMSA9IGlzb2dlbnlNYXAoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHgxMWEwNWYyYjFlODMzMzQwYjgwOTEwMWRkOTk4MTU4NTZiMzAzZTg4YTJkNzAwNWZmMjYyN2I1NmNkYjRlMmM4NTYxMGMyZDVmMmU2MmQ2ZWFlYWMxNjYyNzM0NjQ5YjcnLFxuICAgICAgICAnMHgxNzI5NGVkM2U5NDNhYjJmMDU4OGJhYjIyMTQ3YTgxYzdjMTdlNzViMmY2YTg0MTdmNTY1ZTMzYzcwZDFlODZiNDgzOGYyYTZmMzE4YzM1NmU4MzRlZWYxYjNjYjgzYmInLFxuICAgICAgICAnMHhkNTQwMDVkYjk3Njc4ZWMxZDEwNDhjNWQxMGE5YTFiY2UwMzI0NzMyOTU5ODNlNTY4NzhlNTAxZWM2OGUyNWM5NThjM2UzZDJhMDk3MjlmZTAxNzlmOWRhYzllZGNiMCcsXG4gICAgICAgICcweDE3NzhlNzE2NmZjYzZkYjc0ZTA2MDlkMzA3ZTU1NDEyZDdmNWU0NjU2YThkYmYyNWYxYjMzMjg5ZjFiMzMwODM1MzM2ZTI1Y2UzMTA3MTkzYzViMzg4NjQxZDliNjg2MScsXG4gICAgICAgICcweGU5OTcyNmEzMTk5ZjQ0MzY2NDJiNGIzZTQxMThlNTQ5OWRiOTk1YTEyNTdmYjNmMDg2ZWViNjU5ODJmYWMxODk4NWEyODZmMzAxZTc3YzQ1MTE1NGNlOWFjODg5NWQ5JyxcbiAgICAgICAgJzB4MTYzMGMzMjUwZDczMTNmZjAxZDEyMDFiZjdhNzRhYjVkYjNjYjE3ZGQ5NTI3OTliOWVkM2FiOTA5N2U2OGY5MGEwODcwZDJkY2FlNzNkMTljZDEzYzFjNjZmNjUyOTgzJyxcbiAgICAgICAgJzB4ZDZlZDY1NTNmZTQ0ZDI5NmEzNzI2YzM4YWU2NTJiZmIxMTU4NjI2NGYwZjhjZTE5MDA4ZTIxOGY5Yzg2YjJhOGRhMjUxMjhjMTA1MmVjYWRkZDdmMjI1YTEzOWVkODQnLFxuICAgICAgICAnMHgxN2I4MWU3NzAxYWJkYmUyZTg3NDM4ODRkMTExN2U1MzM1NmRlNWFiMjc1YjRkYjFhNjgyYzYyZWYwZjI3NTMzMzliN2M4ZjhjOGY0NzVhZjljY2I1NjE4ZTNmMGM4OGUnLFxuICAgICAgICAnMHg4MGQzY2YxZjlhNzhmYzQ3YjkwYjMzNTYzYmU5OTBkYzQzYjc1NmNlNzlmNTU3NGEyYzU5NmM5MjhjNWQxZGU0ZmEyOTVmMjk2Yjc0ZTk1NmQ3MTk4NmE4NDk3ZTMxNycsXG4gICAgICAgICcweDE2OWIxZjhlMWJjZmE3YzQyZTBjMzc1MTVkMTM4ZjIyZGQyZWNiODAzYTBjNWM5OTY3NjMxNGJhZjRiYjFiN2ZhMzE5MGIyZWRjMDMyNzc5N2YyNDEwNjdiZTM5MGM5ZScsXG4gICAgICAgICcweDEwMzIxZGEwNzljZTA3ZTI3MmQ4ZWMwOWQyNTY1YjBkZmE3ZGNjZGRlNjc4N2Y5NmQ1MGFmMzYwMDNiMTQ4NjZmNjliNzcxZjhjMjg1ZGVjY2E2N2RmM2YxNjA1ZmI3YicsXG4gICAgICAgICcweDZlMDhjMjQ4ZTI2MGU3MGJkMWU5NjIzODFlZGVlM2QzMWQ3OWQ3ZTIyYzgzN2JjMjNjMGJmMWJjMjRjNmI2OGMyNGIxYjgwYjY0ZDM5MWZhOWM4YmEyZThiYTJkMjI5JyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweDhjYThkNTQ4Y2ZmMTlhZTE4YjJlNjJmNGJkM2ZhNmYwMWQ1ZWY0YmEzNWI0OGJhOWM5NTg4NjE3ZmM4YWM2MmI1NThkNjgxYmUzNDNkZjg5OTNjZjlmYTQwZDIxYjFjJyxcbiAgICAgICAgJzB4MTI1NjFhNWRlYjU1OWM0MzQ4YjQ3MTEyOThlNTM2MzY3MDQxZThjYTBjZjA4MDBjMDEyNmMyNTg4YzQ4YmY1NzEzZGFhODg0NmNiMDI2ZTllNWM4Mjc2ZWM4MmIzYmZmJyxcbiAgICAgICAgJzB4YjI5NjJmZTU3YTMyMjVlODEzN2U2MjliZmYyOTkxZjZmODk0MTZmNWE3MThjZDFmY2E2NGUwMGIxMWFjZWFjZDZhM2QwOTY3Yzk0ZmVkY2ZjYzIzOWJhNWNiODNlMTknLFxuICAgICAgICAnMHgzNDI1NTgxYTU4YWUyZmVjODNhYWZlZjdjNDBlYjU0NWIwODI0M2YxNmIxNjU1MTU0Y2NhOGFiYzI4ZDZmZDA0OTc2ZDUyNDNlZWNmNWM0MTMwZGU4OTM4ZGM2MmNkOCcsXG4gICAgICAgICcweDEzYThlMTYyMDIyOTE0YTgwYTZmMWQ1ZjQzZTdhMDdkZmZkZmM3NTlhMTIwNjJiYjhkNmI0NGU4MzNiMzA2ZGE5YmQyOWJhODFmMzU3ODFkNTM5ZDM5NWIzNTMyYTIxZScsXG4gICAgICAgICcweGU3MzU1ZjhlNGU2NjdiOTU1MzkwZjdmMDUwNmM2ZTkzOTU3MzVlOWNlOWNhZDRkMGE0M2JjZWYyNGI4OTgyZjc0MDBkMjRiYzQyMjhmMTFjMDJkZjlhMjlmNjMwNGE1JyxcbiAgICAgICAgJzB4NzcyY2FhY2YxNjkzNjE5MGYzZTBjNjNlMDU5NjcyMTU3MGY1Nzk5YWY1M2ExODk0ZTJlMDczMDYyYWVkZTljZWE3M2IzNTM4ZjBkZTA2Y2VjMjU3NDQ5NmVlODRhM2EnLFxuICAgICAgICAnMHgxNGE3YWMyYTlkNjRhOGIyMzBiM2Y1YjA3NGNmMDE5OTZlN2Y2M2MyMWJjYTY4YTgxOTk2ZTFjZGY5ODIyYzU4MGZhNWI5NDg5ZDExZTJkMzExZjdkOTliYmRjYzVhNWUnLFxuICAgICAgICAnMHhhMTBlY2Y2YWRhNTRmODI1ZTkyMGIzZGFmYzdhM2NjZTA3ZjhkMWQ3MTYxMzY2Yjc0MTAwZGE2N2YzOTg4MzUwMzgyNjY5MmFiYmE0MzcwNDc3NmVjM2E3OWExZDY0MScsXG4gICAgICAgICcweDk1ZmMxM2FiOWU5MmFkNDQ3NmQ2ZTNlYjNhNTY2ODBmNjgyYjRlZTk2ZjdkMDM3NzZkZjUzMzk3OGYzMWMxNTkzMTc0ZTRiNGI3ODY1MDAyZDYzODRkMTY4ZWNkZDBhJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg5MGQ5N2M4MWJhMjRlZTAyNTlkMWYwOTQ5ODBkY2ZhMTFhZDEzOGU0OGE4Njk1MjJiNTJhZjZjOTU2NTQzZDNjZDBjN2FlZTliM2JhM2MyYmU5ODQ1NzE5NzA3YmIzMycsXG4gICAgICAgICcweDEzNDk5NmExMDRlZTU4MTFkNTEwMzZkNzc2ZmI0NjgzMTIyM2U5NmMyNTRmMzgzZDBmOTA2MzQzZWI2N2FkMzRkNmM1NjcxMTk2MmZhOGJmZTA5N2U3NWEyZTQxYzY5NicsXG4gICAgICAgICcweGNjNzg2YmFhOTY2ZTY2ZjRhMzg0Yzg2YTNiNDk5NDI1NTJlMmQ2NThhMzFjZTJjMzQ0YmU0YjkxNDAwZGE3ZDI2ZDUyMTYyOGIwMDUyM2I4ZGZlMjQwYzcyZGUxZjYnLFxuICAgICAgICAnMHgxZjg2Mzc2ZTg5ODFjMjE3ODk4NzUxYWQ4NzQ2NzU3ZDQyYWE3YjkwZWViNzkxYzA5ZTRhM2VjMDMyNTFjZjlkZTQwNWFiYTllYzYxZGVjYTYzNTVjNzdiMGU1ZjRjYicsXG4gICAgICAgICcweDhjYzAzZmRlZmUwZmYxMzVjYWY0ZmUyYTIxNTI5YzQxOTU1MzZmYmUzY2U1MGI4Nzk4MzNmZDIyMTM1MWFkYzJlZTdmOGRjMDk5MDQwYTg0MWI2ZGFlY2YyZThmZWRiJyxcbiAgICAgICAgJzB4MTY2MDNmY2E0MDYzNGI2YTIyMTFlMTFkYjhmMGE2YTA3NGE3ZDBkNGFmYWRiN2JkNzY1MDVjM2QzYWQ1NTQ0ZTIwM2Y2MzI2Yzk1YTgwNzI5OWIyM2FiMTM2MzNhNWYwJyxcbiAgICAgICAgJzB4NGFiMGI5YmNmYWMxYmJjYjJjOTc3ZDAyNzc5NmIzY2U3NWJiOGNhMmJlMTg0Y2I1MjMxNDEzYzRkNjM0ZjM3NDdhODdhYzI0NjBmNDE1ZWM5NjFmODg1NWZlOWQ2ZjInLFxuICAgICAgICAnMHg5ODdjOGQ1MzMzYWI4NmZkZTk5MjZiZDJjYTZjNjc0MTcwYTA1YmZlM2JkZDgxZmZkMDM4ZGE2YzI2Yzg0MjY0MmY2NDU1MGZlZGZlOTM1YTE1ZTRjYTMxODcwZmIyOScsXG4gICAgICAgICcweDlmYzQwMThiZDk2Njg0YmU4OGM5ZTIyMWU0ZGExYmI4ZjNhYmQxNjY3OWRjMjZjMWU4YjZlNmExZjIwY2FiZTY5ZDY1MjAxYzc4NjA3YTM2MDM3MGU1NzdiZGJhNTg3JyxcbiAgICAgICAgJzB4ZTFiYmE3YTExODZiZGI1MjIzYWJkZTdhZGExNGEyM2M0MmEwY2E3OTE1YWY2ZmUwNjk4NWU3ZWQxZTRkNDNiOWIzZjcwNTVkZDRlYmE2ZjJiYWZhYWViY2E3MzFjMzAnLFxuICAgICAgICAnMHgxOTcxM2U0NzkzN2NkMWJlMGRmZDBiOGYxZDQzZmI5M2NkMmZjYmNiNmNhZjQ5M2ZkMTE4M2U0MTYzODllNjEwMzFiZjNhNWNjZTNmYmFmY2U4MTM3MTFhZDAxMWMxMzInLFxuICAgICAgICAnMHgxOGI0NmE5MDhmMzZmNmRlYjkxOGMxNDNmZWQyZWRjYzUyMzU1OWI4YWFmMGMyNDYyZTZiZmU3ZjkxMWY2NDMyNDlkOWNkZjQxYjQ0ZDYwNmNlMDdjOGE0ZDAwNzRkOGUnLFxuICAgICAgICAnMHhiMTgyY2FjMTAxYjkzOTlkMTU1MDk2MDA0ZjUzZjQ0N2FhN2IxMmEzNDI2YjA4ZWMwMjcxMGU4MDdiNDYzM2YwNmM4NTFjMTkxOTIxMWYyMGQ0YzA0ZjAwYjk3MWVmOCcsXG4gICAgICAgICcweDI0NWEzOTRhZDFlY2E5YjcyZmMwMGFlN2JlMzE1ZGM3NTdiM2IwODBkNGMxNTgwMTNlNjYzMmQzYzQwNjU5Y2M2Y2Y5MGFkMWMyMzJhNjQ0MmQ5ZDNmNWRiOTgwMTMzJyxcbiAgICAgICAgJzB4NWMxMjk2NDVlNDRjZjExMDJhMTU5Zjc0OGM0YTNmYzVlNjczZDgxZDdlODY1NjhkOWFiMGY1ZDM5NmE3Y2U0NmJhMTA0OWI2NTc5YWZiNzg2NmIxZTcxNTQ3NTIyNGInLFxuICAgICAgICAnMHgxNWU2YmU0ZTk5MGYwM2NlNGVhNTBiM2I0MmRmMmViNWNiMTgxZDhmODQ5NjVhMzk1N2FkZDRmYTk1YWYwMWIyYjY2NTAyN2VmZWMwMWM3NzA0YjQ1NmJlNjljOGI2MDQnLFxuICAgIF0sXG4gICAgLy8geURlblxuICAgIFtcbiAgICAgICAgJzB4MTYxMTJjNGMzYTljOThiMjUyMTgxMTQwZmFkMGVhZTk2MDFhNmRlNTc4OTgwYmU2ZWVjMzIzMmI1YmU3MmU3YTA3ZjM2ODhlZjYwYzIwNmQwMTQ3OTI1M2IwMzY2M2MxJyxcbiAgICAgICAgJzB4MTk2MmQ3NWMyMzgxMjAxZTFhMGNiZDZjNDNjMzQ4Yjg4NWM4NGZmNzMxYzRkNTljYTRhMTAzNTZmNDUzZTAxZjc4YTQyNjA3NjM1MjllMzUzMmY2MTAyYzJlNDlhMDNkJyxcbiAgICAgICAgJzB4NThkZjMzMDY2NDBkYTI3NmZhYWFlN2Q2ZThlYjE1Nzc4YzQ4NTU1NTFhZTdmMzEwYzM1YTVkZDI3OWNkMmVjYTY3NTdjZDYzNmY5NmY4OTFlMjUzOGI1M2RiZjY3ZjInLFxuICAgICAgICAnMHgxNmI3ZDI4ODc5OGU1Mzk1ZjIwZDIzYmY4OWVkYjRkMWQxMTVjNWRiZGRiY2QzMGUxMjNkYTQ4OWU3MjZhZjQxNzI3MzY0ZjJjMjgyOTdhZGE4ZDI2ZDk4NDQ1ZjU0MTYnLFxuICAgICAgICAnMHhiZTBlMDc5NTQ1ZjQzZTRiMDBjYzkxMmY4MjI4ZGRjYzZkMTljOWYwZjY5YmJiMDU0MmVkYTBmYzlkZWM5MTZhMjBiMTVkYzBmZDJlZGVkZGEzOTE0MjMxMWE1MDAxZCcsXG4gICAgICAgICcweDhkOWU1Mjk3MTg2ZGIyZDlmYjI2NmVhYWM3ODMxODJiNzAxNTJjNjU1NTBkODgxYzVlY2Q4N2I2ZjBmNWE2NDQ5ZjM4ZGI5ZGZhOWNjZTIwMmM2NDc3ZmFhZjliN2FjJyxcbiAgICAgICAgJzB4MTY2MDA3YzA4YTk5ZGIyZmMzYmE4NzM0YWNlOTgyNGI1ZWVjZmRmYThkMGNmOGVmNWRkMzY1YmM0MDBhMDA1MWQ1ZmE5YzAxYTU4YjFmYjkzZDFhMTM5OTEyNmE3NzVjJyxcbiAgICAgICAgJzB4MTZhM2VmMDhiZTNlYTdlYTAzYmNkZGZhYmJhNmZmNmVlNWE0Mzc1ZWZhMWY0ZmQ3ZmViMzRmZDIwNjM1NzEzMmI5MjBmNWIwMDgwMWRlZTQ2MGVlNDE1YTE1ODEyZWQ5JyxcbiAgICAgICAgJzB4MTg2NmM4ZWQzMzZjNjEyMzFhMWJlNTRmZDFkNzRjYzRmOWZiMGNlNGM2YWY1OTIwYWJjNTc1MGM0YmYzOWI0ODUyY2ZlMmY3YmI5MjQ4ODM2YjIzM2Q5ZDU1NTM1ZDRhJyxcbiAgICAgICAgJzB4MTY3YTU1Y2RhNzBhNmUxY2VhODIwNTk3ZDk0YTg0OTAzMjE2Zjc2M2UxM2Q4N2JiNTMwODU5MmU3ZWE3ZDRmYmM3Mzg1ZWEzZDUyOWIzNWUzNDZlZjQ4YmI4OTEzZjU1JyxcbiAgICAgICAgJzB4NGQyZjI1OWVlYTQwNWJkNDhmMDEwYTAxYWQyOTExZDljNmRkMDM5YmI2MWE2MjkwZTU5MWIzNmU2MzZhNWM4NzFhNWMyOWY0ZjgzMDYwNDAwZjhiNDljYmE4ZjZhYTgnLFxuICAgICAgICAnMHhhY2NiYjY3NDgxZDAzM2ZmNTg1MmMxZTQ4YzUwYzQ3N2Y5NGZmOGFlZmNlNDJkMjhjMGY5YTg4Y2VhNzkxMzUxNmY5Njg5ODZmN2ViYmVhOTY4NGI1MjllMjU2MTA5MicsXG4gICAgICAgICcweGFkNmI5NTE0Yzc2N2ZlM2MzNjEzMTQ0YjQ1ZjE0OTY1NDMzNDZkOThhZGYwMjI2N2Q1Y2VlZjlhMDBkOWI4NjkzMDAwNzYzZTNiOTBhYzExZTk5YjEzODU3MzM0NWNjJyxcbiAgICAgICAgJzB4MjY2MDQwMGViMmU0ZjNiNjI4YmRkMGQ1M2NkNzZmMmJmNTY1Yjk0ZTcyOTI3YzFjYjc0OGRmMjc5NDI0ODBlNDIwNTE3YmQ4NzE0Y2M4MGQxZmFkYzEzMjZlZDA2ZjcnLFxuICAgICAgICAnMHhlMGZhMWQ4MTZkZGMwM2U2YjI0MjU1ZTBkNzgxOWMxNzFjNDBmNjVlMjczYjg1MzMyNGVmY2Q2MzU2Y2FhMjA1Y2EyZjU3MGYxMzQ5NzgwNDQxNTQ3M2ExZDYzNGI4ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG5dLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IEJpZ0ludChqKSkpKTtcbi8vIFNXVSBNYXAgLSBGcDIgdG8gRzInOiB5wrIgPSB4wrMgKyAyNDBpICogeCArIDEwMTIgKyAxMDEyaVxuY29uc3QgRzJfU1dVID0gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcDIsIHtcbiAgICBBOiBGcDIuY3JlYXRlKHsgYzA6IEZwLmNyZWF0ZShfMG4pLCBjMTogRnAuY3JlYXRlKEJpZ0ludCgyNDApKSB9KSwgLy8gQScgPSAyNDAgKiBJXG4gICAgQjogRnAyLmNyZWF0ZSh7IGMwOiBGcC5jcmVhdGUoQmlnSW50KDEwMTIpKSwgYzE6IEZwLmNyZWF0ZShCaWdJbnQoMTAxMikpIH0pLCAvLyBCJyA9IDEwMTIgKiAoMSArIEkpXG4gICAgWjogRnAyLmNyZWF0ZSh7IGMwOiBGcC5jcmVhdGUoQmlnSW50KC0yKSksIGMxOiBGcC5jcmVhdGUoQmlnSW50KC0xKSkgfSksIC8vIFo6IC0oMiArIEkpXG59KTtcbi8vIE9wdGltaXplZCBTV1UgTWFwIC0gRnAgdG8gRzFcbmNvbnN0IEcxX1NXVSA9IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBGcC5jcmVhdGUoQmlnSW50KCcweDE0NDY5OGEzYjhlOTQzM2Q2OTNhMDJjOTZkNDk4MmIwZWE5ODUzODNlZTY2YThkOGU4OTgxYWVmZDg4MWFjOTg5MzZmOGRhMGUwZjk3ZjVjZjQyODA4MmQ1ODRjMWQnKSksXG4gICAgQjogRnAuY3JlYXRlKEJpZ0ludCgnMHgxMmUyOTA4ZDExNjg4MDMwMDE4YjEyZTg3NTNlZWUzYjIwMTZjMWYwZjI0ZjQwNzBhMGI5YzE0ZmNlZjM1ZWY1NWEyMzIxNWEzMTZjZWFhNWQxY2M0OGU5OGUxNzJiZTAnKSksXG4gICAgWjogRnAuY3JlYXRlKEJpZ0ludCgxMSkpLFxufSk7XG4vLyBFbmRvbW9ycGhpc21zIChmb3IgZmFzdCBjb2ZhY3RvciBjbGVhcmluZylcbi8vIM6oKFApIGVuZG9tb3JwaGlzbVxuY29uc3QgeyBHMnBzaSwgRzJwc2kyIH0gPSBwc2lGcm9iZW5pdXMoRnAsIEZwMiwgRnAyLmRpdihGcDIuT05FLCBGcDIuTk9OUkVTSURVRSkpOyAvLyAxLyh1KzEpXG4vLyBEZWZhdWx0IGhhc2hfdG9fZmllbGQgb3B0aW9ucyBhcmUgZm9yIGhhc2ggdG8gRzIuXG4vL1xuLy8gUGFyYW1ldGVyIGRlZmluaXRpb25zIGFyZSBpbiBzZWN0aW9uIDUuMyBvZiB0aGUgc3BlYyB1bmxlc3Mgb3RoZXJ3aXNlIG5vdGVkLlxuLy8gUGFyYW1ldGVyIHZhbHVlcyBjb21lIGZyb20gc2VjdGlvbiA4LjguMiBvZiB0aGUgc3BlYy5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tOC44LjJcbi8vXG4vLyBCYXNlIGZpZWxkIEYgaXMgR0YocF5tKVxuLy8gcCA9IDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiXG4vLyBtID0gMiAob3IgMSBmb3IgRzEgc2VlIHNlY3Rpb24gOC44LjEpXG4vLyBrID0gMTI4XG5jb25zdCBodGZEZWZhdWx0cyA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8vIERTVDogYSBkb21haW4gc2VwYXJhdGlvbiB0YWdcbiAgICAvLyBkZWZpbmVkIGluIHNlY3Rpb24gMi4yLjVcbiAgICAvLyBVc2UgdXRpbHMuZ2V0RFNUTGFiZWwoKSwgdXRpbHMuc2V0RFNUTGFiZWwodmFsdWUpXG4gICAgRFNUOiAnQkxTX1NJR19CTFMxMjM4MUcyX1hNRDpTSEEtMjU2X1NTV1VfUk9fTlVMXycsXG4gICAgZW5jb2RlRFNUOiAnQkxTX1NJR19CTFMxMjM4MUcyX1hNRDpTSEEtMjU2X1NTV1VfUk9fTlVMXycsXG4gICAgLy8gcDogdGhlIGNoYXJhY3RlcmlzdGljIG9mIEZcbiAgICAvLyAgICB3aGVyZSBGIGlzIGEgZmluaXRlIGZpZWxkIG9mIGNoYXJhY3RlcmlzdGljIHAgYW5kIG9yZGVyIHEgPSBwXm1cbiAgICBwOiBGcC5PUkRFUixcbiAgICAvLyBtOiB0aGUgZXh0ZW5zaW9uIGRlZ3JlZSBvZiBGLCBtID49IDFcbiAgICAvLyAgICAgd2hlcmUgRiBpcyBhIGZpbml0ZSBmaWVsZCBvZiBjaGFyYWN0ZXJpc3RpYyBwIGFuZCBvcmRlciBxID0gcF5tXG4gICAgbTogMixcbiAgICAvLyBrOiB0aGUgdGFyZ2V0IHNlY3VyaXR5IGxldmVsIGZvciB0aGUgc3VpdGUgaW4gYml0c1xuICAgIC8vIGRlZmluZWQgaW4gc2VjdGlvbiA1LjFcbiAgICBrOiAxMjgsXG4gICAgLy8gb3B0aW9uIHRvIHVzZSBhIG1lc3NhZ2UgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCBieVxuICAgIC8vIGV4cGFuZF9tZXNzYWdlX3htZFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgLy8gSGFzaCBmdW5jdGlvbnMgZm9yOiBleHBhbmRfbWVzc2FnZV94bWQgaXMgYXBwcm9wcmlhdGUgZm9yIHVzZSB3aXRoIGFcbiAgICAvLyB3aWRlIHJhbmdlIG9mIGhhc2ggZnVuY3Rpb25zLCBpbmNsdWRpbmcgU0hBLTIsIFNIQS0zLCBCTEFLRTIsIGFuZCBvdGhlcnMuXG4gICAgLy8gQkJTKyB1c2VzIGJsYWtlMjogaHR0cHM6Ly9naXRodWIuY29tL2h5cGVybGVkZ2VyL2FyaWVzLWZyYW1ld29yay1nby9pc3N1ZXMvMjI0N1xuICAgIGhhc2g6IHNoYTI1Nixcbn0pO1xuLy8gRW5jb2RpbmcgdXRpbHNcbi8vIFBvaW50IG9uIEcxIGN1cnZlOiAoeCwgeSlcbi8vIENvbXByZXNzZWQgcG9pbnQgb2YgaW5maW5pdHlcbmNvbnN0IENPTVBSRVNTRURfWkVSTyA9IHNldE1hc2soRnAudG9CeXRlcyhfMG4pLCB7IGluZmluaXR5OiB0cnVlLCBjb21wcmVzc2VkOiB0cnVlIH0pOyAvLyBzZXQgY29tcHJlc3NlZCAmIHBvaW50LWF0LWluZmluaXR5IGJpdHNcbmZ1bmN0aW9uIHBhcnNlTWFzayhieXRlcykge1xuICAgIC8vIENvcHksIHNvIHdlIGNhbiByZW1vdmUgbWFzayBkYXRhLiBJdCB3aWxsIGJlIHJlbW92ZWQgYWxzbyBsYXRlciwgd2hlbiBGcC5jcmVhdGUgd2lsbCBjYWxsIG1vZHVsby5cbiAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKCk7XG4gICAgY29uc3QgbWFzayA9IGJ5dGVzWzBdICYgMjI0O1xuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAhISgobWFzayA+PiA3KSAmIDEpOyAvLyBjb21wcmVzc2lvbiBiaXQgKDBiMTAwMF8wMDAwKVxuICAgIGNvbnN0IGluZmluaXR5ID0gISEoKG1hc2sgPj4gNikgJiAxKTsgLy8gcG9pbnQgYXQgaW5maW5pdHkgYml0ICgwYjAxMDBfMDAwMClcbiAgICBjb25zdCBzb3J0ID0gISEoKG1hc2sgPj4gNSkgJiAxKTsgLy8gc29ydCBiaXQgKDBiMDAxMF8wMDAwKVxuICAgIGJ5dGVzWzBdICY9IDMxOyAvLyBjbGVhciBtYXNrICh6ZXJvIGZpcnN0IDMgYml0cylcbiAgICByZXR1cm4geyBjb21wcmVzc2VkLCBpbmZpbml0eSwgc29ydCwgdmFsdWU6IGJ5dGVzIH07XG59XG5mdW5jdGlvbiBzZXRNYXNrKGJ5dGVzLCBtYXNrKSB7XG4gICAgaWYgKGJ5dGVzWzBdICYgMjI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldE1hc2s6IG5vbi1lbXB0eSBtYXNrJyk7XG4gICAgaWYgKG1hc2suY29tcHJlc3NlZClcbiAgICAgICAgYnl0ZXNbMF0gfD0gMTI4O1xuICAgIGlmIChtYXNrLmluZmluaXR5KVxuICAgICAgICBieXRlc1swXSB8PSA2NDtcbiAgICBpZiAobWFzay5zb3J0KVxuICAgICAgICBieXRlc1swXSB8PSAzMjtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBzaWduYXR1cmVHMVRvUmF3Qnl0ZXMocG9pbnQpIHtcbiAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIGNvbnN0IGlzWmVybyA9IHBvaW50LmVxdWFscyhibHMxMl8zODEuRzEuUHJvamVjdGl2ZVBvaW50LlpFUk8pO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICBpZiAoaXNaZXJvKVxuICAgICAgICByZXR1cm4gQ09NUFJFU1NFRF9aRVJPLnNsaWNlKCk7XG4gICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgIGNvbnN0IHNvcnQgPSBCb29sZWFuKCh5ICogXzJuKSAvIFApO1xuICAgIHJldHVybiBzZXRNYXNrKG51bWJlclRvQnl0ZXNCRSh4LCBGcC5CWVRFUyksIHsgY29tcHJlc3NlZDogdHJ1ZSwgc29ydCB9KTtcbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZUcyVG9SYXdCeXRlcyhwb2ludCkge1xuICAgIC8vIE5PVEU6IGJ5IHNvbWUgcmVhc29ucyBpdCB3YXMgbWlzc2VkIGluIGJsczEyLTM4MSwgbG9va3MgbGlrZSBidWdcbiAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIGNvbnN0IGxlbiA9IEZwLkJZVEVTO1xuICAgIGlmIChwb2ludC5lcXVhbHMoYmxzMTJfMzgxLkcyLlByb2plY3RpdmVQb2ludC5aRVJPKSlcbiAgICAgICAgcmV0dXJuIGNvbmNhdEIoQ09NUFJFU1NFRF9aRVJPLCBudW1iZXJUb0J5dGVzQkUoXzBuLCBsZW4pKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgY29uc3QgeyByZTogeDAsIGltOiB4MSB9ID0gRnAyLnJlaW0oeCk7XG4gICAgY29uc3QgeyByZTogeTAsIGltOiB5MSB9ID0gRnAyLnJlaW0oeSk7XG4gICAgY29uc3QgdG1wID0geTEgPiBfMG4gPyB5MSAqIF8ybiA6IHkwICogXzJuO1xuICAgIGNvbnN0IHNvcnQgPSBCb29sZWFuKCh0bXAgLyBGcC5PUkRFUikgJiBfMW4pO1xuICAgIGNvbnN0IHoyID0geDA7XG4gICAgcmV0dXJuIGNvbmNhdEIoc2V0TWFzayhudW1iZXJUb0J5dGVzQkUoeDEsIGxlbiksIHsgc29ydCwgY29tcHJlc3NlZDogdHJ1ZSB9KSwgbnVtYmVyVG9CeXRlc0JFKHoyLCBsZW4pKTtcbn1cbi8vIFRvIHZlcmlmeSBjdXJ2ZSBwYXJhbWV0ZXJzLCBzZWUgcGFpcmluZy1mcmllbmRseS1jdXJ2ZXMgc3BlYzpcbi8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXBhaXJpbmctZnJpZW5kbHktY3VydmVzLTExXG4vLyBCYXNpYyBtYXRoIGlzIGRvbmUgb3ZlciBmaW5pdGUgZmllbGRzIG92ZXIgcC5cbi8vIE1vcmUgY29tcGxpY2F0ZWQgbWF0aCBpcyBkb25lIG92ZXIgcG9seW5vbWluYWwgZXh0ZW5zaW9uIGZpZWxkcy5cbi8vIFRvIHNpbXBsaWZ5IGNhbGN1bGF0aW9ucyBpbiBGcDEyLCB3ZSBjb25zdHJ1Y3QgZXh0ZW5zaW9uIHRvd2VyOlxuLy8gRnDigoHigoIgPSBGcOKChsKyID0+IEZw4oKCwrNcbi8vIEZwKHUpIC8gKHXCsiAtIM6yKSB3aGVyZSDOsiA9IC0xXG4vLyBGcOKCgih2KSAvICh2wrMgLSDOvikgd2hlcmUgzr4gPSB1ICsgMVxuLy8gRnDigoYodykgLyAod8KyIC0gzrMpIHdoZXJlIM6zID0gdlxuLy8gSGVyZSBnb2VzIGNvbnN0YW50cyAmJiBwb2ludCBlbmNvZGluZyBmb3JtYXRcbmV4cG9ydCBjb25zdCBibHMxMl8zODEgPSBibHMoe1xuICAgIC8vIEZpZWxkc1xuICAgIGZpZWxkczoge1xuICAgICAgICBGcCxcbiAgICAgICAgRnAyLFxuICAgICAgICBGcDYsXG4gICAgICAgIEZwMTIsXG4gICAgICAgIEZyLFxuICAgIH0sXG4gICAgLy8gRzEgaXMgdGhlIG9yZGVyLXEgc3ViZ3JvdXAgb2YgRTEoRnApIDogecKyID0geMKzICsgNCwgI0UxKEZwKSA9IGgxcSwgd2hlcmVcbiAgICAvLyBjaGFyYWN0ZXJpc3RpYzsgeiArICh64oG0IC0gesKyICsgMSkoeiAtIDEpwrIvM1xuICAgIEcxOiB7XG4gICAgICAgIEZwLFxuICAgICAgICAvLyBjb2ZhY3RvcjsgKHogLSAxKcKyLzNcbiAgICAgICAgaDogQmlnSW50KCcweDM5NmM4YzAwNTU1NWUxNTY4YzAwYWFhYjAwMDBhYWFiJyksXG4gICAgICAgIC8vIGdlbmVyYXRvcidzIGNvb3JkaW5hdGVzXG4gICAgICAgIC8vIHggPSAzNjg1NDE2NzUzNzEzMzg3MDE2NzgxMDg4MzE1MTgzMDc3NzU3OTYxNjIwNzk1NzgyNTQ2NDA5ODk0NTc4Mzc4Njg4NjA3NTkyMzc4Mzc2MzE4ODM2MDU0OTQ3Njc2MzQ1ODIxNTQ4MTA0MTg1NDY0NTA3XG4gICAgICAgIC8vIHkgPSAxMzM5NTA2NTQ0OTQ0NDc2NDczMDIwNDcxMzc5OTQxOTIxMjIxNTg0OTMzODc1OTM4MzQ5NjIwNDI2NTQzNzM2NDE2NTExNDIzOTU2MzMzNTA2NDcyNzI0NjU1MzUzMzY2NTM0OTkyMzkxNzU2NDQxNTY5XG4gICAgICAgIEd4OiBCaWdJbnQoJzB4MTdmMWQzYTczMTk3ZDc5NDI2OTU2MzhjNGZhOWFjMGZjMzY4OGM0Zjk3NzRiOTA1YTE0ZTNhM2YxNzFiYWM1ODZjNTVlODNmZjk3YTFhZWZmYjNhZjAwYWRiMjJjNmJiJyksXG4gICAgICAgIEd5OiBCaWdJbnQoJzB4MDhiM2Y0ODFlM2FhYTBmMWEwOWUzMGVkNzQxZDhhZTRmY2Y1ZTA5NWQ1ZDAwYWY2MDBkYjE4Y2IyYzA0YjNlZGQwM2NjNzQ0YTI4ODhhZTQwY2FhMjMyOTQ2YzVlN2UxJyksXG4gICAgICAgIGE6IEZwLlpFUk8sXG4gICAgICAgIGI6IF80bixcbiAgICAgICAgaHRmRGVmYXVsdHM6IHsgLi4uaHRmRGVmYXVsdHMsIG06IDEsIERTVDogJ0JMU19TSUdfQkxTMTIzODFHMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPX05VTF8nIH0sXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiB0cnVlLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6IHRydWUsXG4gICAgICAgIC8vIENoZWNrcyBpcyB0aGUgcG9pbnQgcmVzaWRlcyBpbiBwcmltZS1vcmRlciBzdWJncm91cC5cbiAgICAgICAgLy8gcG9pbnQuaXNUb3JzaW9uRnJlZSgpIHNob3VsZCByZXR1cm4gdHJ1ZSBmb3IgdmFsaWQgcG9pbnRzXG4gICAgICAgIC8vIEl0IHJldHVybnMgZmFsc2UgZm9yIHNoaXR0eSBwb2ludHMuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjEvMTEzMC5wZGZcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogKGMsIHBvaW50KSA9PiB7XG4gICAgICAgICAgICAvLyDPhiBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGNvbnN0IGN1YmljUm9vdE9mVW5pdHlNb2RQID0gQmlnSW50KCcweDVmMTk2NzJmZGY3NmNlNTFiYTY5YzYwNzZhMGY3N2VhZGRiM2E5M2JlNmY4OTY4OGRlMTdkODEzNjIwYTAwMDIyZTAxZmZmZmZmZmVmZmZlJyk7XG4gICAgICAgICAgICBjb25zdCBwaGkgPSBuZXcgYyhGcC5tdWwocG9pbnQucHgsIGN1YmljUm9vdE9mVW5pdHlNb2RQKSwgcG9pbnQucHksIHBvaW50LnB6KTtcbiAgICAgICAgICAgIC8vIHRvZG86IHVucm9sbFxuICAgICAgICAgICAgY29uc3QgeFAgPSBwb2ludC5tdWx0aXBseVVuc2FmZShCTFNfWCkubmVnYXRlKCk7IC8vIFt4XVBcbiAgICAgICAgICAgIGNvbnN0IHUyUCA9IHhQLm11bHRpcGx5VW5zYWZlKEJMU19YKTsgLy8gW3UyXVBcbiAgICAgICAgICAgIHJldHVybiB1MlAuZXF1YWxzKHBoaSk7XG4gICAgICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5LzgxNC5wZGZcbiAgICAgICAgICAgIC8vICh6wrIg4oiSIDEpLzNcbiAgICAgICAgICAgIC8vIGNvbnN0IGMxID0gQmlnSW50KCcweDM5NmM4YzAwNTU1NWUxNTYwMDAwMDAwMDU1NTU1NTU1Jyk7XG4gICAgICAgICAgICAvLyBjb25zdCBQID0gdGhpcztcbiAgICAgICAgICAgIC8vIGNvbnN0IFMgPSBQLnNpZ21hKCk7XG4gICAgICAgICAgICAvLyBjb25zdCBRID0gUy5kb3VibGUoKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IFMyID0gUy5zaWdtYSgpO1xuICAgICAgICAgICAgLy8gLy8gWyh6wrIg4oiSIDEpLzNdKDLPgyhQKSDiiJIgUCDiiJIgz4PCsihQKSkg4oiSIM+DwrIoUCkgPSBPXG4gICAgICAgICAgICAvLyBjb25zdCBsZWZ0ID0gUS5zdWJ0cmFjdChQKS5zdWJ0cmFjdChTMikubXVsdGlwbHlVbnNhZmUoYzEpO1xuICAgICAgICAgICAgLy8gY29uc3QgQyA9IGxlZnQuc3VidHJhY3QoUzIpO1xuICAgICAgICAgICAgLy8gcmV0dXJuIEMuaXNaZXJvKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENsZWFyIGNvZmFjdG9yIG9mIEcxXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTkvNDAzXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6IChfYywgcG9pbnQpID0+IHtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50Lm11bHRpcGx5VW5zYWZlKEJMU19YKS5hZGQocG9pbnQpOyAvLyB4KlAgKyBQXG4gICAgICAgIH0sXG4gICAgICAgIG1hcFRvQ3VydmU6IChzY2FsYXJzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IEcxX1NXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgICAgICAgICAgcmV0dXJuIGlzb2dlbnlNYXBHMSh4LCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29tcHJlc3NlZCwgaW5maW5pdHksIHNvcnQsIHZhbHVlIH0gPSBwYXJzZU1hc2soYnl0ZXMpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gNDggJiYgY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZwLmJ5dGVzXG4gICAgICAgICAgICAgICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWRWYWx1ZSA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gWmVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5jcmVhdGUoY29tcHJlc3NlZFZhbHVlICYgRnAuTUFTSyk7XG4gICAgICAgICAgICAgICAgaWYgKGluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICE9PSBfMG4pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0cxOiBub24tZW1wdHkgY29tcHJlc3NlZCBwb2ludCBhdCBpbmZpbml0eScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBfMG4sIHk6IF8wbiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IEZwLmFkZChGcC5wb3coeCwgXzNuKSwgRnAuY3JlYXRlKGJsczEyXzM4MS5wYXJhbXMuRzFiKSk7IC8vIHnCsiA9IHjCsyArIGJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwLnNxcnQocmlnaHQpO1xuICAgICAgICAgICAgICAgIGlmICgheSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbXByZXNzZWQgRzEgcG9pbnQnKTtcbiAgICAgICAgICAgICAgICBpZiAoKHkgKiBfMm4pIC8gUCAhPT0gQmlnSW50KHNvcnQpKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLmNyZWF0ZSh4KSwgeTogRnAuY3JlYXRlKHkpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IDk2ICYmICFjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGluZmluaXR5IGZsYWcgaXMgc2V0XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZS5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyQkUodmFsdWUuc3ViYXJyYXkoRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggIT09IF8wbiB8fCB5ICE9PSBfMG4pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0cxOiBub24tZW1wdHkgcG9pbnQgYXQgaW5maW5pdHknKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsczEyXzM4MS5HMS5Qcm9qZWN0aXZlUG9pbnQuWkVSTy50b0FmZmluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcC5jcmVhdGUoeCksIHk6IEZwLmNyZWF0ZSh5KSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBvaW50IEcxLCBleHBlY3RlZCA0OC85NiBieXRlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b0J5dGVzOiAoYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNaZXJvID0gcG9pbnQuZXF1YWxzKGMuWkVSTyk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzWmVybylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENPTVBSRVNTRURfWkVSTy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBGcC5PUkRFUjtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0ID0gQm9vbGVhbigoeSAqIF8ybikgLyBQKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0TWFzayhudW1iZXJUb0J5dGVzQkUoeCwgRnAuQllURVMpLCB7IGNvbXByZXNzZWQ6IHRydWUsIHNvcnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDJ4IFBVQkxJQ19LRVlfTEVOR1RIXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBjb25jYXRCKG5ldyBVaW50OEFycmF5KFsweDQwXSksIG5ldyBVaW50OEFycmF5KDIgKiBGcC5CWVRFUyAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0QihudW1iZXJUb0J5dGVzQkUoeCwgRnAuQllURVMpLCBudW1iZXJUb0J5dGVzQkUoeSwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFNob3J0U2lnbmF0dXJlOiB7XG4gICAgICAgICAgICBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5maW5pdHksIHNvcnQsIHZhbHVlIH0gPSBwYXJzZU1hc2soZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZUhleCcsIGhleCwgNDgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZFZhbHVlID0gYnl0ZXNUb051bWJlckJFKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICAgICAgaWYgKGluZmluaXR5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxzMTJfMzgxLkcxLlByb2plY3RpdmVQb2ludC5aRVJPO1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5jcmVhdGUoY29tcHJlc3NlZFZhbHVlICYgRnAuTUFTSyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBGcC5hZGQoRnAucG93KHgsIF8zbiksIEZwLmNyZWF0ZShibHMxMl8zODEucGFyYW1zLkcxYikpOyAvLyB5wrIgPSB4wrMgKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcC5zcXJ0KHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoIXkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb21wcmVzc2VkIEcxIHBvaW50Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWZsYWcgPSBCaWdJbnQoc29ydCk7XG4gICAgICAgICAgICAgICAgaWYgKCh5ICogXzJuKSAvIFAgIT09IGFmbGFnKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gYmxzMTJfMzgxLkcxLlByb2plY3RpdmVQb2ludC5mcm9tQWZmaW5lKHsgeCwgeSB9KTtcbiAgICAgICAgICAgICAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b1Jhd0J5dGVzKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZUcxVG9SYXdCeXRlcyhwb2ludCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9IZXgocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleChzaWduYXR1cmVHMVRvUmF3Qnl0ZXMocG9pbnQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBHMiBpcyB0aGUgb3JkZXItcSBzdWJncm91cCBvZiBFMihGcMKyKSA6IHnCsiA9IHjCsys0KDEr4oia4oiSMSksXG4gICAgLy8gd2hlcmUgRnAyIGlzIEZwW+KImuKIkjFdLyh4MisxKS4gI0UyKEZwMiApID0gaDJxLCB3aGVyZVxuICAgIC8vIEfCsiAtIDFcbiAgICAvLyBoMnFcbiAgICBHMjoge1xuICAgICAgICBGcDogRnAyLFxuICAgICAgICAvLyBjb2ZhY3RvclxuICAgICAgICBoOiBCaWdJbnQoJzB4NWQ1NDNhOTU0MTRlN2YxMDkxZDUwNzkyODc2YTIwMmNkOTFkZTQ1NDcwODVhYmFhNjhhMjA1YjJlNWE3ZGRmYTYyOGYxY2I0ZDllODJlZjIxNTM3ZTI5M2E2NjkxYWUxNjE2ZWM2ZTc4NmYwYzcwY2YxYzM4ZTMxYzcyMzhlNScpLFxuICAgICAgICBHeDogRnAyLmZyb21CaWdUdXBsZShbXG4gICAgICAgICAgICBCaWdJbnQoJzB4MDI0YWEyYjJmMDhmMGE5MTI2MDgwNTI3MmRjNTEwNTFjNmU0N2FkNGZhNDAzYjAyYjQ1MTBiNjQ3YWUzZDE3NzBiYWMwMzI2YTgwNWJiZWZkNDgwNTZjOGMxMjFiZGI4JyksXG4gICAgICAgICAgICBCaWdJbnQoJzB4MTNlMDJiNjA1MjcxOWY2MDdkYWNkM2EwODgyNzRmNjU1OTZiZDBkMDk5MjBiNjFhYjVkYTYxYmJkYzdmNTA0OTMzNGNmMTEyMTM5NDVkNTdlNWFjN2QwNTVkMDQyYjdlJyksXG4gICAgICAgIF0pLFxuICAgICAgICAvLyB5ID1cbiAgICAgICAgLy8gOTI3NTUzNjY1NDkyMzMyNDU1NzQ3MjAxOTY1Nzc2MDM3ODgwNzU3NzQwMTkzNDUzNTkyOTcwMDI1MDI3OTc4NzkzOTc2ODc3MDAyNjc1NTY0OTgwOTQ5Mjg5NzI3OTU3NTY1NTc1NDMzMzQ0MjE5NTgyLFxuICAgICAgICAvLyAxOTg1MTUwNjAyMjg3MjkxOTM1NTY4MDU0NTIxMTc3MTcxNjM4MzAwODY4OTc4MjE1NjU1NzMwODU5Mzc4NjY1MDY2MzQ0NzI2MzczODIzNzE4NDIzODY5MTA0MjYzMzMzOTg0NjQxNDk0MzQwMzQ3OTA1XG4gICAgICAgIEd5OiBGcDIuZnJvbUJpZ1R1cGxlKFtcbiAgICAgICAgICAgIEJpZ0ludCgnMHgwY2U1ZDUyNzcyN2Q2ZTExOGNjOWNkYzZkYTJlMzUxYWFkZmQ5YmFhOGNiZGQzYTc2ZDQyOWE2OTUxNjBkMTJjOTIzYWM5Y2MzYmFjYTI4OWUxOTM1NDg2MDhiODI4MDEnKSxcbiAgICAgICAgICAgIEJpZ0ludCgnMHgwNjA2YzRhMDJlYTczNGNjMzJhY2QyYjAyYmMyOGI5OWNiM2UyODdlODVhNzYzYWYyNjc0OTJhYjU3MmU5OWFiM2YzNzBkMjc1Y2VjMWRhMWFhYTkwNzVmZjA1Zjc5YmUnKSxcbiAgICAgICAgXSksXG4gICAgICAgIGE6IEZwMi5aRVJPLFxuICAgICAgICBiOiBGcDIuZnJvbUJpZ1R1cGxlKFtfNG4sIF80bl0pLFxuICAgICAgICBoRWZmOiBCaWdJbnQoJzB4YmM2OWYwOGYyZWU3NWIzNTg0YzZhMGVhOTFiMzUyODg4ZTJhOGU5MTQ1YWQ3Njg5OTg2ZmYwMzE1MDhmZmUxMzI5YzJmMTc4NzMxZGI5NTZkODJiZjAxNWQxMjEyYjAyZWMwZWM2OWQ3NDc3YzFhZTk1NGNiYzA2Njg5ZjZhMzU5ODk0YzBhZGViYmY2YjRlODAyMDAwNWFhYTk1NTUxJyksXG4gICAgICAgIGh0ZkRlZmF1bHRzOiB7IC4uLmh0ZkRlZmF1bHRzIH0sXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiB0cnVlLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6IHRydWUsXG4gICAgICAgIG1hcFRvQ3VydmU6IChzY2FsYXJzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IEcyX1NXVShGcDIuZnJvbUJpZ1R1cGxlKHNjYWxhcnMpKTtcbiAgICAgICAgICAgIHJldHVybiBpc29nZW55TWFwRzIoeCwgeSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENoZWNrcyBpcyB0aGUgcG9pbnQgcmVzaWRlcyBpbiBwcmltZS1vcmRlciBzdWJncm91cC5cbiAgICAgICAgLy8gcG9pbnQuaXNUb3JzaW9uRnJlZSgpIHNob3VsZCByZXR1cm4gdHJ1ZSBmb3IgdmFsaWQgcG9pbnRzXG4gICAgICAgIC8vIEl0IHJldHVybnMgZmFsc2UgZm9yIHNoaXR0eSBwb2ludHMuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjEvMTEzMC5wZGZcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogKGMsIFApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQLm11bHRpcGx5VW5zYWZlKEJMU19YKS5uZWdhdGUoKS5lcXVhbHMoRzJwc2koYywgUCkpOyAvLyDPiChQKSA9PSBbdV0oUClcbiAgICAgICAgICAgIC8vIE9sZGVyIHZlcnNpb246IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTkvODE0LnBkZlxuICAgICAgICAgICAgLy8gzqjCsihQKSA9PiDOqMKzKFApID0+IFt6Xc6owrMoUCkgd2hlcmUgeiA9IC14ID0+IFt6Xc6owrMoUCkgLSDOqMKyKFApICsgUCA9PSBPXG4gICAgICAgICAgICAvLyByZXR1cm4gUC5wc2kyKCkucHNpKCkubXVsTmVnWCgpLnN1YnRyYWN0KHBzaTIpLmFkZChQKS5pc1plcm8oKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFwcyB0aGUgcG9pbnQgaW50byB0aGUgcHJpbWUtb3JkZXIgc3ViZ3JvdXAgRzIuXG4gICAgICAgIC8vIGNsZWFyX2NvZmFjdG9yX2JsczEyMzgxX2cyIGZyb20gY2ZyZy1oYXNoLXRvLWN1cnZlLTExXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTcvNDE5LnBkZlxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogKGMsIFApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBCTFNfWDtcbiAgICAgICAgICAgIGxldCB0MSA9IFAubXVsdGlwbHlVbnNhZmUoeCkubmVnYXRlKCk7IC8vIFsteF1QXG4gICAgICAgICAgICBsZXQgdDIgPSBHMnBzaShjLCBQKTsgLy8gzqgoUClcbiAgICAgICAgICAgIGxldCB0MyA9IFAuZG91YmxlKCk7IC8vIDJQXG4gICAgICAgICAgICB0MyA9IEcycHNpMihjLCB0Myk7IC8vIM6owrIoMlApXG4gICAgICAgICAgICB0MyA9IHQzLnN1YnRyYWN0KHQyKTsgLy8gzqjCsigyUCkgLSDOqChQKVxuICAgICAgICAgICAgdDIgPSB0MS5hZGQodDIpOyAvLyBbLXhdUCArIM6oKFApXG4gICAgICAgICAgICB0MiA9IHQyLm11bHRpcGx5VW5zYWZlKHgpLm5lZ2F0ZSgpOyAvLyBbeMKyXVAgLSBbeF3OqChQKVxuICAgICAgICAgICAgdDMgPSB0My5hZGQodDIpOyAvLyDOqMKyKDJQKSAtIM6oKFApICsgW3jCsl1QIC0gW3hdzqgoUClcbiAgICAgICAgICAgIHQzID0gdDMuc3VidHJhY3QodDEpOyAvLyDOqMKyKDJQKSAtIM6oKFApICsgW3jCsl1QIC0gW3hdzqgoUCkgKyBbeF1QXG4gICAgICAgICAgICBjb25zdCBRID0gdDMuc3VidHJhY3QoUCk7IC8vIM6owrIoMlApIC0gzqgoUCkgKyBbeMKyXVAgLSBbeF3OqChQKSArIFt4XVAgLSAxUFxuICAgICAgICAgICAgcmV0dXJuIFE7IC8vIFt4wrIteC0xXVAgKyBbeC0xXc6oKFApICsgzqjCsigyUClcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29tcHJlc3NlZCwgaW5maW5pdHksIHNvcnQsIHZhbHVlIH0gPSBwYXJzZU1hc2soYnl0ZXMpO1xuICAgICAgICAgICAgaWYgKCghY29tcHJlc3NlZCAmJiAhaW5maW5pdHkgJiYgc29ydCkgfHwgLy8gMDAxMDAwMDBcbiAgICAgICAgICAgICAgICAoIWNvbXByZXNzZWQgJiYgaW5maW5pdHkgJiYgc29ydCkgfHwgLy8gMDExMDAwMDBcbiAgICAgICAgICAgICAgICAoc29ydCAmJiBpbmZpbml0eSAmJiBjb21wcmVzc2VkKSAvLyAxMTEwMDAwMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nIGZsYWc6ICcgKyAoYnl0ZXNbMF0gJiAyMjQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IEwgPSBGcC5CWVRFUztcbiAgICAgICAgICAgIGNvbnN0IHNsYyA9IChiLCBmcm9tLCB0bykgPT4gYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDk2ICYmIGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gYmxzMTJfMzgxLnBhcmFtcy5HMmI7XG4gICAgICAgICAgICAgICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgICAgICAgICAgICAgIGlmIChpbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGF0IGFsbCBieXRlcyBhcmUgMFxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUucmVkdWNlKChwLCBjKSA9PiAocCAhPT0gMCA/IGMgKyAxIDogYyksIDApID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbXByZXNzZWQgRzIgcG9pbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcDIuWkVSTywgeTogRnAyLlpFUk8gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeF8xID0gc2xjKHZhbHVlLCAwLCBMKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4XzAgPSBzbGModmFsdWUsIEwsIDIgKiBMKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAyLmNyZWF0ZSh7IGMwOiBGcC5jcmVhdGUoeF8wKSwgYzE6IEZwLmNyZWF0ZSh4XzEpIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gRnAyLmFkZChGcDIucG93KHgsIF8zbiksIGIpOyAvLyB5wrIgPSB4wrMgKyA0ICogKHUrMSkgPSB4wrMgKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcDIuc3FydChyaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgWV9iaXQgPSB5LmMxID09PSBfMG4gPyAoeS5jMCAqIF8ybikgLyBQIDogKHkuYzEgKiBfMm4pIC8gUCA/IF8xbiA6IF8wbjtcbiAgICAgICAgICAgICAgICB5ID0gc29ydCAmJiBZX2JpdCA+IDAgPyB5IDogRnAyLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IDE5MiAmJiAhY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUucmVkdWNlKChwLCBjKSA9PiAocCAhPT0gMCA/IGMgKyAxIDogYyksIDApID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVuY29tcHJlc3NlZCBHMiBwb2ludCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwMi5aRVJPLCB5OiBGcDIuWkVSTyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB4MSA9IHNsYyh2YWx1ZSwgMCwgTCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeDAgPSBzbGModmFsdWUsIEwsIDIgKiBMKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MSA9IHNsYyh2YWx1ZSwgMiAqIEwsIDMgKiBMKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MCA9IHNsYyh2YWx1ZSwgMyAqIEwsIDQgKiBMKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcDIuZnJvbUJpZ1R1cGxlKFt4MCwgeDFdKSwgeTogRnAyLmZyb21CaWdUdXBsZShbeTAsIHkxXSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwb2ludCBHMiwgZXhwZWN0ZWQgOTYvMTkyIGJ5dGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvQnl0ZXM6IChjLCBwb2ludCwgaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IEJZVEVTOiBsZW4sIE9SREVSOiBQIH0gPSBGcDtcbiAgICAgICAgICAgIGNvbnN0IGlzWmVybyA9IHBvaW50LmVxdWFscyhjLlpFUk8pO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1plcm8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXRCKENPTVBSRVNTRURfWkVSTywgbnVtYmVyVG9CeXRlc0JFKF8wbiwgbGVuKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmxhZyA9IEJvb2xlYW4oeS5jMSA9PT0gXzBuID8gKHkuYzAgKiBfMm4pIC8gUCA6ICh5LmMxICogXzJuKSAvIFApO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXRCKHNldE1hc2sobnVtYmVyVG9CeXRlc0JFKHguYzEsIGxlbiksIHsgY29tcHJlc3NlZDogdHJ1ZSwgc29ydDogZmxhZyB9KSwgbnVtYmVyVG9CeXRlc0JFKHguYzAsIGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzWmVybylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEIobmV3IFVpbnQ4QXJyYXkoWzB4NDBdKSwgbmV3IFVpbnQ4QXJyYXkoNCAqIGxlbiAtIDEpKTsgLy8gYnl0ZXNbMF0gfD0gMSA8PCA2O1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmU6IHgwLCBpbTogeDEgfSA9IEZwMi5yZWltKHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmU6IHkwLCBpbTogeTEgfSA9IEZwMi5yZWltKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXRCKG51bWJlclRvQnl0ZXNCRSh4MSwgbGVuKSwgbnVtYmVyVG9CeXRlc0JFKHgwLCBsZW4pLCBudW1iZXJUb0J5dGVzQkUoeTEsIGxlbiksIG51bWJlclRvQnl0ZXNCRSh5MCwgbGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFNpZ25hdHVyZToge1xuICAgICAgICAgICAgLy8gVE9ETzogT3B0aW1pemUsIGl0J3MgdmVyeSBzbG93IGJlY2F1c2Ugb2Ygc3FydC5cbiAgICAgICAgICAgIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmZpbml0eSwgc29ydCwgdmFsdWUgfSA9IHBhcnNlTWFzayhlbnN1cmVCeXRlcygnc2lnbmF0dXJlSGV4JywgaGV4KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbGYgPSB2YWx1ZS5sZW5ndGggLyAyO1xuICAgICAgICAgICAgICAgIGlmIChoYWxmICE9PSA0OCAmJiBoYWxmICE9PSA5NilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbXByZXNzZWQgc2lnbmF0dXJlIGxlbmd0aCwgbXVzdCBiZSA5NiBvciAxOTInKTtcbiAgICAgICAgICAgICAgICBjb25zdCB6MSA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZS5zbGljZSgwLCBoYWxmKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgejIgPSBieXRlc1RvTnVtYmVyQkUodmFsdWUuc2xpY2UoaGFsZikpO1xuICAgICAgICAgICAgICAgIC8vIEluZGljYXRlcyB0aGUgaW5maW5pdHkgcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAoaW5maW5pdHkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibHMxMl8zODEuRzIuUHJvamVjdGl2ZVBvaW50LlpFUk87XG4gICAgICAgICAgICAgICAgY29uc3QgeDEgPSBGcC5jcmVhdGUoejEgJiBGcC5NQVNLKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4MiA9IEZwLmNyZWF0ZSh6Mik7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwMi5jcmVhdGUoeyBjMDogeDIsIGMxOiB4MSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IEZwMi5hZGQoRnAyLnBvdyh4LCBfM24pLCBibHMxMl8zODEucGFyYW1zLkcyYik7IC8vIHnCsiA9IHjCsyArIDRcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2xvdyBwYXJ0XG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcDIuc3FydCh5Mik7XG4gICAgICAgICAgICAgICAgaWYgKCF5KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGEgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgICAgICAvLyBDaG9vc2UgdGhlIHkgd2hvc2UgbGVmdG1vc3QgYml0IG9mIHRoZSBpbWFnaW5hcnkgcGFydCBpcyBlcXVhbCB0byB0aGUgYV9mbGFnMVxuICAgICAgICAgICAgICAgIC8vIElmIHkxIGhhcHBlbnMgdG8gYmUgemVybywgdGhlbiB1c2UgdGhlIGJpdCBvZiB5MFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmU6IHkwLCBpbTogeTEgfSA9IEZwMi5yZWltKHkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmbGFnMSA9IEJpZ0ludChzb3J0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0dyZWF0ZXIgPSB5MSA+IF8wbiAmJiAoeTEgKiBfMm4pIC8gUCAhPT0gYWZsYWcxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzWmVybyA9IHkxID09PSBfMG4gJiYgKHkwICogXzJuKSAvIFAgIT09IGFmbGFnMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNHcmVhdGVyIHx8IGlzWmVybylcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwMi5uZWcoeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBibHMxMl8zODEuRzIuUHJvamVjdGl2ZVBvaW50LmZyb21BZmZpbmUoeyB4LCB5IH0pO1xuICAgICAgICAgICAgICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvUmF3Qnl0ZXMocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlRzJUb1Jhd0J5dGVzKHBvaW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0hleChwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHNpZ25hdHVyZUcyVG9SYXdCeXRlcyhwb2ludCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHBhcmFtczoge1xuICAgICAgICBhdGVMb29wU2l6ZTogQkxTX1gsIC8vIFRoZSBCTFMgcGFyYW1ldGVyIHggZm9yIEJMUzEyLTM4MVxuICAgICAgICByOiBGci5PUkRFUiwgLy8gb3JkZXI7IHrigbQg4oiSIHrCsiArIDE7IENVUlZFLm4gZnJvbSBvdGhlciBjdXJ2ZXNcbiAgICAgICAgeE5lZ2F0aXZlOiB0cnVlLFxuICAgICAgICB0d2lzdFR5cGU6ICdtdWx0aXBsaWNhdGl2ZScsXG4gICAgfSxcbiAgICBodGZEZWZhdWx0cyxcbiAgICBoYXNoOiBzaGEyNTYsXG4gICAgcmFuZG9tQnl0ZXMsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsczEyLTM4MS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/bls12-381.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/ed25519.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/ed25519.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: () => (/* binding */ ED25519_TORSION_SUBGROUP),\n/* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),\n/* harmony export */   ed25519: () => (/* binding */ ed25519),\n/* harmony export */   ed25519ctx: () => (/* binding */ ed25519ctx),\n/* harmony export */   ed25519ph: () => (/* binding */ ed25519ph),\n/* harmony export */   edwardsToMontgomery: () => (/* binding */ edwardsToMontgomery),\n/* harmony export */   edwardsToMontgomeryPriv: () => (/* binding */ edwardsToMontgomeryPriv),\n/* harmony export */   edwardsToMontgomeryPub: () => (/* binding */ edwardsToMontgomeryPub),\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   hashToRistretto255: () => (/* binding */ hashToRistretto255),\n/* harmony export */   hash_to_ristretto255: () => (/* binding */ hash_to_ristretto255),\n/* harmony export */   x25519: () => (/* binding */ x25519)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/edwards.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/utils.js */ \"./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\nconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ED25519_P;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x) % P; // x^31\n    const b10 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5) % P;\n    const b20 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10) % P;\n    const b40 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20) % P;\n    const b80 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40) % P;\n    const b160 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80) % P;\n    const b240 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80) % P;\n    const b250 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v³\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v⁷\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx²\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))\n        x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n// Just in case\nconst ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = /* @__PURE__ */ (() => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ED25519_P, undefined, true))();\nconst ed25519Defaults = /* @__PURE__ */ (() => ({\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: _8n,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/√v\n    uvRatio,\n}))();\n/**\n * ed25519 curve with EdDSA signatures.\n */\nconst ed25519 = /* @__PURE__ */ (() => (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.concatBytes)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nconst ed25519ctx = /* @__PURE__ */ (() => (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n}))();\nconst ed25519ph = /* @__PURE__ */ (() => (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)(Object.assign({}, ed25519Defaults, {\n    domain: ed25519_domain,\n    prehash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n})))();\nconst x25519 = /* @__PURE__ */ (() => (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n        const P = ED25519_P;\n        // x^(p-2) aka x^(2^255-21)\n        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n        return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n}))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nfunction edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nconst edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nfunction edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([xd, yd]); // batch division\n    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/√(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHex', hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32), hex) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))\n            s = mod(-s);\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32); // 11\n    }\n    toHex() {\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nconst RistrettoPoint = /* @__PURE__ */ (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nconst hashToRistretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)(d) : d;\n    const uniform_bytes = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nconst hash_to_ristretto255 = hashToRistretto255; // legacy\n//# sourceMappingURL=ed25519.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vZWQyNTUxOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzhDO0FBQzhCO0FBQ3JCO0FBQ3dCO0FBQ0k7QUFDN0I7QUFDdUQ7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGdCQUFnQiwwREFBSSx3QkFBd0I7QUFDNUMsZ0JBQWdCLDBEQUFJLHVCQUF1QjtBQUMzQyxpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsdUJBQXVCLDBEQUFJO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFHLGdCQUFnQjtBQUNsQyxlQUFlLHlEQUFHLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0EsWUFBWSx5REFBRyxtQkFBbUI7QUFDbEMsZ0JBQWdCLHlEQUFHLGdCQUFnQjtBQUNuQyxxQkFBcUI7QUFDckIsa0JBQWtCLHlEQUFHLDBCQUEwQjtBQUMvQyxnQ0FBZ0M7QUFDaEMsNkJBQTZCLHlEQUFHLFNBQVM7QUFDekMsMkJBQTJCLHlEQUFHLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUSxrRUFBWTtBQUNwQixZQUFZLHlEQUFHO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyREFBSztBQUN2QztBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QyxvRUFBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdFQUFXLENBQUMsZ0VBQVc7QUFDbEM7QUFDTywwQ0FBMEMsb0VBQWM7QUFDL0Q7QUFDQTtBQUNBLENBQUM7QUFDTSx5Q0FBeUMsb0VBQWMsaUJBQWlCO0FBQy9FO0FBQ0EsYUFBYSx3REFBTTtBQUNuQixDQUFDO0FBQ00sc0NBQXNDLG1FQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGVBQWUseURBQUcsQ0FBQywwREFBSTtBQUN2QixLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNPLG9EQUFvRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLGdFQUFnRTtBQUNoRSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLG9DQUFvQztBQUNwQyw0QkFBNEI7QUFDNUIsb0NBQW9DO0FBQ3BDLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLG9DQUFvQztBQUNwQyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLG9DQUFvQztBQUNwQyxzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEMsaUNBQWlDO0FBQ2pDLDBCQUEwQjtBQUMxQiwwQ0FBMEM7QUFDMUMsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQSwrQ0FBK0MsZ0VBQVUsaUNBQWlDO0FBQzFGO0FBQ0EsWUFBWSxxQkFBcUIseUNBQXlDO0FBQzFFO0FBQ0EsK0JBQStCO0FBQy9CLHNDQUFzQztBQUN0QywrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQywwQ0FBMEM7QUFDMUMsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQSxtQ0FBbUMsd0VBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixDQUFDO0FBQ007QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsbUVBQWU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsZ0RBQWdEO0FBQ2hELHdCQUF3QjtBQUN4Qiw2Q0FBNkM7QUFDN0MsVUFBVSxnQ0FBZ0Msa0JBQWtCO0FBQzVELDBCQUEwQjtBQUMxQixTQUFTLGtFQUFZO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxlQUFlO0FBQ2Ysd0RBQXdEO0FBQ3hEO0FBQ0EsaUNBQWlDO0FBQ2pDLDRDQUE0QztBQUM1Qyw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQVc7QUFDekIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4REFBVSxDQUFDLG1FQUFlLGlCQUFpQixrRUFBWTtBQUNwRTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGdCQUFnQixvQkFBb0IsNkJBQTZCO0FBQ2pFLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsbUNBQW1DO0FBQ25DLFlBQVksa0VBQVk7QUFDeEIseUJBQXlCO0FBQ3pCLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsd0JBQXdCLGtFQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQiw4QkFBOEI7QUFDL0Qsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMsZUFBZTtBQUNmLFlBQVksa0VBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxZQUFZLGtFQUFZO0FBQ3hCLHlCQUF5QjtBQUN6QixrQ0FBa0M7QUFDbEMsWUFBWSxrRUFBWTtBQUN4QjtBQUNBLGVBQWUsbUVBQWUsU0FBUztBQUN2QztBQUNBO0FBQ0EsZUFBZSw4REFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ0Esd0NBQXdDLGdFQUFXO0FBQ25ELDBCQUEwQiw4RUFBa0IsZUFBZSx3REFBTTtBQUNqRTtBQUNBO0FBQ0E7QUFDTyxpREFBaUQ7QUFDeEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjYuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vZWQyNTUxOS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGE1MTIgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTUxMic7XG5pbXBvcnQgeyBjb25jYXRCeXRlcywgcmFuZG9tQnl0ZXMsIHV0ZjhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB0d2lzdGVkRWR3YXJkcyB9IGZyb20gJy4vYWJzdHJhY3QvZWR3YXJkcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGV4cGFuZF9tZXNzYWdlX3htZCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgRnBTcXJ0RXZlbiwgaXNOZWdhdGl2ZUxFLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbW9udGdvbWVyeSB9IGZyb20gJy4vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyc7XG5pbXBvcnQgeyBieXRlc1RvSGV4LCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBlcXVhbEJ5dGVzLCBudW1iZXJUb0J5dGVzTEUsIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG4vKipcbiAqIGVkMjU1MTkgVHdpc3RlZCBFZHdhcmRzIGN1cnZlIHdpdGggZm9sbG93aW5nIGFkZG9uczpcbiAqIC0gWDI1NTE5IEVDREhcbiAqIC0gUmlzdHJldHRvIGNvZmFjdG9yIGVsaW1pbmF0aW9uXG4gKiAtIEVsbGlnYXRvciBoYXNoLXRvLWdyb3VwIC8gcG9pbnQgaW5kaXN0aW5ndWlzaGFiaWxpdHlcbiAqL1xuY29uc3QgRUQyNTUxOV9QID0gQmlnSW50KCc1Nzg5NjA0NDYxODY1ODA5NzcxMTc4NTQ5MjUwNDM0Mzk1MzkyNjYzNDk5MjMzMjgyMDI4MjAxOTcyODc5MjAwMzk1NjU2NDgxOTk0OScpO1xuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuY29uc3QgRUQyNTUxOV9TUVJUX00xID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTInKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbmZ1bmN0aW9uIGVkMjU1MTlfcG93XzJfMjUyXzMoeCkge1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8xMG4gPSBCaWdJbnQoMTApLCBfMjBuID0gQmlnSW50KDIwKSwgXzQwbiA9IEJpZ0ludCg0MCksIF84MG4gPSBCaWdJbnQoODApO1xuICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG4gICAgY29uc3QgeDIgPSAoeCAqIHgpICUgUDtcbiAgICBjb25zdCBiMiA9ICh4MiAqIHgpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGI0ID0gKHBvdzIoYjIsIF8ybiwgUCkgKiBiMikgJSBQOyAvLyB4XjE1LCAxMTExXG4gICAgY29uc3QgYjUgPSAocG93MihiNCwgXzFuLCBQKSAqIHgpICUgUDsgLy8geF4zMVxuICAgIGNvbnN0IGIxMCA9IChwb3cyKGI1LCBfNW4sIFApICogYjUpICUgUDtcbiAgICBjb25zdCBiMjAgPSAocG93MihiMTAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgYjQwID0gKHBvdzIoYjIwLCBfMjBuLCBQKSAqIGIyMCkgJSBQO1xuICAgIGNvbnN0IGI4MCA9IChwb3cyKGI0MCwgXzQwbiwgUCkgKiBiNDApICUgUDtcbiAgICBjb25zdCBiMTYwID0gKHBvdzIoYjgwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNDAgPSAocG93MihiMTYwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNTAgPSAocG93MihiMjQwLCBfMTBuLCBQKSAqIGIxMCkgJSBQO1xuICAgIGNvbnN0IHBvd19wXzVfOCA9IChwb3cyKGIyNTAsIF8ybiwgUCkgKiB4KSAlIFA7XG4gICAgLy8gXiBUbyBwb3cgdG8gKHArMykvOCwgbXVsdGlwbHkgaXQgYnkgeC5cbiAgICByZXR1cm4geyBwb3dfcF81XzgsIGIyIH07XG59XG5mdW5jdGlvbiBhZGp1c3RTY2FsYXJCeXRlcyhieXRlcykge1xuICAgIC8vIFNlY3Rpb24gNTogRm9yIFgyNTUxOSwgaW4gb3JkZXIgdG8gZGVjb2RlIDMyIHJhbmRvbSBieXRlcyBhcyBhbiBpbnRlZ2VyIHNjYWxhcixcbiAgICAvLyBzZXQgdGhlIHRocmVlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgICBieXRlc1swXSAmPSAyNDg7IC8vIDBiMTExMV8xMDAwXG4gICAgLy8gYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCB0byB6ZXJvLFxuICAgIGJ5dGVzWzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gICAgLy8gc2V0IHRoZSBzZWNvbmQgbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGxhc3QgYnl0ZSB0byAxXG4gICAgYnl0ZXNbMzFdIHw9IDY0OyAvLyAwYjAxMDBfMDAwMFxuICAgIHJldHVybiBieXRlcztcbn1cbi8vIHNxcnQodS92KVxuZnVuY3Rpb24gdXZSYXRpbyh1LCB2KSB7XG4gICAgY29uc3QgUCA9IEVEMjU1MTlfUDtcbiAgICBjb25zdCB2MyA9IG1vZCh2ICogdiAqIHYsIFApOyAvLyB2wrNcbiAgICBjb25zdCB2NyA9IG1vZCh2MyAqIHYzICogdiwgUCk7IC8vIHbigbdcbiAgICAvLyAocCszKS84IGFuZCAocC01KS84XG4gICAgY29uc3QgcG93ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh1ICogdjcpLnBvd19wXzVfODtcbiAgICBsZXQgeCA9IG1vZCh1ICogdjMgKiBwb3csIFApOyAvLyAodXbCsykodXbigbcpXihwLTUpLzhcbiAgICBjb25zdCB2eDIgPSBtb2QodiAqIHggKiB4LCBQKTsgLy8gdnjCslxuICAgIGNvbnN0IHJvb3QxID0geDsgLy8gRmlyc3Qgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCByb290MiA9IG1vZCh4ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gU2Vjb25kIHJvb3QgY2FuZGlkYXRlXG4gICAgY29uc3QgdXNlUm9vdDEgPSB2eDIgPT09IHU7IC8vIElmIHZ4wrIgPSB1IChtb2QgcCksIHggaXMgYSBzcXVhcmUgcm9vdFxuICAgIGNvbnN0IHVzZVJvb3QyID0gdngyID09PSBtb2QoLXUsIFApOyAvLyBJZiB2eMKyID0gLXUsIHNldCB4IDwtLSB4ICogMl4oKHAtMSkvNClcbiAgICBjb25zdCBub1Jvb3QgPSB2eDIgPT09IG1vZCgtdSAqIEVEMjU1MTlfU1FSVF9NMSwgUCk7IC8vIFRoZXJlIGlzIG5vIHZhbGlkIHJvb3QsIHZ4wrIgPSAtdeKImigtMSlcbiAgICBpZiAodXNlUm9vdDEpXG4gICAgICAgIHggPSByb290MTtcbiAgICBpZiAodXNlUm9vdDIgfHwgbm9Sb290KVxuICAgICAgICB4ID0gcm9vdDI7IC8vIFdlIHJldHVybiByb290MiBhbnl3YXksIGZvciBjb25zdC10aW1lXG4gICAgaWYgKGlzTmVnYXRpdmVMRSh4LCBQKSlcbiAgICAgICAgeCA9IG1vZCgteCwgUCk7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdXNlUm9vdDEgfHwgdXNlUm9vdDIsIHZhbHVlOiB4IH07XG59XG4vLyBKdXN0IGluIGNhc2VcbmV4cG9ydCBjb25zdCBFRDI1NTE5X1RPUlNJT05fU1VCR1JPVVAgPSBbXG4gICAgJzAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdjNzE3NmE3MDNkNGRkODRmYmEzYzBiNzYwZDEwNjcwZjJhMjA1M2ZhMmMzOWNjYzY0ZWM3ZmQ3NzkyYWMwMzdhJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MCcsXG4gICAgJzI2ZTg5NThmYzJiMjI3YjA0NWMzZjQ4OWYyZWY5OGYwZDVkZmFjMDVkM2M2MzMzOWIxMzgwMjg4NmQ1M2ZjMDUnLFxuICAgICdlY2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjdmJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmM4NScsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdjNzE3NmE3MDNkNGRkODRmYmEzYzBiNzYwZDEwNjcwZjJhMjA1M2ZhMmMzOWNjYzY0ZWM3ZmQ3NzkyYWMwM2ZhJyxcbl07XG5jb25zdCBGcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRmllbGQoRUQyNTUxOV9QLCB1bmRlZmluZWQsIHRydWUpKSgpO1xuY29uc3QgZWQyNTUxOURlZmF1bHRzID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoe1xuICAgIC8vIFBhcmFtOiBhXG4gICAgYTogQmlnSW50KC0xKSwgLy8gRnAuY3JlYXRlKC0xKSBpcyBwcm9wZXI7IG91ciB3YXkgc3RpbGwgd29ya3MgYW5kIGlzIGZhc3RlclxuICAgIC8vIGQgaXMgZXF1YWwgdG8gLTEyMTY2NS8xMjE2NjYgb3ZlciBmaW5pdGUgZmllbGQuXG4gICAgLy8gTmVnYXRpdmUgbnVtYmVyIGlzIFAgLSBudW1iZXIsIGFuZCBkaXZpc2lvbiBpcyBpbnZlcnQobnVtYmVyLCBQKVxuICAgIGQ6IEJpZ0ludCgnMzcwOTU3MDU5MzQ2Njk0MzkzNDMxMzgwODM1MDg3NTQ1NjUxODk1NDIxMTM4Nzk4NDMyMTkwMTYzODg3ODU1MzMwODU5NDAyODM1NTUnKSxcbiAgICAvLyBGaW5pdGUgZmllbGQg8J2UvXAgb3ZlciB3aGljaCB3ZSdsbCBkbyBjYWxjdWxhdGlvbnM7IDJuKioyNTVuIC0gMTluXG4gICAgRnAsXG4gICAgLy8gU3ViZ3JvdXAgb3JkZXI6IGhvdyBtYW55IHBvaW50cyBjdXJ2ZSBoYXNcbiAgICAvLyAybioqMjUybiArIDI3NzQyMzE3Nzc3MzcyMzUzNTM1ODUxOTM3NzkwODgzNjQ4NDkzbjtcbiAgICBuOiBCaWdJbnQoJzcyMzcwMDU1NzczMzIyNjIyMTM5NzMxODY1NjMwNDI5OTQyNDA4NTcxMTYzNTkzNzk5MDc2MDYwMDE5NTA5MzgyODU0NTQyNTA5ODknKSxcbiAgICAvLyBDb2ZhY3RvclxuICAgIGg6IF84bixcbiAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XG4gICAgR3g6IEJpZ0ludCgnMTUxMTIyMjEzNDk1MzU0MDA3NzI1MDExNTE0MDk1ODg1MzE1MTE0NTQwMTI2OTMwNDE4NTcyMDYwNDYxMTMyODM5NDk4NDc3NjIyMDInKSxcbiAgICBHeTogQmlnSW50KCc0NjMxNjgzNTY5NDkyNjQ3ODE2OTQyODM5NDAwMzQ3NTE2MzE0MTMwNzk5Mzg2NjI1NjIyNTYxNTc4MzAzMzYwMzE2NTI1MTg1NTk2MCcpLFxuICAgIGhhc2g6IHNoYTUxMixcbiAgICByYW5kb21CeXRlcyxcbiAgICBhZGp1c3RTY2FsYXJCeXRlcyxcbiAgICAvLyBkb20yXG4gICAgLy8gUmF0aW8gb2YgdSB0byB2LiBBbGxvd3MgdXMgdG8gY29tYmluZSBpbnZlcnNpb24gYW5kIHNxdWFyZSByb290LiBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgIC8vIENvbnN0YW50LXRpbWUsIHUv4oiadlxuICAgIHV2UmF0aW8sXG59KSkoKTtcbi8qKlxuICogZWQyNTUxOSBjdXJ2ZSB3aXRoIEVkRFNBIHNpZ25hdHVyZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBlZDI1NTE5ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0d2lzdGVkRWR3YXJkcyhlZDI1NTE5RGVmYXVsdHMpKSgpO1xuZnVuY3Rpb24gZWQyNTUxOV9kb21haW4oZGF0YSwgY3R4LCBwaGZsYWcpIHtcbiAgICBpZiAoY3R4Lmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IGlzIHRvbyBiaWcnKTtcbiAgICByZXR1cm4gY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ1NpZ0VkMjU1MTkgbm8gRWQyNTUxOSBjb2xsaXNpb25zJyksIG5ldyBVaW50OEFycmF5KFtwaGZsYWcgPyAxIDogMCwgY3R4Lmxlbmd0aF0pLCBjdHgsIGRhdGEpO1xufVxuZXhwb3J0IGNvbnN0IGVkMjU1MTljdHggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHR3aXN0ZWRFZHdhcmRzKHtcbiAgICAuLi5lZDI1NTE5RGVmYXVsdHMsXG4gICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlwaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoT2JqZWN0LmFzc2lnbih7fSwgZWQyNTUxOURlZmF1bHRzLCB7XG4gICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbiAgICBwcmVoYXNoOiBzaGE1MTIsXG59KSkpKCk7XG5leHBvcnQgY29uc3QgeDI1NTE5ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtb250Z29tZXJ5KHtcbiAgICBQOiBFRDI1NTE5X1AsXG4gICAgYTogQmlnSW50KDQ4NjY2MiksXG4gICAgbW9udGdvbWVyeUJpdHM6IDI1NSwgLy8gbiBpcyAyNTMgYml0c1xuICAgIG5CeXRlTGVuZ3RoOiAzMixcbiAgICBHdTogQmlnSW50KDkpLFxuICAgIHBvd1BtaW51czI6ICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG4gICAgICAgIC8vIHheKHAtMikgYWthIHheKDJeMjU1LTIxKVxuICAgICAgICBjb25zdCB7IHBvd19wXzVfOCwgYjIgfSA9IGVkMjU1MTlfcG93XzJfMjUyXzMoeCk7XG4gICAgICAgIHJldHVybiBtb2QocG93Mihwb3dfcF81XzgsIF8zbiwgUCkgKiBiMiwgUCk7XG4gICAgfSxcbiAgICBhZGp1c3RTY2FsYXJCeXRlcyxcbiAgICByYW5kb21CeXRlcyxcbn0pKSgpO1xuLyoqXG4gKiBDb252ZXJ0cyBlZDI1NTE5IHB1YmxpYyBrZXkgdG8geDI1NTE5IHB1YmxpYyBrZXkuIFVzZXMgZm9ybXVsYTpcbiAqICogYCh1LCB2KSA9ICgoMSt5KS8oMS15KSwgc3FydCgtNDg2NjY0KSp1L3gpYFxuICogKiBgKHgsIHkpID0gKHNxcnQoLTQ4NjY2NCkqdS92LCAodS0xKS8odSsxKSlgXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBzb21lb25lc1B1YiA9IGVkMjU1MTkuZ2V0UHVibGljS2V5KGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKTtcbiAqICAgY29uc3QgYVByaXYgPSB4MjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogICB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KGFQcml2LCBlZHdhcmRzVG9Nb250Z29tZXJ5UHViKHNvbWVvbmVzUHViKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHNUb01vbnRnb21lcnlQdWIoZWR3YXJkc1B1Yikge1xuICAgIGNvbnN0IHsgeSB9ID0gZWQyNTUxOS5FeHRlbmRlZFBvaW50LmZyb21IZXgoZWR3YXJkc1B1Yik7XG4gICAgY29uc3QgXzFuID0gQmlnSW50KDEpO1xuICAgIHJldHVybiBGcC50b0J5dGVzKEZwLmNyZWF0ZSgoXzFuICsgeSkgKiBGcC5pbnYoXzFuIC0geSkpKTtcbn1cbmV4cG9ydCBjb25zdCBlZHdhcmRzVG9Nb250Z29tZXJ5ID0gZWR3YXJkc1RvTW9udGdvbWVyeVB1YjsgLy8gZGVwcmVjYXRlZFxuLyoqXG4gKiBDb252ZXJ0cyBlZDI1NTE5IHNlY3JldCBrZXkgdG8geDI1NTE5IHNlY3JldCBrZXkuXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBzb21lb25lc1B1YiA9IHgyNTUxOS5nZXRQdWJsaWNLZXkoeDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSk7XG4gKiAgIGNvbnN0IGFQcml2ID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gKiAgIHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQoZWR3YXJkc1RvTW9udGdvbWVyeVByaXYoYVByaXYpLCBzb21lb25lc1B1YilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHNUb01vbnRnb21lcnlQcml2KGVkd2FyZHNQcml2KSB7XG4gICAgY29uc3QgaGFzaGVkID0gZWQyNTUxOURlZmF1bHRzLmhhc2goZWR3YXJkc1ByaXYuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICByZXR1cm4gZWQyNTUxOURlZmF1bHRzLmFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZCkuc3ViYXJyYXkoMCwgMzIpO1xufVxuLy8gSGFzaCBUbyBDdXJ2ZSBFbGxpZ2F0b3IyIE1hcCAoTk9URTogZGlmZmVyZW50IGZyb20gcmlzdHJldHRvMjU1IGVsbGlnYXRvcilcbi8vIE5PVEU6IHZlcnkgaW1wb3J0YW50IHBhcnQgaXMgdXNhZ2Ugb2YgRnBTcXJ0RXZlbiBmb3IgRUxMMl9DMV9FRFdBUkRTLCBzaW5jZVxuLy8gU2FnZU1hdGggcmV0dXJucyBkaWZmZXJlbnQgcm9vdCBmaXJzdCBhbmQgZXZlcnl0aGluZyBmYWxscyBhcGFydFxuY29uc3QgRUxMMl9DMSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKEZwLk9SREVSICsgXzNuKSAvIF84bikoKTsgLy8gMS4gYzEgPSAocSArIDMpIC8gOCAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuY29uc3QgRUxMMl9DMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRnAucG93KF8ybiwgRUxMMl9DMSkpKCk7IC8vIDIuIGMyID0gMl5jMVxuY29uc3QgRUxMMl9DMyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRnAuc3FydChGcC5uZWcoRnAuT05FKSkpKCk7IC8vIDMuIGMzID0gc3FydCgtMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuZnVuY3Rpb24gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KSB7XG4gICAgY29uc3QgRUxMMl9DNCA9IChGcC5PUkRFUiAtIF81bikgLyBfOG47IC8vIDQuIGM0ID0gKHEgLSA1KSAvIDggICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBFTEwyX0ogPSBCaWdJbnQoNDg2NjYyKTtcbiAgICBsZXQgdHYxID0gRnAuc3FyKHUpOyAvLyAgMS4gIHR2MSA9IHVeMlxuICAgIHR2MSA9IEZwLm11bCh0djEsIF8ybik7IC8vICAyLiAgdHYxID0gMiAqIHR2MVxuICAgIGxldCB4ZCA9IEZwLmFkZCh0djEsIEZwLk9ORSk7IC8vICAzLiAgIHhkID0gdHYxICsgMSAgICAgICAgICMgTm9uemVybzogLTEgaXMgc3F1YXJlIChtb2QgcCksIHR2MSBpcyBub3RcbiAgICBsZXQgeDFuID0gRnAubmVnKEVMTDJfSik7IC8vICA0LiAgeDFuID0gLUogICAgICAgICAgICAgICMgeDEgPSB4MW4gLyB4ZCA9IC1KIC8gKDEgKyAyICogdV4yKVxuICAgIGxldCB0djIgPSBGcC5zcXIoeGQpOyAvLyAgNS4gIHR2MiA9IHhkXjJcbiAgICBsZXQgZ3hkID0gRnAubXVsKHR2MiwgeGQpOyAvLyAgNi4gIGd4ZCA9IHR2MiAqIHhkICAgICAgICAjIGd4ZCA9IHhkXjNcbiAgICBsZXQgZ3gxID0gRnAubXVsKHR2MSwgRUxMMl9KKTsgLy8gIDcuICBneDEgPSBKICogdHYxICAgICAgICAgIyB4MW4gKyBKICogeGRcbiAgICBneDEgPSBGcC5tdWwoZ3gxLCB4MW4pOyAvLyAgOC4gIGd4MSA9IGd4MSAqIHgxbiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkXG4gICAgZ3gxID0gRnAuYWRkKGd4MSwgdHYyKTsgLy8gIDkuICBneDEgPSBneDEgKyB0djIgICAgICAgIyB4MW5eMiArIEogKiB4MW4gKiB4ZCArIHhkXjJcbiAgICBneDEgPSBGcC5tdWwoZ3gxLCB4MW4pOyAvLyAgMTAuIGd4MSA9IGd4MSAqIHgxbiAgICAgICAjIHgxbl4zICsgSiAqIHgxbl4yICogeGQgKyB4MW4gKiB4ZF4yXG4gICAgbGV0IHR2MyA9IEZwLnNxcihneGQpOyAvLyAgMTEuIHR2MyA9IGd4ZF4yXG4gICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vICAxMi4gdHYyID0gdHYzXjIgICAgICAgICAgICMgZ3hkXjRcbiAgICB0djMgPSBGcC5tdWwodHYzLCBneGQpOyAvLyAgMTMuIHR2MyA9IHR2MyAqIGd4ZCAgICAgICAjIGd4ZF4zXG4gICAgdHYzID0gRnAubXVsKHR2MywgZ3gxKTsgLy8gIDE0LiB0djMgPSB0djMgKiBneDEgICAgICAgIyBneDEgKiBneGReM1xuICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vICAxNS4gdHYyID0gdHYyICogdHYzICAgICAgICMgZ3gxICogZ3hkXjdcbiAgICBsZXQgeTExID0gRnAucG93KHR2MiwgRUxMMl9DNCk7IC8vICAxNi4geTExID0gdHYyXmM0ICAgICAgICAjIChneDEgKiBneGReNyleKChwIC0gNSkgLyA4KVxuICAgIHkxMSA9IEZwLm11bCh5MTEsIHR2Myk7IC8vICAxNy4geTExID0geTExICogdHYzICAgICAgICMgZ3gxKmd4ZF4zKihneDEqZ3hkXjcpXigocC01KS84KVxuICAgIGxldCB5MTIgPSBGcC5tdWwoeTExLCBFTEwyX0MzKTsgLy8gIDE4LiB5MTIgPSB5MTEgKiBjM1xuICAgIHR2MiA9IEZwLnNxcih5MTEpOyAvLyAgMTkuIHR2MiA9IHkxMV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDIwLiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTEgPSBGcC5lcWwodHYyLCBneDEpOyAvLyAgMjEuICBlMSA9IHR2MiA9PSBneDFcbiAgICBsZXQgeTEgPSBGcC5jbW92KHkxMiwgeTExLCBlMSk7IC8vICAyMi4gIHkxID0gQ01PVih5MTIsIHkxMSwgZTEpICAjIElmIGcoeDEpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICAgIGxldCB4Mm4gPSBGcC5tdWwoeDFuLCB0djEpOyAvLyAgMjMuIHgybiA9IHgxbiAqIHR2MSAgICAgICAjIHgyID0geDJuIC8geGQgPSAyICogdV4yICogeDFuIC8geGRcbiAgICBsZXQgeTIxID0gRnAubXVsKHkxMSwgdSk7IC8vICAyNC4geTIxID0geTExICogdVxuICAgIHkyMSA9IEZwLm11bCh5MjEsIEVMTDJfQzIpOyAvLyAgMjUuIHkyMSA9IHkyMSAqIGMyXG4gICAgbGV0IHkyMiA9IEZwLm11bCh5MjEsIEVMTDJfQzMpOyAvLyAgMjYuIHkyMiA9IHkyMSAqIGMzXG4gICAgbGV0IGd4MiA9IEZwLm11bChneDEsIHR2MSk7IC8vICAyNy4gZ3gyID0gZ3gxICogdHYxICAgICAgICMgZyh4MikgPSBneDIgLyBneGQgPSAyICogdV4yICogZyh4MSlcbiAgICB0djIgPSBGcC5zcXIoeTIxKTsgLy8gIDI4LiB0djIgPSB5MjFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAyOS4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUyID0gRnAuZXFsKHR2MiwgZ3gyKTsgLy8gIDMwLiAgZTIgPSB0djIgPT0gZ3gyXG4gICAgbGV0IHkyID0gRnAuY21vdih5MjIsIHkyMSwgZTIpOyAvLyAgMzEuICB5MiA9IENNT1YoeTIyLCB5MjEsIGUyKSAgIyBJZiBnKHgyKSBpcyBzcXVhcmUsIHRoaXMgaXMgaXRzIHNxcnRcbiAgICB0djIgPSBGcC5zcXIoeTEpOyAvLyAgMzIuIHR2MiA9IHkxXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMzMuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMyA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAzNC4gIGUzID0gdHYyID09IGd4MVxuICAgIGxldCB4biA9IEZwLmNtb3YoeDJuLCB4MW4sIGUzKTsgLy8gIDM1LiAgeG4gPSBDTU9WKHgybiwgeDFuLCBlMykgICMgSWYgZTMsIHggPSB4MSwgZWxzZSB4ID0geDJcbiAgICBsZXQgeSA9IEZwLmNtb3YoeTIsIHkxLCBlMyk7IC8vICAzNi4gICB5ID0gQ01PVih5MiwgeTEsIGUzKSAgICAjIElmIGUzLCB5ID0geTEsIGVsc2UgeSA9IHkyXG4gICAgbGV0IGU0ID0gRnAuaXNPZGQoeSk7IC8vICAzNy4gIGU0ID0gc2duMCh5KSA9PSAxICAgICAgICAjIEZpeCBzaWduIG9mIHlcbiAgICB5ID0gRnAuY21vdih5LCBGcC5uZWcoeSksIGUzICE9PSBlNCk7IC8vICAzOC4gICB5ID0gQ01PVih5LCAteSwgZTMgWE9SIGU0KVxuICAgIHJldHVybiB7IHhNbjogeG4sIHhNZDogeGQsIHlNbjogeSwgeU1kOiBfMW4gfTsgLy8gIDM5LiByZXR1cm4gKHhuLCB4ZCwgeSwgMSlcbn1cbmNvbnN0IEVMTDJfQzFfRURXQVJEUyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRnBTcXJ0RXZlbihGcCwgRnAubmVnKEJpZ0ludCg0ODY2NjQpKSkpKCk7IC8vIHNnbjAoYzEpIE1VU1QgZXF1YWwgMFxuZnVuY3Rpb24gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfZWR3YXJkczI1NTE5KHUpIHtcbiAgICBjb25zdCB7IHhNbiwgeE1kLCB5TW4sIHlNZCB9ID0gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KTsgLy8gIDEuICAoeE1uLCB4TWQsIHlNbiwgeU1kKSA9XG4gICAgLy8gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KVxuICAgIGxldCB4biA9IEZwLm11bCh4TW4sIHlNZCk7IC8vICAyLiAgeG4gPSB4TW4gKiB5TWRcbiAgICB4biA9IEZwLm11bCh4biwgRUxMMl9DMV9FRFdBUkRTKTsgLy8gIDMuICB4biA9IHhuICogYzFcbiAgICBsZXQgeGQgPSBGcC5tdWwoeE1kLCB5TW4pOyAvLyAgNC4gIHhkID0geE1kICogeU1uICAgICMgeG4gLyB4ZCA9IGMxICogeE0gLyB5TVxuICAgIGxldCB5biA9IEZwLnN1Yih4TW4sIHhNZCk7IC8vICA1LiAgeW4gPSB4TW4gLSB4TWRcbiAgICBsZXQgeWQgPSBGcC5hZGQoeE1uLCB4TWQpOyAvLyAgNi4gIHlkID0geE1uICsgeE1kICAgICMgKG4gLyBkIC0gMSkgLyAobiAvIGQgKyAxKSA9IChuIC0gZCkgLyAobiArIGQpXG4gICAgbGV0IHR2MSA9IEZwLm11bCh4ZCwgeWQpOyAvLyAgNy4gdHYxID0geGQgKiB5ZFxuICAgIGxldCBlID0gRnAuZXFsKHR2MSwgRnAuWkVSTyk7IC8vICA4LiAgIGUgPSB0djEgPT0gMFxuICAgIHhuID0gRnAuY21vdih4biwgRnAuWkVSTywgZSk7IC8vICA5LiAgeG4gPSBDTU9WKHhuLCAwLCBlKVxuICAgIHhkID0gRnAuY21vdih4ZCwgRnAuT05FLCBlKTsgLy8gIDEwLiB4ZCA9IENNT1YoeGQsIDEsIGUpXG4gICAgeW4gPSBGcC5jbW92KHluLCBGcC5PTkUsIGUpOyAvLyAgMTEuIHluID0gQ01PVih5biwgMSwgZSlcbiAgICB5ZCA9IEZwLmNtb3YoeWQsIEZwLk9ORSwgZSk7IC8vICAxMi4geWQgPSBDTU9WKHlkLCAxLCBlKVxuICAgIGNvbnN0IGludiA9IEZwLmludmVydEJhdGNoKFt4ZCwgeWRdKTsgLy8gYmF0Y2ggZGl2aXNpb25cbiAgICByZXR1cm4geyB4OiBGcC5tdWwoeG4sIGludlswXSksIHk6IEZwLm11bCh5biwgaW52WzFdKSB9OyAvLyAgMTMuIHJldHVybiAoeG4sIHhkLCB5biwgeWQpXG59XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihlZDI1NTE5LkV4dGVuZGVkUG9pbnQsIChzY2FsYXJzKSA9PiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdlZHdhcmRzMjU1MTlfWE1EOlNIQS01MTJfRUxMMl9ST18nLFxuICAgIGVuY29kZURTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGE1MTIsXG59KSkoKTtcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuZnVuY3Rpb24gYXNzZXJ0UnN0UG9pbnQob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJpc3RQb2ludCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmlzdHJldHRvUG9pbnQgZXhwZWN0ZWQnKTtcbn1cbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IFNRUlRfTTEgPSBFRDI1NTE5X1NRUlRfTTE7XG4vLyDiiJooYWQgLSAxKVxuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcyNTA2MzA2ODk1MzM4NDYyMzQ3NDExMTQxNDE1ODcwMjE1MjcwMTI0NDUzMTUwMjQ5MjY1NjQ2MDA3OTIxMDQ4MjYxMDQzMDc1MDIzNScpO1xuLy8gMSAvIOKImihhLWQpXG5jb25zdCBJTlZTUVJUX0FfTUlOVVNfRCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzU0NDY5MzA3MDA4OTA5MzE2OTIwOTk1ODEzODY4NzQ1MTQxNjA1MzkzNTk3MjkyOTI3NDU2OTIxMjA1MzEyODk2MzExNzIxMDE3NTc4Jyk7XG4vLyAxLWTCslxuY29uc3QgT05FX01JTlVTX0RfU1EgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxMTU5ODQzMDIxNjY4Nzc5ODc5MTkzNzc1NTIxODU1NTg2NjQ3OTM3MzU3NzU5NzE1NDE3NjU0NDM5ODc5NzIwODc2MTExODA2ODM4Jyk7XG4vLyAoZC0xKcKyXG5jb25zdCBEX01JTlVTX09ORV9TUSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzQwNDQwODM0MzQ2MzA4NTM2ODU4MTAxMDQyNDY5MzIzMTkwODI2MjQ4Mzk5MTQ2MjM4NzA4MzUyMjQwMTMzMjIwODY1MTM3MjY1OTUyJyk7XG4vLyBDYWxjdWxhdGVzIDEv4oiaKG51bWJlcilcbmNvbnN0IGludmVydFNxcnQgPSAobnVtYmVyKSA9PiB1dlJhdGlvKF8xbiwgbnVtYmVyKTtcbmNvbnN0IE1BWF8yNTVCID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG5jb25zdCBieXRlczI1NVRvTnVtYmVyTEUgPSAoYnl0ZXMpID0+IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlKGJ5dGVzVG9OdW1iZXJMRShieXRlcykgJiBNQVhfMjU1Qik7XG4vLyBDb21wdXRlcyBFbGxpZ2F0b3IgbWFwIGZvciBSaXN0cmV0dG9cbi8vIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sXG5mdW5jdGlvbiBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIwKSB7XG4gICAgY29uc3QgeyBkIH0gPSBlZDI1NTE5LkNVUlZFO1xuICAgIGNvbnN0IFAgPSBlZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgIGNvbnN0IHIgPSBtb2QoU1FSVF9NMSAqIHIwICogcjApOyAvLyAxXG4gICAgY29uc3QgTnMgPSBtb2QoKHIgKyBfMW4pICogT05FX01JTlVTX0RfU1EpOyAvLyAyXG4gICAgbGV0IGMgPSBCaWdJbnQoLTEpOyAvLyAzXG4gICAgY29uc3QgRCA9IG1vZCgoYyAtIGQgKiByKSAqIG1vZChyICsgZCkpOyAvLyA0XG4gICAgbGV0IHsgaXNWYWxpZDogTnNfRF9pc19zcSwgdmFsdWU6IHMgfSA9IHV2UmF0aW8oTnMsIEQpOyAvLyA1XG4gICAgbGV0IHNfID0gbW9kKHMgKiByMCk7IC8vIDZcbiAgICBpZiAoIWlzTmVnYXRpdmVMRShzXywgUCkpXG4gICAgICAgIHNfID0gbW9kKC1zXyk7XG4gICAgaWYgKCFOc19EX2lzX3NxKVxuICAgICAgICBzID0gc187IC8vIDdcbiAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgIGMgPSByOyAvLyA4XG4gICAgY29uc3QgTnQgPSBtb2QoYyAqIChyIC0gXzFuKSAqIERfTUlOVVNfT05FX1NRIC0gRCk7IC8vIDlcbiAgICBjb25zdCBzMiA9IHMgKiBzO1xuICAgIGNvbnN0IFcwID0gbW9kKChzICsgcykgKiBEKTsgLy8gMTBcbiAgICBjb25zdCBXMSA9IG1vZChOdCAqIFNRUlRfQURfTUlOVVNfT05FKTsgLy8gMTFcbiAgICBjb25zdCBXMiA9IG1vZChfMW4gLSBzMik7IC8vIDEyXG4gICAgY29uc3QgVzMgPSBtb2QoXzFuICsgczIpOyAvLyAxM1xuICAgIHJldHVybiBuZXcgZWQyNTUxOS5FeHRlbmRlZFBvaW50KG1vZChXMCAqIFczKSwgbW9kKFcyICogVzEpLCBtb2QoVzEgKiBXMyksIG1vZChXMCAqIFcyKSk7XG59XG4vKipcbiAqIEVhY2ggZWQyNTUxOS9FeHRlbmRlZFBvaW50IGhhcyA4IGRpZmZlcmVudCBlcXVpdmFsZW50IHBvaW50cy4gVGhpcyBjYW4gYmVcbiAqIGEgc291cmNlIG9mIGJ1Z3MgZm9yIHByb3RvY29scyBsaWtlIHJpbmcgc2lnbmF0dXJlcy4gUmlzdHJldHRvIHdhcyBjcmVhdGVkIHRvIHNvbHZlIHRoaXMuXG4gKiBSaXN0cmV0dG8gcG9pbnQgb3BlcmF0ZXMgaW4gWDpZOlo6VCBleHRlbmRlZCBjb29yZGluYXRlcyBsaWtlIEV4dGVuZGVkUG9pbnQsXG4gKiBidXQgaXQgc2hvdWxkIHdvcmsgaW4gaXRzIG93biBuYW1lc3BhY2U6IGRvIG5vdCBjb21iaW5lIHRob3NlIHR3by5cbiAqIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXJpc3RyZXR0bzI1NS1kZWNhZjQ0OFxuICovXG5jbGFzcyBSaXN0UG9pbnQge1xuICAgIC8vIFByaXZhdGUgcHJvcGVydHkgdG8gZGlzY291cmFnZSBjb21iaW5pbmcgRXh0ZW5kZWRQb2ludCArIFJpc3RyZXR0b1BvaW50XG4gICAgLy8gQWx3YXlzIHVzZSBSaXN0cmV0dG8gZW5jb2RpbmcvZGVjb2RpbmcgaW5zdGVhZC5cbiAgICBjb25zdHJ1Y3RvcihlcCkge1xuICAgICAgICB0aGlzLmVwID0gZXA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKGFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tQWZmaW5lKGFwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIHVuaWZvcm0gb3V0cHV0IG9mIDY0LWJ5dGUgaGFzaCBmdW5jdGlvbiBsaWtlIHNoYTUxMiBhbmQgY29udmVydHMgaXQgdG8gYFJpc3RyZXR0b1BvaW50YC5cbiAgICAgKiBUaGUgaGFzaC10by1ncm91cCBvcGVyYXRpb24gYXBwbGllcyBFbGxpZ2F0b3IgdHdpY2UgYW5kIGFkZHMgdGhlIHJlc3VsdHMuXG4gICAgICogKipOb3RlOioqIHRoaXMgaXMgb25lLXdheSBtYXAsIHRoZXJlIGlzIG5vIGNvbnZlcnNpb24gZnJvbSBwb2ludCB0byBoYXNoLlxuICAgICAqIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sXG4gICAgICogQHBhcmFtIGhleCA2NC1ieXRlIG91dHB1dCBvZiBhIGhhc2ggZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaFRvQ3VydmUoaGV4KSB7XG4gICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdyaXN0cmV0dG9IYXNoJywgaGV4LCA2NCk7XG4gICAgICAgIGNvbnN0IHIxID0gYnl0ZXMyNTVUb051bWJlckxFKGhleC5zbGljZSgwLCAzMikpO1xuICAgICAgICBjb25zdCBSMSA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjEpO1xuICAgICAgICBjb25zdCByMiA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXguc2xpY2UoMzIsIDY0KSk7XG4gICAgICAgIGNvbnN0IFIyID0gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KFIxLmFkZChSMikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyByaXN0cmV0dG8tZW5jb2RlZCBzdHJpbmcgdG8gcmlzdHJldHRvIHBvaW50LlxuICAgICAqIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2RlY29kaW5nLmh0bWxcbiAgICAgKiBAcGFyYW0gaGV4IFJpc3RyZXR0by1lbmNvZGVkIDMyIGJ5dGVzLiBOb3QgZXZlcnkgMzItYnl0ZSBzdHJpbmcgaXMgdmFsaWQgcmlzdHJldHRvIGVuY29kaW5nXG4gICAgICovXG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdyaXN0cmV0dG9IZXgnLCBoZXgsIDMyKTtcbiAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBlZDI1NTE5LkNVUlZFO1xuICAgICAgICBjb25zdCBQID0gZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcbiAgICAgICAgY29uc3QgbW9kID0gZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGU7XG4gICAgICAgIGNvbnN0IGVtc2cgPSAnUmlzdHJldHRvUG9pbnQuZnJvbUhleDogdGhlIGhleCBpcyBub3QgdmFsaWQgZW5jb2Rpbmcgb2YgUmlzdHJldHRvUG9pbnQnO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXMyNTVUb051bWJlckxFKGhleCk7XG4gICAgICAgIC8vIDEuIENoZWNrIHRoYXQgc19ieXRlcyBpcyB0aGUgY2Fub25pY2FsIGVuY29kaW5nIG9mIGEgZmllbGQgZWxlbWVudCwgb3IgZWxzZSBhYm9ydC5cbiAgICAgICAgLy8gMy4gQ2hlY2sgdGhhdCBzIGlzIG5vbi1uZWdhdGl2ZSwgb3IgZWxzZSBhYm9ydFxuICAgICAgICBpZiAoIWVxdWFsQnl0ZXMobnVtYmVyVG9CeXRlc0xFKHMsIDMyKSwgaGV4KSB8fCBpc05lZ2F0aXZlTEUocywgUCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZW1zZyk7XG4gICAgICAgIGNvbnN0IHMyID0gbW9kKHMgKiBzKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QoXzFuICsgYSAqIHMyKTsgLy8gNCAoYSBpcyAtMSlcbiAgICAgICAgY29uc3QgdTIgPSBtb2QoXzFuIC0gYSAqIHMyKTsgLy8gNVxuICAgICAgICBjb25zdCB1MV8yID0gbW9kKHUxICogdTEpO1xuICAgICAgICBjb25zdCB1Ml8yID0gbW9kKHUyICogdTIpO1xuICAgICAgICBjb25zdCB2ID0gbW9kKGEgKiBkICogdTFfMiAtIHUyXzIpOyAvLyA2XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWU6IEkgfSA9IGludmVydFNxcnQobW9kKHYgKiB1Ml8yKSk7IC8vIDdcbiAgICAgICAgY29uc3QgRHggPSBtb2QoSSAqIHUyKTsgLy8gOFxuICAgICAgICBjb25zdCBEeSA9IG1vZChJICogRHggKiB2KTsgLy8gOVxuICAgICAgICBsZXQgeCA9IG1vZCgocyArIHMpICogRHgpOyAvLyAxMFxuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKHgsIFApKVxuICAgICAgICAgICAgeCA9IG1vZCgteCk7IC8vIDEwXG4gICAgICAgIGNvbnN0IHkgPSBtb2QodTEgKiBEeSk7IC8vIDExXG4gICAgICAgIGNvbnN0IHQgPSBtb2QoeCAqIHkpOyAvLyAxMlxuICAgICAgICBpZiAoIWlzVmFsaWQgfHwgaXNOZWdhdGl2ZUxFKHQsIFApIHx8IHkgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlbXNnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQobmV3IGVkMjU1MTkuRXh0ZW5kZWRQb2ludCh4LCB5LCBfMW4sIHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyByaXN0cmV0dG8gcG9pbnQgdG8gVWludDhBcnJheS5cbiAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbmNvZGluZy5odG1sXG4gICAgICovXG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgbGV0IHsgZXg6IHgsIGV5OiB5LCBlejogeiwgZXQ6IHQgfSA9IHRoaXMuZXA7XG4gICAgICAgIGNvbnN0IFAgPSBlZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuICAgICAgICBjb25zdCBtb2QgPSBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QobW9kKHogKyB5KSAqIG1vZCh6IC0geSkpOyAvLyAxXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKHggKiB5KTsgLy8gMlxuICAgICAgICAvLyBTcXVhcmUgcm9vdCBhbHdheXMgZXhpc3RzXG4gICAgICAgIGNvbnN0IHUyc3EgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IGludnNxcnQgfSA9IGludmVydFNxcnQobW9kKHUxICogdTJzcSkpOyAvLyAzXG4gICAgICAgIGNvbnN0IEQxID0gbW9kKGludnNxcnQgKiB1MSk7IC8vIDRcbiAgICAgICAgY29uc3QgRDIgPSBtb2QoaW52c3FydCAqIHUyKTsgLy8gNVxuICAgICAgICBjb25zdCB6SW52ID0gbW9kKEQxICogRDIgKiB0KTsgLy8gNlxuICAgICAgICBsZXQgRDsgLy8gN1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKHQgKiB6SW52LCBQKSkge1xuICAgICAgICAgICAgbGV0IF94ID0gbW9kKHkgKiBTUVJUX00xKTtcbiAgICAgICAgICAgIGxldCBfeSA9IG1vZCh4ICogU1FSVF9NMSk7XG4gICAgICAgICAgICB4ID0gX3g7XG4gICAgICAgICAgICB5ID0gX3k7XG4gICAgICAgICAgICBEID0gbW9kKEQxICogSU5WU1FSVF9BX01JTlVTX0QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgRCA9IEQyOyAvLyA4XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRSh4ICogekludiwgUCkpXG4gICAgICAgICAgICB5ID0gbW9kKC15KTsgLy8gOVxuICAgICAgICBsZXQgcyA9IG1vZCgoeiAtIHkpICogRCk7IC8vIDEwIChjaGVjayBmb290ZXIncyBub3RlLCBubyBzcXJ0KC1hKSlcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShzLCBQKSlcbiAgICAgICAgICAgIHMgPSBtb2QoLXMpO1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKHMsIDMyKTsgLy8gMTFcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG4gICAgfVxuICAgIC8vIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGFzc2VydFJzdFBvaW50KG90aGVyKTtcbiAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSB9ID0gdGhpcy5lcDtcbiAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiB9ID0gb3RoZXIuZXA7XG4gICAgICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgICAgICAvLyAoeDEgKiB5MiA9PSB5MSAqIHgyKSB8ICh5MSAqIHkyID09IHgxICogeDIpXG4gICAgICAgIGNvbnN0IG9uZSA9IG1vZChYMSAqIFkyKSA9PT0gbW9kKFkxICogWDIpO1xuICAgICAgICBjb25zdCB0d28gPSBtb2QoWTEgKiBZMikgPT09IG1vZChYMSAqIFgyKTtcbiAgICAgICAgcmV0dXJuIG9uZSB8fCB0d287XG4gICAgfVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAuYWRkKG90aGVyLmVwKSk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIGFzc2VydFJzdFBvaW50KG90aGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5zdWJ0cmFjdChvdGhlci5lcCkpO1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5tdWx0aXBseShzY2FsYXIpKTtcbiAgICB9XG4gICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubXVsdGlwbHlVbnNhZmUoc2NhbGFyKSk7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5kb3VibGUoKSk7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5uZWdhdGUoKSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IFJpc3RyZXR0b1BvaW50ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgaWYgKCFSaXN0UG9pbnQuQkFTRSlcbiAgICAgICAgUmlzdFBvaW50LkJBU0UgPSBuZXcgUmlzdFBvaW50KGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5CQVNFKTtcbiAgICBpZiAoIVJpc3RQb2ludC5aRVJPKVxuICAgICAgICBSaXN0UG9pbnQuWkVSTyA9IG5ldyBSaXN0UG9pbnQoZWQyNTUxOS5FeHRlbmRlZFBvaW50LlpFUk8pO1xuICAgIHJldHVybiBSaXN0UG9pbnQ7XG59KSgpO1xuLy8gSGFzaGluZyB0byByaXN0cmV0dG8yNTUuIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI2FwcGVuZGl4LUJcbmV4cG9ydCBjb25zdCBoYXNoVG9SaXN0cmV0dG8yNTUgPSAobXNnLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZCA9IG9wdGlvbnMuRFNUO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKGQpIDogZDtcbiAgICBjb25zdCB1bmlmb3JtX2J5dGVzID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCA2NCwgc2hhNTEyKTtcbiAgICBjb25zdCBQID0gUmlzdFBvaW50Lmhhc2hUb0N1cnZlKHVuaWZvcm1fYnl0ZXMpO1xuICAgIHJldHVybiBQO1xufTtcbmV4cG9ydCBjb25zdCBoYXNoX3RvX3Jpc3RyZXR0bzI1NSA9IGhhc2hUb1Jpc3RyZXR0bzI1NTsgLy8gbGVnYWN5XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZDI1NTE5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+curves@1.6.0/node_modules/@noble/curves/esm/ed25519.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_assert.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_assert.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjUuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSwwREFBMEQsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ3FEO0FBQ3JELGlCQUFpQjtBQUNqQixpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjUuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgbm90ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJvb2xlYW4gZXhwZWN0ZWQsIG5vdCAke2J9YCk7XG59XG4vLyBjb3BpZWQgZnJvbSB1dGlsc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_md.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_md.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js\");\n\n\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n/**\n * Majority function, true if any two inputs is true\n */\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjUuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThDO0FBQ1M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDJDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuNS4wL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhpc3RzLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG4gKi9cbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vKipcbiAqIENob2ljZTogYSA/IGIgOiBjXG4gKi9cbmV4cG9ydCBjb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLyoqXG4gKiBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHV0cyBpcyB0cnVlXG4gKi9cbmV4cG9ydCBjb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLyoqXG4gKiBNZXJrbGUtRGFtZ2FyZCBoYXNoIGNvbnN0cnVjdGlvbiBiYXNlIGNsYXNzLlxuICogQ291bGQgYmUgdXNlZCB0byBjcmVhdGUgTUQ1LCBSSVBFTUQsIFNIQTEsIFNIQTIuXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXNoTUQgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9tZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_md.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_u64.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_u64.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjUuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lMO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEdBQUcsRUFBQztBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL21lb3cvSUNQLUhhY2thdGhvbi0yMDI0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuNS4wL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHsgZnJvbUJpZywgc3BsaXQsIHRvQmlnLCBzaHJTSCwgc2hyU0wsIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCwgcm90cjMySCwgcm90cjMyTCwgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLCBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsIH07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0IGRlZmF1bHQgdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/crypto.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/crypto.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjUuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS41LjAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha256.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha256.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjUuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQ087QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDBDQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQscUNBQXFDLDJDQUFHO0FBQ3hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQsaUNBQWlDLDJDQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyIvVXNlcnMvbWVvdy9JQ1AtSGFja2F0aG9uLTIwMjQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS41LjAvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIYXNoTUQsIENoaSwgTWFqIH0gZnJvbSAnLi9fbWQuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEyLTI1NiBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMgdG8gZXhlY3V0ZSBiaXJ0aGRheSBhdHRhY2suXG4vLyBCVEMgbmV0d29yayBpcyBkb2luZyAyXjY3IGhhc2hlcy9zZWMgYXMgcGVyIGVhcmx5IDIwMjMuXG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuZXhwb3J0IGNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbi8qKlxuICogU0hBMi0yMjQgaGFzaCBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha512.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha512.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA384: () => (/* binding */ SHA384),\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   SHA512_224: () => (/* binding */ SHA512_224),\n/* harmony export */   SHA512_256: () => (/* binding */ SHA512_256),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_md.js */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_1__.HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjUuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ047QUFDaUI7QUFDN0M7QUFDQTtBQUNBLHNEQUFzRCxxREFBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMENBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVUsa0JBQWtCLHNEQUFVLGtCQUFrQixxREFBUztBQUN6Rix3QkFBd0Isc0RBQVUsa0JBQWtCLHNEQUFVLGtCQUFrQixxREFBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVUsaUJBQWlCLHNEQUFVLGlCQUFpQixxREFBUztBQUN2Rix3QkFBd0Isc0RBQVUsaUJBQWlCLHNEQUFVLGlCQUFpQixxREFBUztBQUN2RjtBQUNBLHlCQUF5QixxREFBUztBQUNsQyx5QkFBeUIscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0U7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEYsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDLHdCQUF3QixxREFBUztBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4Riw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWUsRUFBRSxtREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQVM7QUFDakMsaUJBQWlCLHFEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDOUMsbUNBQW1DLDBEQUFlO0FBQ2xELG1DQUFtQywwREFBZTtBQUNsRCwrQkFBK0IsMERBQWU7QUFDckQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjUuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc2hNRCB9IGZyb20gJy4vX21kLmpzJztcbmltcG9ydCB1NjQgZnJvbSAnLi9fdTY0LmpzJztcbmltcG9ydCB7IHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUm91bmQgY29udGFudHMgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBbU0hBNTEyX0toLCBTSEE1MTJfS2xdID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB1NjQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpKSgpO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5jb25zdCBTSEE1MTJfV19IID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jb25zdCBTSEE1MTJfV19MID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5leHBvcnQgY2xhc3MgU0hBNTEyIGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMTI4LCA2NCwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZSB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIEFsc28gbG9va3MgY2xlYW5lciBhbmQgZWFzaWVyIHRvIHZlcmlmeSB3aXRoIHNwZWMuXG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg2YTA5ZTY2NyB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGYzYmNjOTA4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4YmI2N2FlODUgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4NGNhYTczYiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDNjNmVmMzcyIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4ZmU5NGY4MmIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHhhNTRmZjUzYSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDVmMWQzNmYxIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NTEwZTUyN2YgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhZGU2ODJkMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDliMDU2ODhjIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MmIzZTZjMWYgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgxZjgzZDlhYiB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweGZiNDFiZDZiIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NWJlMGNkMTkgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHgxMzdlMjE3OSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEE1MTJfV19ILmZpbGwoMCk7XG4gICAgICAgIFNIQTUxMl9XX0wuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg4YzNkMzdjOCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweDE5NTQ0ZGEyIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NzNlMTk5NjYgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4OWRjZDRkNiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDFkZmFiN2FlIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzJmZjljODIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg2NzlkZDUxNCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU4MmY5ZmNmIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4MGY2ZDJiNjkgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHg3YmQ0NGRhOCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDc3ZTM2ZjczIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MDRjNDg5NDIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgzZjlkODVhOCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDZhMWQzNmM4IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MTExMmU2YWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg5MWQ2OTJhMSB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4OWY1NTVmYTMgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4NmY1M2IxNTEgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4OTYyODNlZTIgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4NTM4NjM5OTIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MGViNzJkZGMgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNIQTM4NCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweGNiYmI5ZDVkIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg2MjlhMjkyYSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4OTE1OTAxNWEgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDE1MmZlY2Q4IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg2NzMzMjY2NyB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OGViNDRhODcgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweGRiMGMyZTBkIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg0N2I1NDgxZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSA0ODtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2hhNTEyID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyKCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTM4NCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTUxMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjUuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQ0M7QUFDL0MsWUFBWSxVQUFVO0FBQ3RCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0EsUUFBUSxpREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0EsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tZW93L0lDUC1IYWNrYXRob24tMjAyNC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjUuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkICgyMDI1LTA0LTMwKSwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuaW1wb3J0IHsgYnl0ZXMgYXMgYWJ5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIGV4cG9ydCB7IGlzQnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gV2UgY2FuJ3QgcmV1c2UgaXNCeXRlcyBmcm9tIF9hc3NlcnQsIGJlY2F1c2Ugc29tZWhvdyB0aGlzIGNhdXNlcyBodWdlIHBlcmYgaXNzdWVzXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RsID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuLy8gVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IGJ5dGVTd2FwID0gKHdvcmQpID0+ICgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICAgKCh3b3JkIDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKTtcbi8vIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybVxuZXhwb3J0IGNvbnN0IGJ5dGVTd2FwSWZCRSA9IGlzTEUgPyAobikgPT4gbiA6IChuKSA9PiBieXRlU3dhcChuKTtcbi8vIEluIHBsYWNlIGJ5dGUgc3dhcCBmb3IgVWludDMyQXJyYXlcbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcDMyKGFycikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJ5dGVTd2FwKGFycltpXSk7XG4gICAgfVxufVxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["pages/_app","main"], () => (__webpack_exec__("./node_modules/.pnpm/next@15.0.3_react-dom@19.0.0-rc-66855b96-20241106_react@19.0.0-rc-66855b96-20241106__react@19.0.0-rc-66855b96-20241106/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fmeow%2FICP-Hackathon-2024%2Fpages%2Ftest.tsx&page=%2Ftest!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);